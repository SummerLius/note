<!-- TOC -->

- [基本语法](#基本语法)
    - [PHP 标记](#php-标记)
    - [从 HTML 中分离](#从-html-中分离)
    - [指令分隔符](#指令分隔符)
    - [注释](#注释)
- [类型](#类型)
    - [简介](#简介)
    - [Boolean 布尔类型](#boolean-布尔类型)
    - [Integer 整型](#integer-整型)
    - [Float 浮点型](#float-浮点型)
    - [String 字符串](#string-字符串)
    - [Array 数组](#array-数组)
    - [Object 对象](#object-对象)
    - [Resource 资源类型](#resource-资源类型)
    - [NULL](#null)
    - [Callback / Callable 类型](#callback--callable-类型)
    - [本文档中使用的伪类型与变量](#本文档中使用的伪类型与变量)
    - [类型转换的判别](#类型转换的判别)
- [变量](#变量)
    - [基础](#基础)
    - [预定义变量](#预定义变量)
    - [变量范围](#变量范围)
    - [可变变量](#可变变量)
    - [来自 PHP 之外的变量](#来自-php-之外的变量)
- [常量](#常量)
    - [语法](#语法)
    - [魔术常量](#魔术常量)
- [表达式](#表达式)
- [运算符](#运算符)
    - [运算符优先级](#运算符优先级)
    - [算术运算符](#算术运算符)
    - [赋值运算符](#赋值运算符)
    - [位运算符](#位运算符)
    - [比较运算符](#比较运算符)
    - [错误控制运算符](#错误控制运算符)
    - [执行运算符](#执行运算符)
    - [递增／递减运算符](#递增／递减运算符)
    - [逻辑运算符](#逻辑运算符)
    - [字符串运算符](#字符串运算符)
    - [数组运算符](#数组运算符)
    - [类型运算符](#类型运算符)
- [流程控制](#流程控制)
    - [简介](#简介-1)
    - [if](#if)
    - [else](#else)
    - [elseif/else if](#elseifelse-if)
    - [流程控制的替代语法](#流程控制的替代语法)
    - [while](#while)
    - [do-while](#do-while)
    - [for](#for)
    - [foreach](#foreach)
    - [break](#break)
    - [continue](#continue)
    - [switch](#switch)
    - [declare](#declare)
    - [return](#return)
    - [require](#require)
    - [include](#include)
    - [require_once](#require_once)
    - [include_once](#include_once)
    - [goto](#goto)
- [函数](#函数)
    - [用户自定义函数](#用户自定义函数)
    - [函数的参数](#函数的参数)
    - [返回值](#返回值)
    - [可变函数](#可变函数)
    - [内部（内置）函数](#内部内置函数)
    - [匿名函数](#匿名函数)
- [类与对象](#类与对象)
    - [简介](#简介-2)
    - [基本概念](#基本概念)
    - [属性](#属性)
    - [类常量](#类常量)
    - [类的自动加载](#类的自动加载)
    - [构造函数和析构函数](#构造函数和析构函数)
    - [访问控制（可见性）](#访问控制可见性)
    - [对象继承](#对象继承)
    - [范围解析操作符 （::）](#范围解析操作符-)
    - [Static（静态）关键字](#static静态关键字)
    - [抽象类](#抽象类)
    - [对象接口](#对象接口)
    - [Trait](#trait)
    - [匿名类](#匿名类)
    - [重载](#重载)
    - [遍历对象](#遍历对象)
    - [魔术方法](#魔术方法)
    - [Final 关键字](#final-关键字)
    - [对象复制](#对象复制)
    - [对象比较](#对象比较)
    - [类型约束](#类型约束)
    - [后期静态绑定](#后期静态绑定)
    - [对象和引用](#对象和引用)
    - [对象序列化](#对象序列化)
    - [OOP 变更日志](#oop-变更日志)
- [命名空间](#命名空间)
    - [命名空间概述](#命名空间概述)
    - [定义命名空间](#定义命名空间)
    - [定义子命名空间](#定义子命名空间)
    - [在同一个文件中定义多个命名空间](#在同一个文件中定义多个命名空间)
    - [使用命名空间：基础](#使用命名空间基础)
    - [命名空间和动态语言特征](#命名空间和动态语言特征)
    - [namespace关键字和__NAMESPACE__常量](#namespace关键字和__namespace__常量)
    - [使用命名空间：别名/导入](#使用命名空间别名导入)
    - [全局空间](#全局空间)
    - [使用命名空间：后备全局函数/常量](#使用命名空间后备全局函数常量)
    - [名称解析规则](#名称解析规则)
    - [FAQ: things you need to know about namespaces](#faq-things-you-need-to-know-about-namespaces)
- [Errors](#errors)
    - [Basics](#basics)
    - [PHP 7 错误处理](#php-7-错误处理)
- [异常处理](#异常处理)
    - [扩展（extend） PHP 内置的异常处理类](#扩展extend-php-内置的异常处理类)
- [生成器](#生成器)
    - [生成器总览](#生成器总览)
    - [生成器语法](#生成器语法)
    - [Comparing generators with Iterator objects](#comparing-generators-with-iterator-objects)
- [引用的解释](#引用的解释)
    - [引用是什么](#引用是什么)
    - [引用做什么](#引用做什么)
    - [引用不是什么](#引用不是什么)
    - [引用传递](#引用传递)
    - [引用返回](#引用返回)
    - [取消引用](#取消引用)
    - [引用定位](#引用定位)
- [预定义变量](#预定义变量-1)
    - [超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量](#超全局变量--超全局变量是在全部作用域中始终可用的内置变量)
    - [$GLOBALS — 引用全局作用域中可用的全部变量](#globals--引用全局作用域中可用的全部变量)
    - [$_SERVER — 服务器和执行环境信息](#_server--服务器和执行环境信息)
    - [$_GET — HTTP GET 变量](#_get--http-get-变量)
    - [$_POST — HTTP POST 变量](#_post--http-post-变量)
    - [$_FILES — HTTP 文件上传变量](#_files--http-文件上传变量)
    - [$_REQUEST — HTTP Request 变量](#_request--http-request-变量)
    - [$_SESSION — Session 变量](#_session--session-变量)
    - [$_ENV — 环境变量](#_env--环境变量)
    - [$_COOKIE — HTTP Cookies](#_cookie--http-cookies)
    - [$php_errormsg — 前一个错误信息](#php_errormsg--前一个错误信息)
    - [$HTTP_RAW_POST_DATA — 原生POST数据](#http_raw_post_data--原生post数据)
    - [$http_response_header — HTTP 响应头](#http_response_header--http-响应头)
    - [$argc — 传递给脚本的参数数目](#argc--传递给脚本的参数数目)
    - [$argv — 传递给脚本的参数数组](#argv--传递给脚本的参数数组)
- [预定义异常](#预定义异常)
    - [Exception](#exception)
    - [ErrorException](#errorexception)
- [预定义接口](#预定义接口)
    - [遍历 — Traversable（遍历）接口](#遍历--traversable遍历接口)
    - [迭代器 — Iterator（迭代器）接口](#迭代器--iterator迭代器接口)
    - [聚合式迭代器 — IteratorAggregate（聚合式迭代器）接口](#聚合式迭代器--iteratoraggregate聚合式迭代器接口)
    - [数组式访问 — ArrayAccess（数组式访问）接口](#数组式访问--arrayaccess数组式访问接口)
    - [序列化 — 序列化接口](#序列化--序列化接口)
    - [Closure — Closure 类](#closure--closure-类)
    - [生成器 — 生成器类](#生成器--生成器类)
- [上下文（Context）选项和参数](#上下文context选项和参数)
    - [套接字上下文选项 — 套接字上下文选项列表](#套接字上下文选项--套接字上下文选项列表)
    - [HTTP context 选项 — HTTP context 的选项列表](#http-context-选项--http-context-的选项列表)
    - [FTP context options — FTP context option listing](#ftp-context-options--ftp-context-option-listing)
    - [SSL 上下文选项 — SSL 上下文选项清单](#ssl-上下文选项--ssl-上下文选项清单)
    - [CURL context options — CURL 上下文选项列表](#curl-context-options--curl-上下文选项列表)
    - [Phar 上下文（context）选项 — Phar 上下文（context）选项列表](#phar-上下文context选项--phar-上下文context选项列表)
    - [MongoDB context options — MongoDB context option listing](#mongodb-context-options--mongodb-context-option-listing)
    - [Context 参数 — Context 参数列表](#context-参数--context-参数列表)
- [支持的协议和封装协议](#支持的协议和封装协议)
    - [file:// — 访问本地文件系统](#file--访问本地文件系统)
    - [http:// — 访问 HTTP(s) 网址](#http--访问-https-网址)
    - [ftp:// — 访问 FTP(s) URLs](#ftp--访问-ftps-urls)
    - [php:// — 访问各个输入/输出流（I/O streams）](#php--访问各个输入输出流io-streams)
    - [zlib:// — 压缩流](#zlib--压缩流)
    - [data:// — 数据（RFC 2397）](#data--数据rfc-2397)
    - [glob:// — 查找匹配的文件路径模式](#glob--查找匹配的文件路径模式)
    - [phar:// — PHP 归档](#phar--php-归档)
    - [ssh2:// — Secure Shell 2](#ssh2--secure-shell-2)
    - [rar:// — RAR](#rar--rar)
    - [ogg:// — 音频流](#ogg--音频流)
    - [expect:// — 处理交互式的流](#expect--处理交互式的流)

<!-- /TOC -->



## 基本语法

### PHP 标记

- 当解析一个文件时，PHP 会寻找起始和结束标记，也就是 <?php 和 ?>，这告诉 PHP 开始和停止解析二者之间的代码。此种解析方式使得 PHP 可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。
- 如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。

### 从 HTML 中分离

- 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去，如下例所示。
    ```php
    <p>This is going to be ignored by PHP and displayed by the browser.</p>
    <?php echo 'While this is going to be parsed.'; ?>
    <p>This will also be ignored by PHP and displayed by the browser.</p>
    ```
- 这将如预期中的运行，因为当 PHP 解释器碰到 ?> 结束标记时就简单地将其后内容原样输出（除非马上紧接换行 - 见指令分隔符）直到碰到下一个开始标记；
- 其中有个例外情况是，处于条件语句中间时，此时 PHP 解释器会根据条件判断来决定哪些输出，哪些跳过。见下例。使用条件结构：
    ```php
    <?php if ($expression == true): ?>
      This will show if the expression is true.
    <?php else: ?>
      Otherwise this will show.
    <?php endif; ?>
    ```
- 上例中 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。由于 PHP 解释器会在条件未达成时直接跳过该段条件语句块，因此 PHP 会根据条件来忽略之。
- 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo 或 print 输出更有效率。
- 可以在 PHP 中使用四对不同的开始和结束标记。其中两种，`<?php ?>` 和 `<script language="php"> </script>` 总是可用的。另两种是短标记和 ASP 风格标记，可以在 php.ini 配置文件中打开或关闭。尽管有些人觉得短标记和 ASP 风格标记很方便，但移植性较差，通常不推荐使用。

### 指令分隔符

- 同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。
- 一段 PHP 代码中的结束标记隐含表示了一个分号。在一个 PHP 代码段中的最后一行可以不用分号结束。
- 如果后面还有新行，则代码段的结束标记包含了行结束。
- 文件末尾的 PHP 代码段结束标记可以不要，有些情况下当使用 include 或者 require 时省略掉会更好些，这样不期望的空白符就不会出现在文件末尾，之后仍然可以输出响应标头。在使用输出缓冲时也很便利，就不会看到由包含文件生成的不期望的空白符。
    ```php
    <?php
    echo "This is a test";
    ?>
    
    <?php echo "This is a test" ?>
    
    <?php echo 'We omitted the last closing tag';
    ```

### 注释

- PHP 支持 C，C++ 和 Unix Shell 风格（Perl 风格）的注释。
    ```php
    <?php
    echo "This is a test"; // This is a one-line c++ style comment
    /* This is a multi line comment
       yet another line of comment */
    echo "This is yet another test";
    echo 'One Final Test'; # This is a one-line shell-style comment
    ?>
    ```

## 类型

### 简介

- php支持9种原始数据类型：
    - 四种标量类型：
        - boolean
        - integer
        - float（也称作 double）
        - string
    - 三种复合类型：
        - array
        - object
        - callable（可调用）
    - 两种特殊类型：
        - resource（资源）
        - NULL
- 可能还会读到一些关于“双精度（double）”类型的参考。实际上 double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。
- 变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
    ```php
    <?php
    $a_bool = TRUE;   // 布尔值 boolean
    $a_str  = "foo";  // 字符串 string
    $a_str2 = 'foo';  // 字符串 string
    $an_int = 12;     // 整型 integer
    
    echo gettype($a_bool); // 输出:  boolean
    echo gettype($a_str);  // 输出:  string
    
    // 如果是整型，就加上 4
    if (is_int($an_int)) {
        $an_int += 4;
    }
    
    // 如果 $bool 是字符串，就打印出来
    // (啥也没打印出来)
    if (is_string($a_bool)) {
        echo "String: $a_bool";
    }
    ?>
    ```
- 如果要将一个变量强制转换为某类型，可以对其使用强制转换或者 settype() 函数。
- 注意变量根据其当时的类型在特定场合下会表现出不同的值。更多信息见 [类型转换的判别](#)。此外，还可以参考 [PHP 类型比较表](#) 看不同类型相互比较的例子。

### Boolean 布尔类型

- 这是最简单的类型。boolean 表达了真值，可以为 TRUE 或 FALSE。
- 语法：要指定一个布尔值，使用常量TRUE或FALSE。俩个都不区分大小写。
- 通常运算符所返回的boolean值结果会被传递给控制流程：
    ```php
    <?php
    // == 是一个操作符，它检测两个变量是否相等，并返回一个布尔值
    if ($action == "show_version") {
        echo "The version is 1.23";
    }
    
    // 这样做是不必要的...
    if ($show_separators == TRUE) {
        echo "<hr>\n";
    }
    
    // ...因为可以使用下面这种简单的方式：
    if ($show_separators) {
        echo "<hr>\n";
    }
    ?>
    ```
- 转换为布尔值
    - 要明确地将一个值转换成 boolean，用 (bool) 或者 (boolean) 来强制转换。
    - 但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。
    - 当转换为boolean时，以下值被认为是FALSE：
        - 布尔值false本身
        - 整型值0
        - 浮点值0.0
        - 空字符串，以及空字符串"0"
        - 不包括任何元素的数组
        - 特殊类型NULL（包括尚未复制的变量）
        - 从空标记生成的SimpleXML对象
    - 其它值都被认为是true（包括任何资源和NAN）
        ```php
        <?php
        var_dump((bool) "");        // bool(false)
        var_dump((bool) 1);         // bool(true)
        var_dump((bool) -2);        // bool(true)
        var_dump((bool) "foo");     // bool(true)
        var_dump((bool) 2.3e5);     // bool(true)
        var_dump((bool) array(12)); // bool(true)
        var_dump((bool) array());   // bool(false)
        var_dump((bool) "false");   // bool(true)
        ?>
        ```

### Integer 整型

- integer 是集合 ℤ = {..., -2, -1, 0, 1, 2, ...} 中的某个数。
- 语法：
    - 整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。
    - 二进制表达的 integer 自 PHP 5.4.0 起可用。
    - 要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。
    - integer语法的结构形式是：
        ```sh
        decimal     : [1-9][0-9]*
                    | 0
        
        hexadecimal : 0[xX][0-9a-fA-F]+
        
        octal       : 0[0-7]+
        
        binary      : 0b[01]+
        
        integer     : [+-]?decimal
                    | [+-]?hexadecimal
                    | [+-]?octal
                    | [+-]?binary
        ```
- 整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。64 位平台下的最大值通常是大约 9E18，除了 Windows 下 PHP 7 以前的版本，总是 32 位的。
- PHP 不支持无符号的 integer
- Integer 值的字长可以用常量 PHP_INT_SIZE来表示，自 PHP 4.4.0 和 PHP 5.0.5后，最大值可以用常量 PHP_INT_MAX 来表示，最小值可以在 PHP 7.0.0 及以后的版本中用常量 PHP_INT_MIN 表示。
- > NOTE：PHP 7 以前的版本里，如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。PHP 7 以后，会产生 Parse Error。
- 整数溢出：
    - 如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出了 integer 范围，也会返回 float。
        ```php
        # 32位系统下的整数溢出
        <?php
        $large_number = 2147483647;
        var_dump($large_number);                     // int(2147483647)
        
        $large_number = 2147483648;
        var_dump($large_number);                     // float(2147483648)
        
        $million = 1000000;
        $large_number =  50000 * $million;
        var_dump($large_number);                     // float(50000000000)
        ?>

        # 64位系统下的整数溢出
        <?php
        $large_number = 9223372036854775807;
        var_dump($large_number);                     // int(9223372036854775807)
        
        $large_number = 9223372036854775808;
        var_dump($large_number);                     // float(9.2233720368548E+18)
        
        $million = 1000000;
        $large_number =  50000000000000 * $million;
        var_dump($large_number);                     // float(5.0E+19)
        ?>
        ```
- PHP 中没有整除的运算符。1/2 产生出 float 0.5。 值可以舍弃小数部分，强制转换为 integer，或者使用 round() 函数可以更好地进行四舍五入。
    ```php
    <?php
    var_dump(25/7);         // float(3.5714285714286) 
    var_dump((int) (25/7)); // int(3)
    var_dump(round(25/7));  // float(4) 
    ?>
    ```
- 转换为整型
    - 要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换
    - 不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。
    - 还可以通过函数 intval() 来将一个值转换成整型。
    - 将 resource 转换成 integer 时， 结果会是 PHP 运行时为 resource 分配的唯一资源号。
    - 从boolean值转换，false对应0，true对应1
    - 从float值转换，将向下取整。
    - 如果浮点数超出了整数范围（32 位平台下通常为 +/- 2.15e+9 = 2^31，64 位平台下，除了 Windows，通常为 +/- 9.22e+18 = 2^63），则结果为未定义，因为没有足够的精度给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
    - > NOTE: PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。
    - > NOTE：绝不要将未知的分数强制转换为 integer，这样有时会导致不可预料的结果。
    - 从字符串转换，见string小节

### Float 浮点型

- 浮点型（也叫浮点数 float，双精度数 double 或实数 real）可以用以下任一语法定义：
    ```php
    <?php
    $a = 1.234; 
    $b = 1.2e3; 
    $c = 7E-10;
    ?>
    ```
- 浮点数的形式表示：
    ```php
    LNUM          [0-9]+
    DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
    EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
    ```
- 浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。
- 浮点数注意：
    - > Warning
    - > 浮点数的精度
    - > 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致    的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运 算时的误差传递。
    - > 此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的 二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱 的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表  示其实是类似 7.9999999999999991118...。
    - > 所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确    实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。
    - > 参见» 浮点数指南网页的简单解释。
- 转换为浮点型
    - 如果希望了解有关何时和如何将字符串转换成浮点数的信息，请参阅“字符串转换为数值”一节。对于其它类型的值，其情况类似于先将值转换成整型，然后再转换成浮点。请参阅“转换为整型”一节以获取更多信息。自 PHP 5 起，如果试图将对象转换为浮点数，会发出一条 E_NOTICE 错误消息。
- 比较浮点数
    - 如上述警告信息所言，由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。不过还是有迂回的方法来比较浮点数值的。
    - 要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。
    - $a 和 $b 在小数点后五位精度内都是相等的。
        ```php
        <?php
        $a = 1.23456789;
        $b = 1.23456780;
        $epsilon = 0.00001;
        
        if(abs($a-$b) < $epsilon) {
            echo "true";
        }
        ?>
        ```
- NAN
    - 某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。
    - 由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。

### String 字符串

- 一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。
    - > Note：string最大可以达到2GB
- 语法：
    - 字符串有4种方式表达
        - 单引号
        - 双引号
        - heredoc 语法结构
        - nowdoc 语法结构（自 PHP 5.3.0 起）
    - 单引号
        - 定义一个字符串的最简单的方法是用单引号把它包围起来
        - 要表达一个单引号自身，需在它的前面加个反斜线（`\`）来转义。要表达一个反斜线自身，则用两个反斜线（`\\`）。其它任何方式的反斜线都会被当成反斜线本身：也就是说如果想使用其它转义序列例如 `\r` 或者 `\n`，并不代表任何特殊含义，就单纯是这两个字符本身。
        - 不像双引号和 heredoc 语法结构，在单引号字符串中的变量和特殊字符的转义序列将不会被替换。
            ```php
            <?php
            echo 'this is a simple string';
            
            // 可以录入多行
            echo 'You can also have embedded newlines in 
            strings this way as it is
            okay to do';
            
            // 输出： Arnold once said: "I'll be back"
            echo 'Arnold once said: "I\'ll be back"';
            
            // 输出： You deleted C:\*.*?
            echo 'You deleted C:\\*.*?';
            
            // 输出： You deleted C:\*.*?
            echo 'You deleted C:\*.*?';
            
            // 输出： This will not expand: \n a newline
            echo 'This will not expand: \n a newline';
            
            // 输出： Variables do not $expand $either
            echo 'Variables do not $expand $either';
            ?>
            ```
    - 双引号
        - 如果字符串是包围在双引号（"）中， PHP 将对一些特殊的字符进行解析：
            ```sh
            转义字符
            
            序列    含义
            \n      换行（ASCII 字符集中的 LF 或 0x0A (10)）
            \r      回车（ASCII 字符集中的 CR 或 0x0D (13)）
            \t      水平制表符（ASCII 字符集中的 HT 或 0x09 (9)）
            \v      垂直制表符（ASCII 字符集中的 VT 或 0x0B (11)）（自 PHP 5.2.5 起）
            \e      Escape（ASCII 字符集中的 ESC 或 0x1B (27)）（自 PHP 5.4.0 起）
            \f      换页（ASCII 字符集中的 FF 或 0x0C (12)）（自 PHP 5.2.5 起）
            \\      反斜线
            \$      美元标记
            \"      双引号
            \[0-7]{1,3}     符合该正则表达式序列的是一个以八进制方式来表达的字符
            \x[0-9A-Fa-f]{1,2}      符合该正则表达式序列的是一个以十六进制方式来表达的字符
            ```
        - 和单引号字符串一样，转义任何其它字符都会导致反斜线被显示出来。PHP 5.1.1 以前，`\{$var}` 中的反斜线还不会被显示出来。
        - 用双引号定义的字符串最重要的特征是变量会被解析，详见变量解析。
    - Heredoc结构
        - 第三种表达字符串的方法是用 heredoc 句法结构：<<<。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。
        - 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。
            - > Warning
            - > 要注意的是结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 \n，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。
            - > 如果不遵守该规则导致结束标识不“干净”，PHP 将认为它不是结束标识符而继续寻找。如果在文件结束前也没有找到一个正确的结束标识符，PHP 将会在最后一行产生一个解析错误。
            - > Heredocs 结构不能用来初始化类的属性。自 PHP 5.3 起，此限制仅对 heredoc 包含变量时有效，如果不包含变量，则可以赋值。
        - Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。
        - 在 PHP 5.3.0 以后，也可以用 Heredoc 结构来初始化静态变量和类的属性和常量：
            ```php
            <?php
            // 静态变量
            function foo()
            {
                static $bar = <<<LABEL
            Nothing in here...
            LABEL;
            }
            
            // 类的常量、属性
            class foo
            {
                const BAR = <<<FOOBAR
            Constant example
            FOOBAR;
            
                public $baz = <<<FOOBAR
            Property example
            FOOBAR;
            }
            ?>
            ```
        - 自 PHP 5.3.0 起还可以在 Heredoc 结构中用双引号来声明标识符：
    - Nowdoc结构
        - Nowdoc 结构是在 PHP 5.3.0 中加入的。
        - 就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。
        - Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。
        - 这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 `<![CDATA[ ]]>` 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。
        - 一个 nowdoc 结构也用和 heredocs 结构一样的标记 <<<， 但是跟在后面的标识符要用单引号括起来，即 <<<'EOT'。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。
            ```php
            <?php
            $str = <<<'EOD'
            Example of string
            spanning multiple lines
            using nowdoc syntax.
            EOD;
            
            /* 含有变量的更复杂的示例 */
            class foo
            {
                public $foo;
                public $bar;
            
                function foo()
                {
                    $this->foo = 'Foo';
                    $this->bar = array('Bar1', 'Bar2', 'Bar3');
                }
            }
            
            $foo = new foo();
            $name = 'MyName';
            
            echo <<<'EOT'
            My name is "$name". I am printing some $foo->foo.
            Now, I am printing some {$foo->bar[1]}.
            This should not print a capital 'A': \x41
            EOT;
            ?>
            ```
        - 不象 heredoc 结构，nowdoc 结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量：
            ```php
            # 静态数据示例
            <?php
            class foo {
                public $bar = <<<'EOT'
            bar
            EOT;
            }
            ?>
            ```
- 变量解析
    - 当字符串用双引号或 heredoc 结构定义时，其中的变量将会被解析。
    - 这里共有两种语法规则：一种简单规则，一种复杂规则。
        - 简单的语法规则是最常用和最方便的，它可以用最少的代码在一个 string 中嵌入一个变量，一个 array 的值，或一个 object 的属性。
        - 复杂规则语法的显著标记是用花括号包围的表达式。
    - 简单语法
        - 当 PHP 解析器遇到一个美元符号（$）时，它会和其它很多解析器一样，去组合尽量多的标识以形成一个合法的变量名
        - 可以用{花括号}来明确变量名的界线
        - 类似的，一个 array 索引或一个 object 属性也可被解析。数组索引要用方括号（]）来表示索引结束的边际，对象属性则是和上述的变量规则相同。
            ```php
            <?php
            $juices = array("apple", "orange", "koolaid1" => "purple");
            
            echo "He drank some $juices[0] juice.".PHP_EOL;
            echo "He drank some $juices[1] juice.".PHP_EOL;
            echo "He drank some juice made of $juice[0]s.".PHP_EOL; // Won't work
            echo "He drank some $juices[koolaid1] juice.".PHP_EOL;
            
            class people {
                public $john = "John Smith";
                public $jane = "Jane Smith";
                public $robert = "Robert Paulsen";
                
                public $smith = "Smith";
            }
            
            $people = new people();
            
            echo "$people->john drank some $juices[0] juice.".PHP_EOL;
            echo "$people->john then said hello to $people->jane.".PHP_EOL;
            echo "$people->john's wife greeted $people->robert.".PHP_EOL;
            echo "$people->robert greeted the two $people->smiths."; // Won't work
            ?>
            ```
    - 复杂（花括号）语法
        - 复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。
        - 任何具有 string 表达的标量变量，数组单元或对象属性都可使用此语法。只需简单地像在 string 以外的地方那样写出表达式，然后用花括号 { 和 } 把它括起来即可。由于 { 无法被转义，只有 $ 紧挨着 { 时才会被识别。可以用 {\$ 来表达 {$。
        - 也可以在字符串中用此语法通过变量来调用类的属性。
            ```php
            <?php
            class foo {
                var $bar = 'I am bar.';
            }
            
            $foo = new foo();
            $bar = 'bar';
            $baz = array('foo', 'bar', 'baz', 'quux');
            echo "{$foo->$bar}\n";
            echo "{$foo->$baz[1]}\n";
            ?>
            ```
        - 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。
            ```php
            <?php
            // 显示所有错误
            error_reporting(E_ALL);
            
            class beers {
                const softdrink = 'rootbeer';
                public static $ale = 'ipa';
            }
            
            $rootbeer = 'A & W';
            $ipa = 'Alexander Keith\'s';
            
            // 有效，输出： I'd like an A & W
            echo "I'd like an {${beers::softdrink}}\n";
            
            // 也有效，输出： I'd like an Alexander Keith's
            echo "I'd like an {${beers::$ale}}\n";
            ?>
            ```
- 存取和修改字符串中的字符
    - string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 string 当成字符组成的 array。函数 substr() 和 substr_replace() 可用于操作多于一个字符的情况。
        - > Warning：
        - > 用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个 E_NOTICE 级别错误。用负数下标写入字符串时会产生一个 E_NOTICE 级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。
        - > PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如 ISO-8859-1 的字符串进行此类操作。
        ```php
        <?php
        // 取得字符串的第一个字符
        $str = 'This is a test.';
        $first = $str[0];
        
        // 取得字符串的第三个字符
        $third = $str[2];
        
        // 取得字符串的最后一个字符
        $str = 'This is still a test.';
        $last = $str[strlen($str)-1]; 
        
        // 修改字符串的最后一个字符
        $str = 'Look at the sea';
        $str[strlen($str)-1] = 'e';
        
        ?>
        ```
    - 自 PHP 5.4 起字符串下标必须为整数或可转换为整数的字符串，否则会发出警告。之前例如 "foo" 的下标会无声地转换成 0。
    - 用 [] 或 {} 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 NULL。
    - PHP 5.5 增加了直接在字符串原型中用 [] 或 {} 访问字符的支持。
- 有用的函数和运算符
    - 字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符没有这个功能。更多信息参考字符串运算符。
    - 对于 string 的操作有很多有用的函数。
    - 可以参考字符串函数了解大部分函数，高级的查找与替换功能可以参考正则表达式函数或 Perl 兼容正则表达式函数。
    - 另外还有 URL 字符串函数，也有加密／解密字符串的函数（mcrypt 和 mhash）。
    - 最后，可以参考字符类型函数。
- 转换成字符串
    - 一个值可以通过在其前面加上 (string) 或用 strval() 函数来转变成字符串。
    - 在一个需要字符串的表达式中，会自动转换为 string。
    - 比如在使用函数 echo 或 print 时，或在一个变量和一个 string 进行比较时，就会发生这种转换。类型和类型转换可以更好的解释下面的事情，也可参考函数 settype()。
    - 一个布尔值 boolean 的 TRUE 被转换成 string 的 "1"。Boolean 的 FALSE 被转换成 ""（空字符串）。这种转换可以在 boolean 和 string 之间相互进行。
    - 一个整数 integer 或浮点数 float 被转换为数字的字面样式的 string（包括 float 中的指数部分）。使用指数计数法的浮点数（4.1E+6）也可转换。
    - 数组 array 总是转换成字符串 "Array"，因此，echo 和 print 无法显示出该数组的内容。要显示某个单元，可以用 echo $arr['foo'] 这种结构。要显示整个数组内容见下文。
    - 在 PHP 4 中对象 object 总是被转换成字符串 "Object"，如果为了调试原因需要打印出对象的值，请继续阅读下文。为了得到对象的类的名称，可以用 get_class() 函数。自 PHP 5 起，适当时可以用 __toString 方法。
    - 资源 resource 总会被转变成 "Resource id #1" 这种结构的字符串，其中的 1 是 PHP 在运行时分配给该 resource 的唯一值。不要依赖此结构，可能会有变更。要得到一个 resource 的类型，可以用函数 get_resource_type()。
    - NULL 总是被转变成空字符串。
    - 如上面所说的，直接把 array，object 或 resource 转换成 string 不会得到除了其类型之外的任何有用信息。可以使用函数 print_r() 和 var_dump() 列出这些类型的内容。
    - 大部分的 PHP 值可以转变成 string 来永久保存，这被称作串行化，可以用函数 serialize() 来实现。如果 PHP 引擎设定支持 WDDX，PHP 值也可被串行化为格式良好的 XML 文本。
- 字符串转换为数值
    - 当一个字符串被当作一个数值来取值，其结果和类型如下：
        - 如果该字符串没有包含 '.'，'e' 或 'E' 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。
        - 该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。
            ```php
            <?php
            $foo = 1 + "10.5";                // $foo is float (11.5)
            $foo = 1 + "-1.3e3";              // $foo is float (-1299)
            $foo = 1 + "bob-1.3e3";           // $foo is integer (1)
            $foo = 1 + "bob3";                // $foo is integer (1)
            $foo = 1 + "10 Small Pigs";       // $foo is integer (11)
            $foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
            $foo = "10.0 pigs " + 1;          // $foo is float (11)
            $foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
            ?>
            ```
        - 不要想像在 C 语言中的那样，通过将一个字符转换成整数以得到其代码。使用函数 ord() 和 chr() 实现 ASCII 码和字符间的转换。
- 字符串类型详解
    - PHP 中的 string 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。并无如何将字节转换成字符的信息，由程序员来决定。
    - 字符串由什么值来组成并无限制；特别的，其值为 0（“NUL bytes”）的字节可以处于字符串任何位置（不过有几个函数，在本手册中被称为非“二进制安全”的，也许会把 NUL 字节之后的数据全都忽略）
    - 字符串类型的此特性解释了为什么 PHP 中没有单独的“byte”类型 - 已经用字符串来代替了。
    - 返回非文本值的函数 - 例如从网络套接字读取的任意数据 - 仍会返回字符串。
    - 由于 PHP 并不特别指明字符串的编码，那字符串到底是怎样编码的呢？例如字符串 "á" 到底是等于 "\xE1"（ISO-8859-1），"\xC3\xA1"（UTF-8，C form），"\x61\xCC\x81"（UTF-8，D form）还是任何其它可能的表达呢？答案是字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1，以此类推。不过这并不适用于激活了 Zend Multibyte 时；此时脚本可以是以任何方式编码的（明确指定或被自动检测）然后被转换为某种内部编码，然后字符串将被用此方式编码。注意脚本的编码有一些约束（如果激活了 Zend Multibyte 则是其内部编码）- 这意味着此编码应该是 ASCII 的兼容超集，例如 UTF-8 或 ISO-8859-1。不过要注意，依赖状态的编码其中相同的字节值可以用于首字母和非首字母而转换状态，这可能会造成问题。
    - 当然了，要做到有用，操作文本的函数必须假定字符串是如何编码的。不幸的是，PHP 关于此的函数有很多变种：
        - 某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如 substr()，strpos()，strlen() 和 strcmp()。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。
        - 某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如 htmlentities() 和 mbstring 扩展中的大部分函数。
        - 其它函数使用了当前区域（见 setlocale()），但是逐字节操作。例如 strcasecmp()，strtoupper() 和 ucfirst()。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如 strtoupper("á") 在区域设定正确并且 á 是单字节编码时会返回 "Á"。如果是用 UTF-8 编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。
        - 最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。intl 扩展和 PCRE（上例中仅在使用了 u 修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，utf8_decode() 会假定 UTF-8 编码而 utf8_encode() 会假定 ISO-8859-1 编码。
        - 最后，要书写能够正确使用 Unicode 的程序依赖于很小心地避免那些可能会损坏数据的函数。要使用来自于 intl 和 mbstring 扩展的函数。不过使用能处理 Unicode 编码的函数只是个开始。不管用何种语言提供的函数，最基本的还是了解 Unicode 规格。例如一个程序如果假定只有大写和小写，那可是大错特错。

### Array 数组

- array数组
    - PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。
    - 此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。
    - 由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。
    - 解释这些结构超出了本手册的范围，但对于每种结构至少会提供一个例子。要得到这些结构的更多信息，建议参考有关此广阔主题的其它著作。
- 语法
    - 定义数组：
        - 可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） => 值（value）对。最后一个数组单元之后的逗号可以省略。
            ```php
            array(  key =>  value
                 , ...
                 )
            // 键（key）可是是一个整数 integer 或字符串 string
            // 值（value）可以是任意类型的值

            $array = array(
                "foo" => "bar",
                "bar" => "foo",
            );
            
            // 自 PHP 5.4 起
            $array = [
                "foo" => "bar",
                "bar" => "foo",
            ];
            ```
        - 自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。
        - key 可以是 integer 或者 string。value 可以是任意类型。此外 key 会有如下的强制转换：
            - 包含有合法整型值的字符串会被转换为整型。例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值。
            - 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。
            - 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。
            - Null 会被转换为空字符串，即键名 null 实际会被储存为 ""。
            - 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。
        - 如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。
        - key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。如果指定的键名已经有了值，则该值会被覆盖。
    - 用方括号语法访问数组单元：
        - 数组单元可以通过 array[key] 语法来访问。
            ```php
            <?php
            $array = array(
                "foo" => "bar",
                42    => 24,
                "multi" => array(
                     "dimensional" => array(
                         "array" => "foo"
                     )
                )
            );
            
            var_dump($array["foo"]);
            var_dump($array[42]);
            var_dump($array["multi"]["dimensional"]["array"]);
            ?>
            ```
        - 方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）
        - 自 PHP 5.4 起可以用直接对函数或方法调用的结果进行数组解引用，在此之前只能通过一个临时变量。
        - 自 PHP 5.5 起可以直接对一个数组原型进行数组解引用。
            ```php
            <?php
            function getArray() {
                return array(1, 2, 3);
            }
            
            // on PHP 5.4
            $secondElement = getArray()[1];
            
            // previously
            $tmp = getArray();
            $secondElement = $tmp[1];
            
            // or
            list(, $secondElement) = getArray();
            ?>
            ```
        - 试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致 E_NOTICE 级别错误信息，其结果为 NULL。
    - 用方括号的语法新建、修改
        - 这是通过在方括号内指定键名来给数组赋值实现的。也可以省略键名，在这种情况下给变量名加上一对空的方括号（[]）。
        - 要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 unset() 函数。
            ```php
            <?php
            $arr = array(5 => 1, 12 => 2);
            
            $arr[] = 56;    // This is the same as $arr[13] = 56;
                            // at this point of the script
            
            $arr["x"] = 42; // This adds a new element to
                            // the array with key "x"
                            
            unset($arr[5]); // This removes the element from the array
            
            unset($arr);    // This deletes the whole array
            ?>
            ```
        - 如上所述，如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上 1（但是最小为 0）。如果当前还没有整数索引，则键名将为 0。注意这里所使用的最大整数键名不一定当前就在数组中。它只要在上次数组重新生成索引后曾经存在过就行了。以下面的例子来说明：
            ```php
            <?php
            // 创建一个简单的数组
            $array = array(1, 2, 3, 4, 5);
            print_r($array);
            
            // 现在删除其中的所有元素，但保持数组本身不变:
            foreach ($array as $i => $value) {
                unset($array[$i]);
            }
            print_r($array);
            
            // 添加一个单元（注意新的键名是 5，而不是你可能以为的 0）
            $array[] = 6;
            print_r($array);
            
            // 重新索引：
            $array = array_values($array);
            $array[] = 7;
            print_r($array);
            ?>
            ```
- 实用函数
    - 有很多操作数组的函数，请参阅[函数参考](#)章节
    - unset() 函数允许删除数组中的某个键。但要注意数组将不会重建索引。如果要删除后重建索引，可以用 array_values() 函数。
        ```php
        <?php
        $a = array(1 => 'one', 2 => 'two', 3 => 'three');
        unset($a[2]);
        /* will produce an array that would have been defined as
           $a = array(1 => 'one', 3 => 'three');
           and NOT
           $a = array(1 => 'one', 2 =>'three');
        */
        
        $b = array_values($a);
        // Now $b is array(0 => 'one', 1 =>'three')
        ?>
        ```
- 数组做什么和不做什么
    - 建议使用$foo['bar']，而不是$foo[bar]，原因见官方文档
    - ...待整理...！！！！！！！！！！！
- 转换为数组
    - 对于任意 integer，float，string，boolean 和 resource 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，(array)$scalarValue 与 array($scalarValue) 完全一样。
    - 如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 '*' 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为。
    - 将 NULL 转换为 array 会得到一个空的数组。
- 比较
    - 可以用 array_diff() 和数组运算符来比较数组。
- 示例
    - 见官方文档

### Object 对象

- 对象初始化
    - 要创建一个新的对象，使用new语句实例化一个类：
        ```php
        <?php
        class foo
        {
            function do_foo()
            {
                echo "Doing foo."; 
            }
        }
        
        $bar = new foo;
        $bar->do_foo();
        ?>
        ```
    - 详情见[类与对象](#)章节
- 转换为对象
    - 如果将一个对象转换成对象，它将不会有任何变化。
    - 如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。
    - 如果该值为 NULL，则新的实例为空。
    -  array 转换成 object 将使键名成为属性名并具有相对应的值，除了数字键，不迭代就无法被访问。

### Resource 资源类型

- 资源resource是一种特殊的变量，保存了到外部资源的一个引用。
- 资源是通过专门的函数来建立和使用的。所有这些函数以及相应资源类型见[附录](#)
    - get_resource_type()
- 转换为资源
    - 由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。
- 释放资源
    - 引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。
    - note: 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。参见[数据库永久连接](#)一章。

### NULL

- 特殊的NULL值表示一个变量没有值。NULL类型唯一可能的值就是NULL。
- 在下列情况下一个变量被认为是NULL：
    - 被赋值未NULL
    - 尚未赋值
    - 被unset()
- 语法：
    - NULL类型只有一个值，就是不区分大小写的常量NULL。
    - 参见is_null()和unset()
- 转换为NULL
    - 使用 (unset) $var 将一个变量转换为 null 将不会删除该变量或 unset 其值。仅是返回 NULL 值而已

### Callback / Callable 类型

- 自 PHP 5.4 起可用 callable 类型指定回调类型 callback。本文档基于同样理由使用 callback 类型信息。
- 一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。
- 

### 本文档中使用的伪类型与变量

- 伪类型（pseudo-types） 是 PHP 文档里用于指示参数可以使用的类型和值。 请注意，它们不是 PHP 语言里原生类型。 所以不能把伪类型用于自定义函数里的类型约束（typehint）。
- **mixed**
    - mixed 说明一个参数可以接受多种不同的（但不一定是所有的）类型。例如 gettype() 可以接受所有的 PHP 类型，str_replace() 可以接受字符串和数组。
- **number**
    - number 说明一个参数可以是 integer 或者 float。
- **callback**
    - 本文档中在 PHP 5.4 引入 callable 类型之前使用 了 callback 伪类型。二者含义完全相同。
- **array|object**
    - array|object 意思是参数既可以是 array 也可以是 object。
- **void**
    - void 作为返回类型意味着函数的返回值是无用的。void 作为参数列表意味着函数不接受任何参数。
- **...**
    - 在函数原型中，$... 表示等等的意思。当一个函数可以接受任意个参数时使用此变量名。

### 类型转换的判别

- PHP 在变量定义中不需要（或不支持）明确的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个 string 值赋给变量 $var，$var 就成了一个 string。如果又把一个integer 赋给 $var，那它就成了一个integer。
- PHP 的自动类型转换的一个例子是乘法运算符“*”。如果任何一个操作数是float，则所有的操作数都被当成float，结果也是float。否则操作数会被解释为integer，结果也是integer。注意这并没有改变这些操作数本身的类型；改变的仅是这些操作数如何被求值以及表达式本身的类型。
    ```php
    <?php
    $foo = "1";  // $foo 是字符串 (ASCII 49)
    $foo *= 2;   // $foo 现在是一个整数 (2)
    $foo = $foo * 1.3;  // $foo 现在是一个浮点数 (2.6)
    $foo = 5 * "10 Little Piggies"; // $foo 是整数 (50)
    $foo = 5 * "10 Small Pigs";     // $foo 是整数 (50)
    ?>
    ```
- 如果要强制将一个变量当作某种类型来求值，可以类型强制转换。如果要改变一个变量的类型，参见 settype()。如果想要测试本节中任何例子的话，可以用 var_dump() 函数。
- 自动转换为 数组 的行为目前没有定义。此外，由于 PHP 支持使用和数组下标同样的语法访问字符串下标，以下例子在所有 PHP 版本中都有效：
    ```php
    <?php
    $a    = 'car'; // $a is a string
    $a[0] = 'b';   // $a is still a string
    echo $a;       // bar
    ?>
    ```
- 类型强制转换
    - PHP 中的类型强制转换和 C 中的非常像：在要转换的变量之前加上用括号括起来的目标类型。
    - 允许的强制转换有：
        - (int), (integer) - 转换为整形 integer
        - (bool), (boolean) - 转换为布尔类型 boolean
        - (float), (double), (real) - 转换为浮点型 float
        - (string) - 转换为字符串 string
        - (array) - 转换为数组 array
        - (object) - 转换为对象 object
        - (unset) - 转换为 NULL (PHP 5)
    - (binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。
    - 注意在括号内允许有空格和制表符
    - 将字符串文字和变量转换为二进制字符串
        ```php
        <?php
        $binary = (binary)$string;
        $binary = b"binary string";
        ?>
        ```
    - 可以将变量放置在双引号中的方式来代替将变量转换成字符串：
        ```php
        <?php
        $foo = 10;            // $foo 是一个整数
        $str = "$foo";        // $str 是一个字符串
        $fst = (string) $foo; // $fst 也是一个字符串
        
        // 输出 "they are the same"
        if ($fst === $str) {
            echo "they are the same";
        }
        ?>
        ```
- 时在类型之间强制转换时确切地会发生什么可能不是很明显。更多信息见如下小节：
    - [转换为布尔型](https://php.net/manual/zh/language.types.boolean.php#language.types.boolean.casting)
    - [转换为整型](https://php.net/manual/zh/language.types.integer.php#language.types.integer.casting)
    - [转换为浮点型](https://php.net/manual/zh/language.types.float.php#language.types.float.casting)
    - [转换为字符串](https://php.net/manual/zh/language.types.string.php#language.types.string.casting)
    - [转换为数组](https://php.net/manual/zh/language.types.array.php#language.types.array.casting)
    - [转换为对象](https://php.net/manual/zh/language.types.object.php#language.types.object.casting)
    - [转换为资源](https://php.net/manual/zh/language.types.resource.php#language.types.resource.casting)
    - [转换为 NULL](https://php.net/manual/zh/language.types.null.php#language.types.null.casting)
    - [类型比较表](https://php.net/manual/zh/types.comparisons.php)

## 变量

### 基础

- PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。
- 变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。按照正常的正则表达式，它将被表述为：`[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*`。
- $this 是一个特殊的变量，它不能被赋值。
- 有关变量的函数，请参阅函数参考。
- PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。
- 使用引用赋值，简单地将一个 & 符号加到将要赋值的变量前（源变量）。
    ```php
    <?php
    $foo = 'Bob';              // 将 'Bob' 赋给 $foo
    $bar = &$foo;              // 通过 $bar 引用 $foo
    $bar = "My name is $bar";  // 修改 $bar 变量
    echo $bar;
    echo $foo;                 // $foo 的值也被修改
    ?>
    ```
- 虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。
- 未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 FALSE，整形和浮点型变量默认值是零，字符串型变量（例如用于 echo 中）默认值是空字符串以及数组变量的默认值是空数组。
- 依赖未初始化变量的默认值在某些情况下会有问题，例如把一个文件包含到另一个之中时碰上相同的变量名。另外把 register_globals 打开是一个主要的安全隐患。使用未初始化的变量会发出 E_NOTICE 错误，但是在向一个未初始化的数组附加单元时不会。isset() 语言结构可以用来检测一个变量是否已被初始化。

### 预定义变量

- PHP 提供了大量的预定义变量。
- 由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。
- 一些预定义变量在 PHP 以命令行形式运行时并不生效。
- 有关这些变量的详细列表，请参阅[预定义变量](https://php.net/manual/zh/reserved.variables.php)一章。
    - > Warning
    - > PHP 4.2.0 以及后续版本中，PHP 指令 register_globals 的默认值为 off。
    - > 更多相关信息，请阅读 register_globals 的配置项条目，安全一章中的使用 Register Globals，以及 PHP » 4.1.0 和 » 4.2.0 的发布公告。
    - 如果有可用的 PHP 预定义变量那最好用，如超全局数组。
- 从 PHP 4.1.0 开始，PHP 提供了一套附加的预定数组，这些数组变量包含了来自 web 服务器（如果可用），运行环境，和用户输入的数据。
- 这些数组非常特别，它们在全局范围内自动生效，例如，在任何范围内自动生效。因此通常被称为自动全局变量（autoglobals）或者超全局变量（superglobals）。（PHP 中没有用户自定义超全局变量的机制。）超全局变量罗列于下文中；但是为了得到它们的内容和关于 PHP 预定义变量的进一步的讨论以及它们的本质，请参阅预定义变量。而且，你也将注意到旧的预定义数组（$HTTP_*_VARS）仍旧存在。自 PHP 5.0.0 起, 用 register_long_arrays 设置选项可禁用 长类型的 PHP 预定义变量数组。
- 超级全局变量不能被用作函数或类方法中的可变变量。
- 尽管超全局变量和 HTTP_*_VARS 同时存在，但是它们并不是同一个变量，所以改变其中一个的值并不会对另一个产生影响。
- 如果某些 variables_order 中的变量没有设定，它们的对应的 PHP 预定义数组也是空的。


### 变量范围

- 变量的范围即它定义的上下文环境（也就是它的生效范围）。
- 大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。例如：这里变量 $a 将会在包含文件 b.inc 中生效。
    ```php
    <?php
    $a = 1;
    include 'b.inc';
    ?>
    ```
- 但是，在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如：下面这个脚本不会有任何输出，因为 echo 语句引用了一个局部版本的变量 $a，而且在这个范围内，它并没有被赋值。
    ```php
    <?php
    $a = 1; /* global scope */
    
    function Test()
    {
        echo $a; /* reference to local scope variable */
    }
    
    Test();
    ?>
    ```
- 你可能注意到 PHP 的全局变量和 C 语言有一点点不同，在 C 语言中，全局变量在函数中自动生效，除非被局部变量覆盖。这可能引起一些问题，有些人可能不小心就改变了一个全局变量。PHP 中全局变量在函数中使用时必须声明为 global。
- global关键字
    - 以下脚本的输出将是“3”。在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。
        ```php
        <?php
        $a = 1;
        $b = 2;
        
        function Sum()
        {
            global $a, $b;
        
            $b = $a + $b;
        }
        
        Sum();
        echo $b;
        ?>
        ```
    - 对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。
    - 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 `$GLOBALS` 数组。前面的例子可以写成：
        ```php
        <?php
        $a = 1;
        $b = 2;
        
        function Sum()
        {
            $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
        }
        
        Sum();
        echo $b;
        ?>
        ```
    - $GLOBALS 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。$GLOBALS 之所以在全局范围内存在，是因为 $GLOBALS 是一个超全局变量。以下范例显示了超全局变量的用处：
        ```php
        <?php
        function test_global()
        {
            // 大多数的预定义变量并不 "super"，它们需要用 'global' 关键字来使它们在函数的本地区域中有效。
            global $HTTP_POST_VARS;
        
            echo $HTTP_POST_VARS['name'];
        
            // Superglobals 在任何范围内都有效，它们并不需要 'global' 声明。Superglobals 是在 PHP 4.1.0 引入的。
            echo $_POST['name'];
        }
        ?>
        ```
- 使用静态变量
    - 变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。
    - 静态变量也提供了一种处理递归函数的方法。
    - 如果在声明中用表达式的结果对其赋值会导致解析错误。
        ```php
        <?php
        function foo(){
            static $int = 0;          // correct
            static $int = 1+2;        // wrong  (as it is an expression)
            static $int = sqrt(121);  // wrong  (as it is an expression too)
        
            $int++;
            echo $int;
        }
        ?>
        ```
    - 静态声明是在编译时解析的。
    - 在函数之外使用 global 关键字不算错。可以用于在一个函数之内包含文件时。
- 全局和静态变量的引用
    - ...待这整理...

### 可变变量

- 有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置。
    ```php
    <?php
    $a = 'hello';
    $$a = 'world';
    ?>
    ```
- 要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。
- 类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo->$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。
- 也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时（例如来自 json_decode() 或 SimpleXML）。
- 注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。

### 来自 PHP 之外的变量

- HTML 表单（GET 和 POST）
    - 当一个表单提交给 PHP 脚本时，表单中的信息会自动在脚本中可用。有很多方法访问此信息，例如：
        ```html
        <form action="foo.php" method="POST">
            Name:  <input type="text" name="username"><br />
            Email: <input type="text" name="email"><br />
            <input type="submit" name="submit" value="Submit me!" />
        </form>
        ```
        ```php
        <?php
        // 自 PHP 4.1.0 起可用
           echo $_POST['username'];
           echo $_REQUEST['username'];
        
           import_request_variables('p', 'p_');
           echo $p_username;
        
        // 自 PHP 5.0.0 起，这些长格式的预定义变量
        // 可用 register_long_arrays 指令关闭。
        
           echo $HTTP_POST_VARS['username'];
        
        // 如果 PHP 指令 register_globals = on 时可用。不过自
        // PHP 4.2.0 起默认值为 register_globals = off。
        // 不提倡使用/依赖此种方法。
        
           echo $username;
        ?>
        ```
    - [超全局数组](#)例如 [$_POST](#) 和 [$_GET](#)，自 PHP 4.1.0 起可用。
    - 变量名中的点和空格被转换成下划线。例如 `<input name="a.b" />` 变成了 $_REQUEST["a_b"]。
    - 如上所示，在 PHP 4.2.0 之前 register_globals 的默认值是 on。PHP 社区鼓励大家不要依赖此指令，建议在编码时假定其为 off。
    - magic_quotes_gpc 配置指令影响到 Get，Post 和 Cookie 的值。如果打开，值 (It's "PHP!") 会自动转换成 (It\'s \"PHP!\")。十多年前对数据库的插入需要如此转义，如今已经过时了，应该关闭。参见 addslashes()，stripslashes() 和 magic_quotes_sybase。
    - PHP 也懂得表单变量上下文中的数组（参见相关常见问题）。例如可以将相关的变量编成组，或者用此特性从多选输入框中取得值。例如，将一个表单 POST 给自己并在提交时显示数据：
        ```php
        <?php
        if (isset($_POST['action']) && $_POST['action'] == 'submitted') {
            echo '<pre>';
        
            print_r($_POST);
            echo '<a href="'. $_SERVER['PHP_SELF'] .'">Please try again</a>';
        
            echo '</pre>';
        } else {
        ?>
        <form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
            Name:  <input type="text" name="personal[name]"><br />
            Email: <input type="text" name="personal[email]"><br />
            Beer: <br>
            <select multiple name="beer[]">
                <option value="warthog">Warthog</option>
                <option value="guinness">Guinness</option>
                <option value="stuttgarter">Stuttgarter Schwabenbr</option>
            </select><br />
            <input type="hidden" name="action" value="submitted" />
            <input type="submit" name="submit" value="submit me!" />
        </form>
        <?php
        }
        ?>
        ```
    - IMAGE SUBMIT 变量名
        - 当提交表单时，可以用一幅图像代替标准的提交按钮，用类似这样的标记
            ```html
            <input type="image" src="image.gif" name="sub" />
            ```
        - 当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量 sub_x 和 sub_y。它们包含了用户点击图像的坐标。有经验的用户可能会注意到被浏览器发送的实际变量名包含的是一个点而不是下划线（即 sub.x 和 sub.y），但 PHP 自动将点转换成了下划线。
- HTTP Cookies
    - PHP 透明地支持 » RFC 6265定义中的 HTTP cookies。
    - Cookies 是一种在远端浏览器端存储数据并能追踪或识别再次访问的用户的机制。
    - 可以用 setcookie() 函数设定 cookies。Cookies 是 HTTP 信息头中的一部分，因此 SetCookie 函数必须在向浏览器发送任何输出之前调用。对于 header() 函数也有同样的限制。
    - Cookie 数据会在相应的 cookie 数据数组中可用，例如 $_COOKIE，$HTTP_COOKIE_VARS 和 $_REQUEST。更多细节和例子见 setcookie() 手册页面。
    - 如果要将多个值赋给一个 cookie 变量，必须将其赋成数组。例如：
        ```php
        <?php
          setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
          setcookie("MyCookie[bar]", 'Testing 2', time()+3600);
        ?>
        ```
    - 这将会建立两个单独的 cookie，尽管 MyCookie 在脚本中是一个单一的数组。如果想在仅仅一个 cookie 中设定多个值，考虑先在值上使用 serialize() 或 explode()。
    - 注意在浏览器中一个 cookie 会替换掉上一个同名的 cookie，除非路径或者域不同。
- 变量名中的点
    - 通常，PHP 不会改变传递给脚本中的变量名。然而应该注意到点（句号）不是 PHP 变量名中的合法字符。
    - PHP 将会自动将变量名中的点替换成下划线。
- 确定变量类型 
    - 因为 PHP 会判断变量类型并在需要时进行转换（通常情况下），因此在某一时刻给定的变量是何种类型并不明显。
    - PHP 包括几个函数可以判断变量的类型，例如：gettype()，is_array()，is_float()，is_int()，is_object() 和 is_string()。

## 常量

- 常量是一个简单值的标识符（名字）。
- 如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量）。
- 常量默认为大小写敏感。传统上常量标识符总是大写的。
- 常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。用正则表达式是这样表达的：`[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*`。
- 和 superglobals 一样，常量的范围是全局的。不用管作用区域就可以在脚本的任何地方访问常量。
    ```php
    <?php

    // 合法的常量名
    define("FOO",     "something");
    define("FOO2",    "something else");
    define("FOO_BAR", "something more");
    
    // 非法的常量名
    define("2FOO",    "something");
    
    // 下面的定义是合法的，但应该避免这样做：(自定义常量不要以__开头)
    // 也许将来有一天PHP会定义一个__FOO__的魔术常量
    // 这样就会与你的代码相冲突
    define("__FOO__", "something");
    
    ?>
    ```

### 语法

- 可以用 define() 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。
- 一个常量一旦被定义，就不能再改变或者取消定义。
- 常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。
- 可以简单的通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。
- 如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。
- 常量和（全局）变量在不同的名字空间中。这意味着例如 TRUE 和 $TRUE 是不同的。
- 如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 "CONSTANT"）。此时将发出一个 E_NOTICE 级的错误。参见手册中为什么 $foo[bar] 是错误的（除非事先用 define() 将 bar 定义为一个常量）。如果只想检查是否定义了某常量，用 defined() 函数。
- 常量和变量有如下不同：
    - 常量前面没有美元符号（$）；
    - 常量只能用 define() 函数定义，而不能通过赋值语句；php5.3后，也可以用const。
    - 常量可以不用理会变量的作用域而在任何地方定义和访问；
    - 常量一旦定义就不能被重新定义或者取消定义；
    - 常量的值只能是标量。
- 和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。
    ```php
    <?php
    define("CONSTANT", "Hello world.");
    echo CONSTANT; // outputs "Hello world."
    echo Constant; // 输出 "Constant" 并发出一个提示级别错误信息

    // 以下代码在 PHP 5.3.0 后可以正常工作
    const CONSTANT = 'Hello World';
    
    echo CONSTANT;
    ?>
    ```

### 魔术常量

- PHP 向它运行的任何脚本提供了大量的[预定义常量](https://php.net/manual/zh/reserved.constants.php)。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。
- 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 `__LINE__` 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下：
    - `__LINE__`：文件中的当前行号。
    - `__FILE__`：文件的完整路径和文件名。
    - `__DIR__`：文件所在的目录。
    - `__FUNCTION__`：函数名称。
    - `__CLASS__`：类的名称
    - `__TRAIT__`：Trait 的名字
    - `__METHOD__`：类的方法名
    - `__NAMESPACE__`：当前命名空间的名称
- 参见 get_class()，get_object_vars()，file_exists() 和 function_exists()。

## 表达式

- 表达式是 PHP 最重要的基石。
- 在 PHP 中，几乎所写的任何东西都是一个表达式。
- 简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。
- PHP 是一种面向表达式的语言，从这一方面来讲几乎一切都是表达式。
- 一些表达式可以被当成语句。
- PHP 提供了一套完整强大的表达式，而为它提供完整的文件资料已经超出了本手册的范围。上面的例子应该为你提供了一个好的关于什么是表达式和怎样构建一个有用的表达式的概念。在本手册的其余部分，我们将始终使用 expr 来表示一个有效的 PHP 表达式。

## 运算符

- 运算符是可以通过给出的一或多个值（用编程行话来说，表达式）来产生另一个值（因而整个结构成为一个表达式）的东西。

### 运算符优先级

- 运算符优先级指定了两个表达式绑定得有多“紧密”。
- 如果运算符优先级相同，那运算符的结合方向决定了该如何运算。
- 

### 算术运算符

### 赋值运算符

### 位运算符

### 比较运算符

### 错误控制运算符

### 执行运算符

### 递增／递减运算符

### 逻辑运算符

### 字符串运算符

### 数组运算符

### 类型运算符

## 流程控制

### 简介

### if

### else

### elseif/else if

### 流程控制的替代语法

### while

### do-while

### for

### foreach

### break

### continue

### switch

### declare

### return

### require

### include

### require_once

### include_once

### goto

## 函数

### 用户自定义函数

### 函数的参数

### 返回值

### 可变函数

### 内部（内置）函数

### 匿名函数

## 类与对象

### 简介

### 基本概念

### 属性

### 类常量

### 类的自动加载

### 构造函数和析构函数

### 访问控制（可见性）

### 对象继承

### 范围解析操作符 （::）

### Static（静态）关键字

### 抽象类

### 对象接口

### Trait

### 匿名类

### 重载

### 遍历对象

### 魔术方法

### Final 关键字

### 对象复制

### 对象比较

### 类型约束

### 后期静态绑定

### 对象和引用

### 对象序列化

### OOP 变更日志

## 命名空间

### 命名空间概述

### 定义命名空间

### 定义子命名空间

### 在同一个文件中定义多个命名空间

### 使用命名空间：基础

### 命名空间和动态语言特征

### namespace关键字和__NAMESPACE__常量

### 使用命名空间：别名/导入

### 全局空间

### 使用命名空间：后备全局函数/常量

### 名称解析规则

### FAQ: things you need to know about namespaces

## Errors

### Basics

### PHP 7 错误处理

## 异常处理

### 扩展（extend） PHP 内置的异常处理类

## 生成器

### 生成器总览

### 生成器语法

### Comparing generators with Iterator objects

## 引用的解释

### 引用是什么

### 引用做什么

### 引用不是什么

### 引用传递

### 引用返回

### 取消引用

### 引用定位

## 预定义变量

- 对于全部脚本而言，PHP 提供了大量的预定义变量。这些变量将所有的[外部变量](https://php.net/manual/zh/language.variables.external.php)表示成内建环境变量，并且将错误信息表示成返回头。
- 参见 FAQ “[register_globals 对我有什么影响？](https://php.net/manual/zh/faq.using.php#faq.register-globals)”
- 预定义变量
    - 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量
    - $GLOBALS — 引用全局作用域中可用的全部变量
    - $_SERVER — 服务器和执行环境信息
    - $_GET — HTTP GET 变量
    - $_POST — HTTP POST 变量
    - $_FILES — HTTP 文件上传变量
    - $_REQUEST — HTTP Request 变量
    - $_SESSION — Session 变量
    - $_ENV — 环境变量
    - $_COOKIE — HTTP Cookies
    - $php_errormsg — 前一个错误信息
    - $HTTP_RAW_POST_DATA — 原生POST数据
    - $http_response_header — HTTP 响应头
    - $argc — 传递给脚本的参数数目
    - $argv — 传递给脚本的参数数组

### 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量

- 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量
- PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。
- 超全局变量有：
    - $GLOBALS
    - $_SERVER
    - $_GET
    - $_POST
    - $_FILES
    - $_COOKIE
    - $_SESSION
    - $_REQUEST
    - $_ENV
- 如果已经弃用的 register_globals 指令被设置为 on 那么局部变量也将在脚本的全局作用域中可用。例如， $_POST['foo'] 也将以 $foo 的形式存在。
- 在函数或类方法中，超全局变量不能被用作可变变量。

### $GLOBALS — 引用全局作用域中可用的全部变量

- $GLOBALS — 引用全局作用域中可用的全部变量
- 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。
- “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 global $variable; 来访问它。
- 与所有其他超全局变量不同，$GLOBALS在PHP中总是可用的。
    ```php
    <?php
    function test() {
        $foo = "local variable";
    
        echo '$foo in global scope: ' . $GLOBALS["foo"] . "\n";
        echo '$foo in current scope: ' . $foo . "\n";
    }
    
    $foo = "Example content";
    test();
    ?>
    ```

### $_SERVER — 服务器和执行环境信息

### $_GET — HTTP GET 变量

### $_POST — HTTP POST 变量

### $_FILES — HTTP 文件上传变量

### $_REQUEST — HTTP Request 变量

### $_SESSION — Session 变量

### $_ENV — 环境变量

### $_COOKIE — HTTP Cookies

### $php_errormsg — 前一个错误信息

### $HTTP_RAW_POST_DATA — 原生POST数据

### $http_response_header — HTTP 响应头

### $argc — 传递给脚本的参数数目

### $argv — 传递给脚本的参数数组

## 预定义异常

### Exception

### ErrorException

## 预定义接口

### 遍历 — Traversable（遍历）接口

### 迭代器 — Iterator（迭代器）接口

### 聚合式迭代器 — IteratorAggregate（聚合式迭代器）接口

### 数组式访问 — ArrayAccess（数组式访问）接口

### 序列化 — 序列化接口

### Closure — Closure 类

### 生成器 — 生成器类

## 上下文（Context）选项和参数

### 套接字上下文选项 — 套接字上下文选项列表

### HTTP context 选项 — HTTP context 的选项列表

### FTP context options — FTP context option listing

### SSL 上下文选项 — SSL 上下文选项清单

### CURL context options — CURL 上下文选项列表

### Phar 上下文（context）选项 — Phar 上下文（context）选项列表

### MongoDB context options — MongoDB context option listing

### Context 参数 — Context 参数列表

## 支持的协议和封装协议

### file:// — 访问本地文件系统

### http:// — 访问 HTTP(s) 网址

### ftp:// — 访问 FTP(s) URLs

### php:// — 访问各个输入/输出流（I/O streams）

### zlib:// — 压缩流

### data:// — 数据（RFC 2397）

### glob:// — 查找匹配的文件路径模式

### phar:// — PHP 归档

### ssh2:// — Secure Shell 2

### rar:// — RAR

### ogg:// — 音频流

### expect:// — 处理交互式的流