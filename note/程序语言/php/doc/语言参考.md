<!-- TOC -->

- [基本语法](#基本语法)
    - [PHP 标记](#php-标记)
    - [从 HTML 中分离](#从-html-中分离)
    - [指令分隔符](#指令分隔符)
    - [注释](#注释)
- [类型](#类型)
    - [简介](#简介)
    - [Boolean 布尔类型](#boolean-布尔类型)
    - [Integer 整型](#integer-整型)
    - [Float 浮点型](#float-浮点型)
    - [String 字符串](#string-字符串)
    - [Array 数组](#array-数组)
    - [Object 对象](#object-对象)
    - [Resource 资源类型](#resource-资源类型)
    - [NULL](#null)
    - [Callback / Callable 类型](#callback--callable-类型)
    - [本文档中使用的伪类型与变量](#本文档中使用的伪类型与变量)
    - [类型转换的判别](#类型转换的判别)
- [变量](#变量)
    - [基础](#基础)
    - [预定义变量](#预定义变量)
    - [变量范围](#变量范围)
    - [可变变量](#可变变量)
    - [来自 PHP 之外的变量](#来自-php-之外的变量)
- [常量](#常量)
    - [语法](#语法)
    - [魔术常量](#魔术常量)
- [表达式](#表达式)
- [运算符](#运算符)
    - [运算符优先级](#运算符优先级)
    - [算术运算符](#算术运算符)
    - [赋值运算符](#赋值运算符)
    - [位运算符](#位运算符)
    - [比较运算符](#比较运算符)
    - [错误控制运算符](#错误控制运算符)
    - [执行运算符](#执行运算符)
    - [递增／递减运算符](#递增／递减运算符)
    - [逻辑运算符](#逻辑运算符)
    - [字符串运算符](#字符串运算符)
    - [数组运算符](#数组运算符)
    - [类型运算符](#类型运算符)
- [流程控制](#流程控制)
    - [简介](#简介-1)
    - [if](#if)
    - [else](#else)
    - [elseif/else if](#elseifelse-if)
    - [流程控制的替代语法](#流程控制的替代语法)
    - [while](#while)
    - [do-while](#do-while)
    - [for](#for)
    - [foreach](#foreach)
    - [break](#break)
    - [continue](#continue)
    - [switch](#switch)
    - [declare](#declare)
    - [return](#return)
    - [require](#require)
    - [include](#include)
    - [require_once](#require_once)
    - [include_once](#include_once)
    - [goto](#goto)
- [函数](#函数)
    - [用户自定义函数](#用户自定义函数)
    - [函数的参数](#函数的参数)
    - [返回值](#返回值)
    - [可变函数](#可变函数)
    - [内部（内置）函数](#内部内置函数)
    - [匿名函数](#匿名函数)
- [类与对象](#类与对象)
    - [简介](#简介-2)
    - [基本概念](#基本概念)
    - [属性](#属性)
    - [类常量](#类常量)
    - [类的自动加载](#类的自动加载)
    - [构造函数和析构函数](#构造函数和析构函数)
    - [访问控制（可见性）](#访问控制可见性)
    - [对象继承](#对象继承)
    - [范围解析操作符 （::）](#范围解析操作符-)
    - [Static（静态）关键字](#static静态关键字)
    - [抽象类](#抽象类)
    - [对象接口](#对象接口)
    - [Trait](#trait)
    - [匿名类](#匿名类)
    - [重载](#重载)
    - [遍历对象](#遍历对象)
    - [魔术方法](#魔术方法)
    - [Final 关键字](#final-关键字)
    - [对象复制](#对象复制)
    - [对象比较](#对象比较)
    - [类型约束](#类型约束)
    - [后期静态绑定](#后期静态绑定)
    - [对象和引用](#对象和引用)
    - [对象序列化](#对象序列化)
    - [OOP 变更日志](#oop-变更日志)
- [命名空间](#命名空间)
    - [命名空间概述](#命名空间概述)
    - [定义命名空间](#定义命名空间)
    - [定义子命名空间](#定义子命名空间)
    - [在同一个文件中定义多个命名空间](#在同一个文件中定义多个命名空间)
    - [使用命名空间：基础](#使用命名空间基础)
    - [命名空间和动态语言特征](#命名空间和动态语言特征)
    - [namespace关键字和__NAMESPACE__常量](#namespace关键字和__namespace__常量)
    - [使用命名空间：别名/导入](#使用命名空间别名导入)
    - [全局空间](#全局空间)
    - [使用命名空间：后备全局函数/常量](#使用命名空间后备全局函数常量)
    - [名称解析规则](#名称解析规则)
    - [FAQ: things you need to know about namespaces](#faq-things-you-need-to-know-about-namespaces)
- [Errors](#errors)
    - [Basics](#basics)
    - [PHP 7 错误处理](#php-7-错误处理)
- [异常处理](#异常处理)
    - [扩展（extend） PHP 内置的异常处理类](#扩展extend-php-内置的异常处理类)
- [生成器](#生成器)
    - [生成器总览](#生成器总览)
    - [生成器语法](#生成器语法)
    - [Comparing generators with Iterator objects](#comparing-generators-with-iterator-objects)
- [引用的解释](#引用的解释)
    - [引用是什么](#引用是什么)
    - [引用做什么](#引用做什么)
    - [引用不是什么](#引用不是什么)
    - [引用传递](#引用传递)
    - [引用返回](#引用返回)
    - [取消引用](#取消引用)
    - [引用定位](#引用定位)
- [预定义变量](#预定义变量-1)
    - [超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量](#超全局变量--超全局变量是在全部作用域中始终可用的内置变量)
    - [$GLOBALS — 引用全局作用域中可用的全部变量](#globals--引用全局作用域中可用的全部变量)
    - [$_SERVER — 服务器和执行环境信息](#_server--服务器和执行环境信息)
    - [$_GET — HTTP GET 变量](#_get--http-get-变量)
    - [$_POST — HTTP POST 变量](#_post--http-post-变量)
    - [$_FILES — HTTP 文件上传变量](#_files--http-文件上传变量)
    - [$_REQUEST — HTTP Request 变量](#_request--http-request-变量)
    - [$_SESSION — Session 变量](#_session--session-变量)
    - [$_ENV — 环境变量](#_env--环境变量)
    - [$_COOKIE — HTTP Cookies](#_cookie--http-cookies)
    - [$php_errormsg — 前一个错误信息](#php_errormsg--前一个错误信息)
    - [$HTTP_RAW_POST_DATA — 原生POST数据](#http_raw_post_data--原生post数据)
    - [$http_response_header — HTTP 响应头](#http_response_header--http-响应头)
    - [$argc — 传递给脚本的参数数目](#argc--传递给脚本的参数数目)
    - [$argv — 传递给脚本的参数数组](#argv--传递给脚本的参数数组)
- [预定义异常](#预定义异常)
    - [Exception](#exception)
    - [ErrorException](#errorexception)
- [预定义接口](#预定义接口)
    - [遍历 — Traversable（遍历）接口](#遍历--traversable遍历接口)
    - [迭代器 — Iterator（迭代器）接口](#迭代器--iterator迭代器接口)
    - [聚合式迭代器 — IteratorAggregate（聚合式迭代器）接口](#聚合式迭代器--iteratoraggregate聚合式迭代器接口)
    - [数组式访问 — ArrayAccess（数组式访问）接口](#数组式访问--arrayaccess数组式访问接口)
    - [序列化 — 序列化接口](#序列化--序列化接口)
    - [Closure — Closure 类](#closure--closure-类)
    - [生成器 — 生成器类](#生成器--生成器类)
- [上下文（Context）选项和参数](#上下文context选项和参数)
    - [套接字上下文选项 — 套接字上下文选项列表](#套接字上下文选项--套接字上下文选项列表)
    - [HTTP context 选项 — HTTP context 的选项列表](#http-context-选项--http-context-的选项列表)
    - [FTP context options — FTP context option listing](#ftp-context-options--ftp-context-option-listing)
    - [SSL 上下文选项 — SSL 上下文选项清单](#ssl-上下文选项--ssl-上下文选项清单)
    - [CURL context options — CURL 上下文选项列表](#curl-context-options--curl-上下文选项列表)
    - [Phar 上下文（context）选项 — Phar 上下文（context）选项列表](#phar-上下文context选项--phar-上下文context选项列表)
    - [MongoDB context options — MongoDB context option listing](#mongodb-context-options--mongodb-context-option-listing)
    - [Context 参数 — Context 参数列表](#context-参数--context-参数列表)
- [支持的协议和封装协议](#支持的协议和封装协议)
    - [file:// — 访问本地文件系统](#file--访问本地文件系统)
    - [http:// — 访问 HTTP(s) 网址](#http--访问-https-网址)
    - [ftp:// — 访问 FTP(s) URLs](#ftp--访问-ftps-urls)
    - [php:// — 访问各个输入/输出流（I/O streams）](#php--访问各个输入输出流io-streams)
    - [zlib:// — 压缩流](#zlib--压缩流)
    - [data:// — 数据（RFC 2397）](#data--数据rfc-2397)
    - [glob:// — 查找匹配的文件路径模式](#glob--查找匹配的文件路径模式)
    - [phar:// — PHP 归档](#phar--php-归档)
    - [ssh2:// — Secure Shell 2](#ssh2--secure-shell-2)
    - [rar:// — RAR](#rar--rar)
    - [ogg:// — 音频流](#ogg--音频流)
    - [expect:// — 处理交互式的流](#expect--处理交互式的流)

<!-- /TOC -->



## 基本语法

### PHP 标记

- 当解析一个文件时，PHP 会寻找起始和结束标记，也就是 <?php 和 ?>，这告诉 PHP 开始和停止解析二者之间的代码。此种解析方式使得 PHP 可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。
- 如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。

### 从 HTML 中分离

- 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去，如下例所示。
    ```php
    <p>This is going to be ignored by PHP and displayed by the browser.</p>
    <?php echo 'While this is going to be parsed.'; ?>
    <p>This will also be ignored by PHP and displayed by the browser.</p>
    ```
- 这将如预期中的运行，因为当 PHP 解释器碰到 ?> 结束标记时就简单地将其后内容原样输出（除非马上紧接换行 - 见指令分隔符）直到碰到下一个开始标记；
- 其中有个例外情况是，处于条件语句中间时，此时 PHP 解释器会根据条件判断来决定哪些输出，哪些跳过。见下例。使用条件结构：
    ```php
    <?php if ($expression == true): ?>
      This will show if the expression is true.
    <?php else: ?>
      Otherwise this will show.
    <?php endif; ?>
    ```
- 上例中 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。由于 PHP 解释器会在条件未达成时直接跳过该段条件语句块，因此 PHP 会根据条件来忽略之。
- 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo 或 print 输出更有效率。
- 可以在 PHP 中使用四对不同的开始和结束标记。其中两种，`<?php ?>` 和 `<script language="php"> </script>` 总是可用的。另两种是短标记和 ASP 风格标记，可以在 php.ini 配置文件中打开或关闭。尽管有些人觉得短标记和 ASP 风格标记很方便，但移植性较差，通常不推荐使用。

### 指令分隔符

- 同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。
- 一段 PHP 代码中的结束标记隐含表示了一个分号。在一个 PHP 代码段中的最后一行可以不用分号结束。
- 如果后面还有新行，则代码段的结束标记包含了行结束。
- 文件末尾的 PHP 代码段结束标记可以不要，有些情况下当使用 include 或者 require 时省略掉会更好些，这样不期望的空白符就不会出现在文件末尾，之后仍然可以输出响应标头。在使用输出缓冲时也很便利，就不会看到由包含文件生成的不期望的空白符。
    ```php
    <?php
    echo "This is a test";
    ?>
    
    <?php echo "This is a test" ?>
    
    <?php echo 'We omitted the last closing tag';
    ```

### 注释

- PHP 支持 C，C++ 和 Unix Shell 风格（Perl 风格）的注释。
    ```php
    <?php
    echo "This is a test"; // This is a one-line c++ style comment
    /* This is a multi line comment
       yet another line of comment */
    echo "This is yet another test";
    echo 'One Final Test'; # This is a one-line shell-style comment
    ?>
    ```

## 类型

### 简介

- php支持9种原始数据类型：
    - 四种标量类型：
        - boolean
        - integer
        - float（也称作 double）
        - string
    - 三种复合类型：
        - array
        - object
        - callable（可调用）
    - 两种特殊类型：
        - resource（资源）
        - NULL
- 可能还会读到一些关于“双精度（double）”类型的参考。实际上 double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。
- 变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
    ```php
    <?php
    $a_bool = TRUE;   // 布尔值 boolean
    $a_str  = "foo";  // 字符串 string
    $a_str2 = 'foo';  // 字符串 string
    $an_int = 12;     // 整型 integer
    
    echo gettype($a_bool); // 输出:  boolean
    echo gettype($a_str);  // 输出:  string
    
    // 如果是整型，就加上 4
    if (is_int($an_int)) {
        $an_int += 4;
    }
    
    // 如果 $bool 是字符串，就打印出来
    // (啥也没打印出来)
    if (is_string($a_bool)) {
        echo "String: $a_bool";
    }
    ?>
    ```
- 如果要将一个变量强制转换为某类型，可以对其使用强制转换或者 settype() 函数。
- 注意变量根据其当时的类型在特定场合下会表现出不同的值。更多信息见 [类型转换的判别](#)。此外，还可以参考 [PHP 类型比较表](#) 看不同类型相互比较的例子。

### Boolean 布尔类型

- 这是最简单的类型。boolean 表达了真值，可以为 TRUE 或 FALSE。
- 语法：要指定一个布尔值，使用常量TRUE或FALSE。俩个都不区分大小写。
- 通常运算符所返回的boolean值结果会被传递给控制流程：
    ```php
    <?php
    // == 是一个操作符，它检测两个变量是否相等，并返回一个布尔值
    if ($action == "show_version") {
        echo "The version is 1.23";
    }
    
    // 这样做是不必要的...
    if ($show_separators == TRUE) {
        echo "<hr>\n";
    }
    
    // ...因为可以使用下面这种简单的方式：
    if ($show_separators) {
        echo "<hr>\n";
    }
    ?>
    ```
- 转换为布尔值
    - 要明确地将一个值转换成 boolean，用 (bool) 或者 (boolean) 来强制转换。
    - 但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。
    - 当转换为boolean时，以下值被认为是FALSE：
        - 布尔值false本身
        - 整型值0
        - 浮点值0.0
        - 空字符串，以及空字符串"0"
        - 不包括任何元素的数组
        - 特殊类型NULL（包括尚未复制的变量）
        - 从空标记生成的SimpleXML对象
    - 其它值都被认为是true（包括任何资源和NAN）
        ```php
        <?php
        var_dump((bool) "");        // bool(false)
        var_dump((bool) 1);         // bool(true)
        var_dump((bool) -2);        // bool(true)
        var_dump((bool) "foo");     // bool(true)
        var_dump((bool) 2.3e5);     // bool(true)
        var_dump((bool) array(12)); // bool(true)
        var_dump((bool) array());   // bool(false)
        var_dump((bool) "false");   // bool(true)
        ?>
        ```

### Integer 整型

- integer 是集合 ℤ = {..., -2, -1, 0, 1, 2, ...} 中的某个数。
- 语法：
    - 整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。
    - 二进制表达的 integer 自 PHP 5.4.0 起可用。
    - 要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。
    - integer语法的结构形式是：
        ```sh
        decimal     : [1-9][0-9]*
                    | 0
        
        hexadecimal : 0[xX][0-9a-fA-F]+
        
        octal       : 0[0-7]+
        
        binary      : 0b[01]+
        
        integer     : [+-]?decimal
                    | [+-]?hexadecimal
                    | [+-]?octal
                    | [+-]?binary
        ```
- 整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。64 位平台下的最大值通常是大约 9E18，除了 Windows 下 PHP 7 以前的版本，总是 32 位的。
- PHP 不支持无符号的 integer
- Integer 值的字长可以用常量 PHP_INT_SIZE来表示，自 PHP 4.4.0 和 PHP 5.0.5后，最大值可以用常量 PHP_INT_MAX 来表示，最小值可以在 PHP 7.0.0 及以后的版本中用常量 PHP_INT_MIN 表示。
- > NOTE：PHP 7 以前的版本里，如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。PHP 7 以后，会产生 Parse Error。
- 整数溢出：
    - 如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出了 integer 范围，也会返回 float。
        ```php
        # 32位系统下的整数溢出
        <?php
        $large_number = 2147483647;
        var_dump($large_number);                     // int(2147483647)
        
        $large_number = 2147483648;
        var_dump($large_number);                     // float(2147483648)
        
        $million = 1000000;
        $large_number =  50000 * $million;
        var_dump($large_number);                     // float(50000000000)
        ?>

        # 64位系统下的整数溢出
        <?php
        $large_number = 9223372036854775807;
        var_dump($large_number);                     // int(9223372036854775807)
        
        $large_number = 9223372036854775808;
        var_dump($large_number);                     // float(9.2233720368548E+18)
        
        $million = 1000000;
        $large_number =  50000000000000 * $million;
        var_dump($large_number);                     // float(5.0E+19)
        ?>
        ```
- PHP 中没有整除的运算符。1/2 产生出 float 0.5。 值可以舍弃小数部分，强制转换为 integer，或者使用 round() 函数可以更好地进行四舍五入。
    ```php
    <?php
    var_dump(25/7);         // float(3.5714285714286) 
    var_dump((int) (25/7)); // int(3)
    var_dump(round(25/7));  // float(4) 
    ?>
    ```
- 转换为整型
    - 要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换
    - 不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。
    - 还可以通过函数 intval() 来将一个值转换成整型。
    - 将 resource 转换成 integer 时， 结果会是 PHP 运行时为 resource 分配的唯一资源号。
    - 从boolean值转换，false对应0，true对应1
    - 从float值转换，将向下取整。
    - 如果浮点数超出了整数范围（32 位平台下通常为 +/- 2.15e+9 = 2^31，64 位平台下，除了 Windows，通常为 +/- 9.22e+18 = 2^63），则结果为未定义，因为没有足够的精度给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
    - > NOTE: PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。
    - > NOTE：绝不要将未知的分数强制转换为 integer，这样有时会导致不可预料的结果。
    - 从字符串转换，见string小节

### Float 浮点型

- 浮点型（也叫浮点数 float，双精度数 double 或实数 real）可以用以下任一语法定义：
    ```php
    <?php
    $a = 1.234; 
    $b = 1.2e3; 
    $c = 7E-10;
    ?>
    ```
- 浮点数的形式表示：
    ```php
    LNUM          [0-9]+
    DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
    EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
    ```
- 浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。
- 浮点数注意：
    - > Warning
    - > 浮点数的精度
    - > 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致    的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运 算时的误差传递。
    - > 此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的 二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱 的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表  示其实是类似 7.9999999999999991118...。
    - > 所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确    实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。
    - > 参见» 浮点数指南网页的简单解释。
- 转换为浮点型
    - 如果希望了解有关何时和如何将字符串转换成浮点数的信息，请参阅“字符串转换为数值”一节。对于其它类型的值，其情况类似于先将值转换成整型，然后再转换成浮点。请参阅“转换为整型”一节以获取更多信息。自 PHP 5 起，如果试图将对象转换为浮点数，会发出一条 E_NOTICE 错误消息。
- 比较浮点数
    - 如上述警告信息所言，由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。不过还是有迂回的方法来比较浮点数值的。
    - 要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。
    - $a 和 $b 在小数点后五位精度内都是相等的。
        ```php
        <?php
        $a = 1.23456789;
        $b = 1.23456780;
        $epsilon = 0.00001;
        
        if(abs($a-$b) < $epsilon) {
            echo "true";
        }
        ?>
        ```
- NAN
    - 某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。
    - 由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。

### String 字符串

- 一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。
    - > Note：string最大可以达到2GB
- 语法：
    - 字符串有4种方式表达
        - 单引号
        - 双引号
        - heredoc 语法结构
        - nowdoc 语法结构（自 PHP 5.3.0 起）
    - 单引号
        - 定义一个字符串的最简单的方法是用单引号把它包围起来
        - 要表达一个单引号自身，需在它的前面加个反斜线（`\`）来转义。要表达一个反斜线自身，则用两个反斜线（`\\`）。其它任何方式的反斜线都会被当成反斜线本身：也就是说如果想使用其它转义序列例如 `\r` 或者 `\n`，并不代表任何特殊含义，就单纯是这两个字符本身。
        - 不像双引号和 heredoc 语法结构，在单引号字符串中的变量和特殊字符的转义序列将不会被替换。
            ```php
            <?php
            echo 'this is a simple string';
            
            // 可以录入多行
            echo 'You can also have embedded newlines in 
            strings this way as it is
            okay to do';
            
            // 输出： Arnold once said: "I'll be back"
            echo 'Arnold once said: "I\'ll be back"';
            
            // 输出： You deleted C:\*.*?
            echo 'You deleted C:\\*.*?';
            
            // 输出： You deleted C:\*.*?
            echo 'You deleted C:\*.*?';
            
            // 输出： This will not expand: \n a newline
            echo 'This will not expand: \n a newline';
            
            // 输出： Variables do not $expand $either
            echo 'Variables do not $expand $either';
            ?>
            ```
    - 双引号
        - 如果字符串是包围在双引号（"）中， PHP 将对一些特殊的字符进行解析：
            ```sh
            转义字符
            
            序列    含义
            \n      换行（ASCII 字符集中的 LF 或 0x0A (10)）
            \r      回车（ASCII 字符集中的 CR 或 0x0D (13)）
            \t      水平制表符（ASCII 字符集中的 HT 或 0x09 (9)）
            \v      垂直制表符（ASCII 字符集中的 VT 或 0x0B (11)）（自 PHP 5.2.5 起）
            \e      Escape（ASCII 字符集中的 ESC 或 0x1B (27)）（自 PHP 5.4.0 起）
            \f      换页（ASCII 字符集中的 FF 或 0x0C (12)）（自 PHP 5.2.5 起）
            \\      反斜线
            \$      美元标记
            \"      双引号
            \[0-7]{1,3}     符合该正则表达式序列的是一个以八进制方式来表达的字符
            \x[0-9A-Fa-f]{1,2}      符合该正则表达式序列的是一个以十六进制方式来表达的字符
            ```
        - 和单引号字符串一样，转义任何其它字符都会导致反斜线被显示出来。PHP 5.1.1 以前，`\{$var}` 中的反斜线还不会被显示出来。
        - 用双引号定义的字符串最重要的特征是变量会被解析，详见变量解析。
    - Heredoc结构
        - 第三种表达字符串的方法是用 heredoc 句法结构：<<<。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。
        - 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。
            - > Warning
            - > 要注意的是结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 \n，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。
            - > 如果不遵守该规则导致结束标识不“干净”，PHP 将认为它不是结束标识符而继续寻找。如果在文件结束前也没有找到一个正确的结束标识符，PHP 将会在最后一行产生一个解析错误。
            - > Heredocs 结构不能用来初始化类的属性。自 PHP 5.3 起，此限制仅对 heredoc 包含变量时有效，如果不包含变量，则可以赋值。
        - Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。
        - 在 PHP 5.3.0 以后，也可以用 Heredoc 结构来初始化静态变量和类的属性和常量：
            ```php
            <?php
            // 静态变量
            function foo()
            {
                static $bar = <<<LABEL
            Nothing in here...
            LABEL;
            }
            
            // 类的常量、属性
            class foo
            {
                const BAR = <<<FOOBAR
            Constant example
            FOOBAR;
            
                public $baz = <<<FOOBAR
            Property example
            FOOBAR;
            }
            ?>
            ```
        - 自 PHP 5.3.0 起还可以在 Heredoc 结构中用双引号来声明标识符：
    - Nowdoc结构
        - Nowdoc 结构是在 PHP 5.3.0 中加入的。
        - 就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。
        - Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。
        - 这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 `<![CDATA[ ]]>` 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。
        - 一个 nowdoc 结构也用和 heredocs 结构一样的标记 <<<， 但是跟在后面的标识符要用单引号括起来，即 <<<'EOT'。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。
            ```php
            <?php
            $str = <<<'EOD'
            Example of string
            spanning multiple lines
            using nowdoc syntax.
            EOD;
            
            /* 含有变量的更复杂的示例 */
            class foo
            {
                public $foo;
                public $bar;
            
                function foo()
                {
                    $this->foo = 'Foo';
                    $this->bar = array('Bar1', 'Bar2', 'Bar3');
                }
            }
            
            $foo = new foo();
            $name = 'MyName';
            
            echo <<<'EOT'
            My name is "$name". I am printing some $foo->foo.
            Now, I am printing some {$foo->bar[1]}.
            This should not print a capital 'A': \x41
            EOT;
            ?>
            ```
        - 不象 heredoc 结构，nowdoc 结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量：
            ```php
            # 静态数据示例
            <?php
            class foo {
                public $bar = <<<'EOT'
            bar
            EOT;
            }
            ?>
            ```
- 变量解析
    - 当字符串用双引号或 heredoc 结构定义时，其中的变量将会被解析。
    - 这里共有两种语法规则：一种简单规则，一种复杂规则。
        - 简单的语法规则是最常用和最方便的，它可以用最少的代码在一个 string 中嵌入一个变量，一个 array 的值，或一个 object 的属性。
        - 复杂规则语法的显著标记是用花括号包围的表达式。
    - 简单语法
        - 当 PHP 解析器遇到一个美元符号（$）时，它会和其它很多解析器一样，去组合尽量多的标识以形成一个合法的变量名
        - 可以用{花括号}来明确变量名的界线
        - 类似的，一个 array 索引或一个 object 属性也可被解析。数组索引要用方括号（]）来表示索引结束的边际，对象属性则是和上述的变量规则相同。
            ```php
            <?php
            $juices = array("apple", "orange", "koolaid1" => "purple");
            
            echo "He drank some $juices[0] juice.".PHP_EOL;
            echo "He drank some $juices[1] juice.".PHP_EOL;
            echo "He drank some juice made of $juice[0]s.".PHP_EOL; // Won't work
            echo "He drank some $juices[koolaid1] juice.".PHP_EOL;
            
            class people {
                public $john = "John Smith";
                public $jane = "Jane Smith";
                public $robert = "Robert Paulsen";
                
                public $smith = "Smith";
            }
            
            $people = new people();
            
            echo "$people->john drank some $juices[0] juice.".PHP_EOL;
            echo "$people->john then said hello to $people->jane.".PHP_EOL;
            echo "$people->john's wife greeted $people->robert.".PHP_EOL;
            echo "$people->robert greeted the two $people->smiths."; // Won't work
            ?>
            ```
    - 复杂（花括号）语法
        - 复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。
        - 任何具有 string 表达的标量变量，数组单元或对象属性都可使用此语法。只需简单地像在 string 以外的地方那样写出表达式，然后用花括号 { 和 } 把它括起来即可。由于 { 无法被转义，只有 $ 紧挨着 { 时才会被识别。可以用 {\$ 来表达 {$。
        - 也可以在字符串中用此语法通过变量来调用类的属性。
            ```php
            <?php
            class foo {
                var $bar = 'I am bar.';
            }
            
            $foo = new foo();
            $bar = 'bar';
            $baz = array('foo', 'bar', 'baz', 'quux');
            echo "{$foo->$bar}\n";
            echo "{$foo->$baz[1]}\n";
            ?>
            ```
        - 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。
            ```php
            <?php
            // 显示所有错误
            error_reporting(E_ALL);
            
            class beers {
                const softdrink = 'rootbeer';
                public static $ale = 'ipa';
            }
            
            $rootbeer = 'A & W';
            $ipa = 'Alexander Keith\'s';
            
            // 有效，输出： I'd like an A & W
            echo "I'd like an {${beers::softdrink}}\n";
            
            // 也有效，输出： I'd like an Alexander Keith's
            echo "I'd like an {${beers::$ale}}\n";
            ?>
            ```
- 存取和修改字符串中的字符
    - string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 string 当成字符组成的 array。函数 substr() 和 substr_replace() 可用于操作多于一个字符的情况。
        - > Warning：
        - > 用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个 E_NOTICE 级别错误。用负数下标写入字符串时会产生一个 E_NOTICE 级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。
        - > PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如 ISO-8859-1 的字符串进行此类操作。
        ```php
        <?php
        // 取得字符串的第一个字符
        $str = 'This is a test.';
        $first = $str[0];
        
        // 取得字符串的第三个字符
        $third = $str[2];
        
        // 取得字符串的最后一个字符
        $str = 'This is still a test.';
        $last = $str[strlen($str)-1]; 
        
        // 修改字符串的最后一个字符
        $str = 'Look at the sea';
        $str[strlen($str)-1] = 'e';
        
        ?>
        ```
    - 自 PHP 5.4 起字符串下标必须为整数或可转换为整数的字符串，否则会发出警告。之前例如 "foo" 的下标会无声地转换成 0。
    - 用 [] 或 {} 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 NULL。
    - PHP 5.5 增加了直接在字符串原型中用 [] 或 {} 访问字符的支持。
- 有用的函数和运算符
    - 字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符没有这个功能。更多信息参考字符串运算符。
    - 对于 string 的操作有很多有用的函数。
    - 可以参考字符串函数了解大部分函数，高级的查找与替换功能可以参考正则表达式函数或 Perl 兼容正则表达式函数。
    - 另外还有 URL 字符串函数，也有加密／解密字符串的函数（mcrypt 和 mhash）。
    - 最后，可以参考字符类型函数。
- 转换成字符串
    - 一个值可以通过在其前面加上 (string) 或用 strval() 函数来转变成字符串。
    - 在一个需要字符串的表达式中，会自动转换为 string。
    - 比如在使用函数 echo 或 print 时，或在一个变量和一个 string 进行比较时，就会发生这种转换。类型和类型转换可以更好的解释下面的事情，也可参考函数 settype()。
    - 一个布尔值 boolean 的 TRUE 被转换成 string 的 "1"。Boolean 的 FALSE 被转换成 ""（空字符串）。这种转换可以在 boolean 和 string 之间相互进行。
    - 一个整数 integer 或浮点数 float 被转换为数字的字面样式的 string（包括 float 中的指数部分）。使用指数计数法的浮点数（4.1E+6）也可转换。
    - 数组 array 总是转换成字符串 "Array"，因此，echo 和 print 无法显示出该数组的内容。要显示某个单元，可以用 echo $arr['foo'] 这种结构。要显示整个数组内容见下文。
    - 在 PHP 4 中对象 object 总是被转换成字符串 "Object"，如果为了调试原因需要打印出对象的值，请继续阅读下文。为了得到对象的类的名称，可以用 get_class() 函数。自 PHP 5 起，适当时可以用 __toString 方法。
    - 资源 resource 总会被转变成 "Resource id #1" 这种结构的字符串，其中的 1 是 PHP 在运行时分配给该 resource 的唯一值。不要依赖此结构，可能会有变更。要得到一个 resource 的类型，可以用函数 get_resource_type()。
    - NULL 总是被转变成空字符串。
    - 如上面所说的，直接把 array，object 或 resource 转换成 string 不会得到除了其类型之外的任何有用信息。可以使用函数 print_r() 和 var_dump() 列出这些类型的内容。
    - 大部分的 PHP 值可以转变成 string 来永久保存，这被称作串行化，可以用函数 serialize() 来实现。如果 PHP 引擎设定支持 WDDX，PHP 值也可被串行化为格式良好的 XML 文本。
- 字符串转换为数值
    - 当一个字符串被当作一个数值来取值，其结果和类型如下：
        - 如果该字符串没有包含 '.'，'e' 或 'E' 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。
        - 该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。
            ```php
            <?php
            $foo = 1 + "10.5";                // $foo is float (11.5)
            $foo = 1 + "-1.3e3";              // $foo is float (-1299)
            $foo = 1 + "bob-1.3e3";           // $foo is integer (1)
            $foo = 1 + "bob3";                // $foo is integer (1)
            $foo = 1 + "10 Small Pigs";       // $foo is integer (11)
            $foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
            $foo = "10.0 pigs " + 1;          // $foo is float (11)
            $foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
            ?>
            ```
        - 不要想像在 C 语言中的那样，通过将一个字符转换成整数以得到其代码。使用函数 ord() 和 chr() 实现 ASCII 码和字符间的转换。
- 字符串类型详解
    - PHP 中的 string 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。并无如何将字节转换成字符的信息，由程序员来决定。
    - 字符串由什么值来组成并无限制；特别的，其值为 0（“NUL bytes”）的字节可以处于字符串任何位置（不过有几个函数，在本手册中被称为非“二进制安全”的，也许会把 NUL 字节之后的数据全都忽略）
    - 字符串类型的此特性解释了为什么 PHP 中没有单独的“byte”类型 - 已经用字符串来代替了。
    - 返回非文本值的函数 - 例如从网络套接字读取的任意数据 - 仍会返回字符串。
    - 由于 PHP 并不特别指明字符串的编码，那字符串到底是怎样编码的呢？例如字符串 "á" 到底是等于 "\xE1"（ISO-8859-1），"\xC3\xA1"（UTF-8，C form），"\x61\xCC\x81"（UTF-8，D form）还是任何其它可能的表达呢？答案是字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1，以此类推。不过这并不适用于激活了 Zend Multibyte 时；此时脚本可以是以任何方式编码的（明确指定或被自动检测）然后被转换为某种内部编码，然后字符串将被用此方式编码。注意脚本的编码有一些约束（如果激活了 Zend Multibyte 则是其内部编码）- 这意味着此编码应该是 ASCII 的兼容超集，例如 UTF-8 或 ISO-8859-1。不过要注意，依赖状态的编码其中相同的字节值可以用于首字母和非首字母而转换状态，这可能会造成问题。
    - 当然了，要做到有用，操作文本的函数必须假定字符串是如何编码的。不幸的是，PHP 关于此的函数有很多变种：
        - 某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如 substr()，strpos()，strlen() 和 strcmp()。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。
        - 某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如 htmlentities() 和 mbstring 扩展中的大部分函数。
        - 其它函数使用了当前区域（见 setlocale()），但是逐字节操作。例如 strcasecmp()，strtoupper() 和 ucfirst()。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如 strtoupper("á") 在区域设定正确并且 á 是单字节编码时会返回 "Á"。如果是用 UTF-8 编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。
        - 最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。intl 扩展和 PCRE（上例中仅在使用了 u 修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，utf8_decode() 会假定 UTF-8 编码而 utf8_encode() 会假定 ISO-8859-1 编码。
        - 最后，要书写能够正确使用 Unicode 的程序依赖于很小心地避免那些可能会损坏数据的函数。要使用来自于 intl 和 mbstring 扩展的函数。不过使用能处理 Unicode 编码的函数只是个开始。不管用何种语言提供的函数，最基本的还是了解 Unicode 规格。例如一个程序如果假定只有大写和小写，那可是大错特错。

### Array 数组

- array数组
    - PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。
    - 此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。
    - 由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。
    - 解释这些结构超出了本手册的范围，但对于每种结构至少会提供一个例子。要得到这些结构的更多信息，建议参考有关此广阔主题的其它著作。
- 语法
- 
    

### Object 对象

- 对象初始化
    - 要创建一个新的对象，使用new语句实例化一个类：
        ```php
        <?php
        class foo
        {
            function do_foo()
            {
                echo "Doing foo."; 
            }
        }
        
        $bar = new foo;
        $bar->do_foo();
        ?>
        ```
    - 详情见[类与对象](#)章节
- 转换为对象
    - 如果将一个对象转换成对象，它将不会有任何变化。
    - 如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。
    - 如果该值为 NULL，则新的实例为空。
    -  array 转换成 object 将使键名成为属性名并具有相对应的值，除了数字键，不迭代就无法被访问。

### Resource 资源类型

- 资源resource是一种特殊的变量，保存了到外部资源的一个引用。
- 资源是通过专门的函数来建立和使用的。所有这些函数以及相应资源类型见[附录](#)
    - get_resource_type()
- 转换为资源
    - 由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。
- 释放资源
    - 引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。
    - note: 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。参见[数据库永久连接](#)一章。

### NULL

- 特殊的NULL值表示一个变量没有值。NULL类型唯一可能的值就是NULL。
- 在下列情况下一个变量被认为是NULL：
    - 被赋值未NULL
    - 尚未赋值
    - 被unset()
- 语法：
    - NULL类型只有一个值，就是不区分大小写的常量NULL。
    - 参见is_null()和unset()
- 转换为NULL
    - 使用 (unset) $var 将一个变量转换为 null 将不会删除该变量或 unset 其值。仅是返回 NULL 值而已

### Callback / Callable 类型

- 自 PHP 5.4 起可用 callable 类型指定回调类型 callback。本文档基于同样理由使用 callback 类型信息。
- 一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。
- 

### 本文档中使用的伪类型与变量

- 伪类型（pseudo-types） 是 PHP 文档里用于指示参数可以使用的类型和值。 请注意，它们不是 PHP 语言里原生类型。 所以不能把伪类型用于自定义函数里的类型约束（typehint）。
- **mixed**
    - mixed 说明一个参数可以接受多种不同的（但不一定是所有的）类型。例如 gettype() 可以接受所有的 PHP 类型，str_replace() 可以接受字符串和数组。
- **number**
    - number 说明一个参数可以是 integer 或者 float。
- **callback**
    - 本文档中在 PHP 5.4 引入 callable 类型之前使用 了 callback 伪类型。二者含义完全相同。
- **array|object**
    - array|object 意思是参数既可以是 array 也可以是 object。
- **void**
    - void 作为返回类型意味着函数的返回值是无用的。void 作为参数列表意味着函数不接受任何参数。
- **...**
    - 在函数原型中，$... 表示等等的意思。当一个函数可以接受任意个参数时使用此变量名。

### 类型转换的判别

- PHP 在变量定义中不需要（或不支持）明确的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个 string 值赋给变量 $var，$var 就成了一个 string。如果又把一个integer 赋给 $var，那它就成了一个integer。
- PHP 的自动类型转换的一个例子是乘法运算符“*”。如果任何一个操作数是float，则所有的操作数都被当成float，结果也是float。否则操作数会被解释为integer，结果也是integer。注意这并没有改变这些操作数本身的类型；改变的仅是这些操作数如何被求值以及表达式本身的类型。
    ```php
    <?php
    $foo = "1";  // $foo 是字符串 (ASCII 49)
    $foo *= 2;   // $foo 现在是一个整数 (2)
    $foo = $foo * 1.3;  // $foo 现在是一个浮点数 (2.6)
    $foo = 5 * "10 Little Piggies"; // $foo 是整数 (50)
    $foo = 5 * "10 Small Pigs";     // $foo 是整数 (50)
    ?>
    ```
- 如果要强制将一个变量当作某种类型来求值，可以类型强制转换。如果要改变一个变量的类型，参见 settype()。如果想要测试本节中任何例子的话，可以用 var_dump() 函数。
- ！！！！！！！！！！！！！！！！！！！！！

## 变量

### 基础

### 预定义变量

### 变量范围

### 可变变量

### 来自 PHP 之外的变量

## 常量

### 语法

### 魔术常量

## 表达式

## 运算符

### 运算符优先级

### 算术运算符

### 赋值运算符

### 位运算符

### 比较运算符

### 错误控制运算符

### 执行运算符

### 递增／递减运算符

### 逻辑运算符

### 字符串运算符

### 数组运算符

### 类型运算符

## 流程控制

### 简介

### if

### else

### elseif/else if

### 流程控制的替代语法

### while

### do-while

### for

### foreach

### break

### continue

### switch

### declare

### return

### require

### include

### require_once

### include_once

### goto

## 函数

### 用户自定义函数

### 函数的参数

### 返回值

### 可变函数

### 内部（内置）函数

### 匿名函数

## 类与对象

### 简介

### 基本概念

### 属性

### 类常量

### 类的自动加载

### 构造函数和析构函数

### 访问控制（可见性）

### 对象继承

### 范围解析操作符 （::）

### Static（静态）关键字

### 抽象类

### 对象接口

### Trait

### 匿名类

### 重载

### 遍历对象

### 魔术方法

### Final 关键字

### 对象复制

### 对象比较

### 类型约束

### 后期静态绑定

### 对象和引用

### 对象序列化

### OOP 变更日志

## 命名空间

### 命名空间概述

### 定义命名空间

### 定义子命名空间

### 在同一个文件中定义多个命名空间

### 使用命名空间：基础

### 命名空间和动态语言特征

### namespace关键字和__NAMESPACE__常量

### 使用命名空间：别名/导入

### 全局空间

### 使用命名空间：后备全局函数/常量

### 名称解析规则

### FAQ: things you need to know about namespaces

## Errors

### Basics

### PHP 7 错误处理

## 异常处理

### 扩展（extend） PHP 内置的异常处理类

## 生成器

### 生成器总览

### 生成器语法

### Comparing generators with Iterator objects

## 引用的解释

### 引用是什么

### 引用做什么

### 引用不是什么

### 引用传递

### 引用返回

### 取消引用

### 引用定位

## 预定义变量

### 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量

### $GLOBALS — 引用全局作用域中可用的全部变量

### $_SERVER — 服务器和执行环境信息

### $_GET — HTTP GET 变量

### $_POST — HTTP POST 变量

### $_FILES — HTTP 文件上传变量

### $_REQUEST — HTTP Request 变量

### $_SESSION — Session 变量

### $_ENV — 环境变量

### $_COOKIE — HTTP Cookies

### $php_errormsg — 前一个错误信息

### $HTTP_RAW_POST_DATA — 原生POST数据

### $http_response_header — HTTP 响应头

### $argc — 传递给脚本的参数数目

### $argv — 传递给脚本的参数数组

## 预定义异常

### Exception

### ErrorException

## 预定义接口

### 遍历 — Traversable（遍历）接口

### 迭代器 — Iterator（迭代器）接口

### 聚合式迭代器 — IteratorAggregate（聚合式迭代器）接口

### 数组式访问 — ArrayAccess（数组式访问）接口

### 序列化 — 序列化接口

### Closure — Closure 类

### 生成器 — 生成器类

## 上下文（Context）选项和参数

### 套接字上下文选项 — 套接字上下文选项列表

### HTTP context 选项 — HTTP context 的选项列表

### FTP context options — FTP context option listing

### SSL 上下文选项 — SSL 上下文选项清单

### CURL context options — CURL 上下文选项列表

### Phar 上下文（context）选项 — Phar 上下文（context）选项列表

### MongoDB context options — MongoDB context option listing

### Context 参数 — Context 参数列表

## 支持的协议和封装协议

### file:// — 访问本地文件系统

### http:// — 访问 HTTP(s) 网址

### ftp:// — 访问 FTP(s) URLs

### php:// — 访问各个输入/输出流（I/O streams）

### zlib:// — 压缩流

### data:// — 数据（RFC 2397）

### glob:// — 查找匹配的文件路径模式

### phar:// — PHP 归档

### ssh2:// — Secure Shell 2

### rar:// — RAR

### ogg:// — 音频流

### expect:// — 处理交互式的流