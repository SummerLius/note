<!-- TOC -->

- [go指南](#go指南)
    - [概要](#概要)
    - [基础](#基础)
        - [包、变量和函数](#包变量和函数)
        - [流程控制语句](#流程控制语句)
        - [更多类型](#更多类型)
    - [方法和接口](#方法和接口)
    - [并发](#并发)
    - [接下来去哪？](#接下来去哪)

<!-- /TOC -->

# go指南


## 概要

- [go 指南 地址](https://tour.go-zh.org/welcome/1)
- 本指南涵盖了该语言的大部分重要特性，主要包括：
    1. 基础 
        - 基本结构：包、变量和函数
        - 流程控制语句：for、if、else、switch和defer
        - 更多类型：struct、slice和映射
    2. 方法和接口
    3. 并发

## 基础

### 包、变量和函数

1. 包
2. 导入
3. 导出名
4. 函数
    - [类型在变量之后，这样设定的说明](https://blog.go-zh.org/gos-declaration-syntax)
5. 多值返回
6. 命名返回值
7. 变量
8. 变量的初始化
9. 短变量声明
10. 基本类型
11. 零值
    - 数值类型：0
    - 布尔类型：false
    - 字符串类型：""（空串）
12. 类型转换
    - 表达式 T(v) 将值 v 转换为类型 T。
    - 与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。否则报错。
13. 类型推导
14. 常量
    - 常量的声明与变量类似，只不过是使用 const 关键字。
    - 常量可以是字符、字符串、布尔值或数值。
    - 常量不能用 := 语法声明。
15. 数值常量

### 流程控制语句

1. for
    - Go只有一种循环结构：for 循环。
    - 基本的for循环由三部分组成，它们用分号隔开：
        - 初始化语句：在第一次迭代前执行
        - 条件表达式：在每次迭代前求值
        - 后置语句：在每次迭代的结尾执行
    - 初始化语句通常为一句短变量声明，该变量声明仅在for语句的作用域中可见。
    - 初始化语句和后置语句是可选的。
    - 和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 { } 则是必须的。
2. for是Go中的“while”
3. 无限循环
    - `for {}`
4. if
    - Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。
5. if的简短短语
    - 同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。
6. if和else
7. switch
    - switch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。
    - Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。
8. switch的求值顺序
    - switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。
9. 没有条件的switch
    - 没有条件的 switch 同 switch true 一样。
    - 这种形式能将一长串 if-then-else 写得更加清晰。
10. defer
    - defer 语句会将函数推迟到外层函数返回之后执行。
    - 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
11. defer栈
    - 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

### 更多类型

1. 指针
    - 与 C 不同，Go 没有指针运算。
2. 结构体
    - 一个结构体（struct）就是一个字段的集合。
3. 结构体字段
    - 结构体字段使用点号来访问。
4. 结构体指针
    - 结构体字段可以通过结构体指针来访问。
    - 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。
5. 结构体文法
    - 结构体文法通过直接列出字段的值来新分配一个结构体。
    - 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）
    - 特殊的前缀 & 返回一个指向结构体的指针。
6. 数组
7. 切片
    - 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。
8. 切片就像数组的引用
    - 切片并不存储任何数据，它只是描述了底层数组中的一段。
    - 更改切片的元素会修改其底层数组中对应的元素。
    - 与它共享底层数组的切片都会观测到这些修改。
9. 切片文法
    - 切片文法类似于没有长度的数组文法。
10. 切片的默认行为
    - 切片下界的默认值为 0，上界则是该切片的长度。
11. 切片的长度与容量
12. nil切片
    - 切片的零值是 nil。
    - nil 切片的长度和容量为 0 且没有底层数组。
13. 用 make 创建切片
    - 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。
14. 切片的切片
    - 切片可包含任何类型，甚至包括其它的切片。
15. 向切片追加元素
    - 为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。
16. Range
    - for 循环的 range 形式可遍历切片或映射。
    - 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。
    - 可以将下标或值赋予 _ 来忽略它。
    - 若你只需要索引，去掉 , value 的部分即可。
17. 映射
    - 映射将键映射到值。
    - 映射的零值为 nil 。nil 映射既没有键，也不能添加键。
    - make 函数会返回给定类型的映射，并将其初始化备用。
18. 映射的文法
    - 映射的文法与结构体相似，不过必须有键名。
    - 若顶级类型只是一个类型名，你可以在文法的元素中省略它。
19. 修改映射
20. 函数值
    - 函数也是值。它们可以像其它值一样传递。
    - 函数值可以用作函数的参数或返回值。
21. 函数的闭包
    - Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。
    - 例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。


## 方法和接口

1. 方法
    - Go 没有类。不过你可以为结构体类型定义方法。
    - 方法就是一类带特殊的 接收者 参数的函数。
    - 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。
    - 你也可以为非结构体类型声明方法。
2. 方法即函数
    - 记住：方法只是个带接收者参数的函数。
3. 指针接受者
4. 指针与函数
5. 方法和指针重定向
6. 选择值或指针作为接收者
7. 接口
    - 接口类型 是由一组方法签名定义的集合。
    - 接口类型的变量可以保存任何实现了这些方法的值。
8. 接口与隐式实现
9. 接口值
10. 底层值为 nil 的接口值
11. nil 接口值
12. 空接口
13. 类型断言
14. 类型选择
15. Stringer
16. 错误
17. Reader
18. 图像

## 并发

1. go程
    - Go 程（goroutine）是由 Go 运行时管理的轻量级线程。
2. 信道
3. 带缓冲的信道
4. range 和 close
5. select 语句
6. 默认选择
7. sync.Mutex

## 接下来去哪？

- [接下来去哪里？](https://tour.go-zh.org/concurrency/11)