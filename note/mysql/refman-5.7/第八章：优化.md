<!-- TOC -->

- [第八章 优化](#第八章-优化)
    - [优化概要](#优化概要)
        - [在数据库级别进行优化](#在数据库级别进行优化)
        - [在硬件级别进行优化](#在硬件级别进行优化)
        - [平衡可移植性和性能](#平衡可移植性和性能)
    - [SQL语句优化](#sql语句优化)
        - [Where子句优化](#where子句优化)
        - [范围优化](#范围优化)
        - [索引融合优化](#索引融合优化)
        - [引擎状态下推优化](#引擎状态下推优化)
        - [索引状态下推优化](#索引状态下推优化)
        - [嵌套循环连接算法](#嵌套循环连接算法)
        - [嵌套连接优化](#嵌套连接优化)
        - [左连接和右连接优化](#左连接和右连接优化)
        - [外连接简化](#外连接简化)
        - [多范围读取优化](#多范围读取优化)
        - [阻止嵌套循环和批量密钥访问连接](#阻止嵌套循环和批量密钥访问连接)
        - [IS NULL优化](#is-null优化)
        - [ORDER BY优化](#order-by优化)
        - [GROUP BY优化](#group-by优化)
        - [DISTINCT优化](#distinct优化)
        - [LIMIT查询优化](#limit查询优化)
        - [函数调用优化](#函数调用优化)
        - [行构造函数表达式优化](#行构造函数表达式优化)
        - [避免全表查询](#避免全表查询)
    - [优化和索引](#优化和索引)
        - [如何使用索引](#如何使用索引)
        - [使用主键](#使用主键)
        - [使用外键](#使用外键)
        - [列索引](#列索引)
            - [索引前缀](#索引前缀)
            - [全文索引](#全文索引)
            - [空间索引](#空间索引)
            - [MEMORY存储引擎中的索引](#memory存储引擎中的索引)
        - [多列索引](#多列索引)
        - [验证索引使用](#验证索引使用)
        - [InnoDB和MyISAM索引统计集合](#innodb和myisam索引统计集合)
        - [索引类型比较：B树和哈希](#索引类型比较b树和哈希)
        - [使用索引扩展](#使用索引扩展)
        - [优化器使用生成的列索引](#优化器使用生成的列索引)
    - [优化数据库结构](#优化数据库结构)
    - [优化InnoDB引擎下的表](#优化innodb引擎下的表)
    - [优化MyISAM引擎下的表](#优化myisam引擎下的表)
    - [理解查询执行计划/步骤](#理解查询执行计划步骤)
    - [控制查询优化器](#控制查询优化器)
    - [缓冲与缓存](#缓冲与缓存)
    - [优化锁定操作](#优化锁定操作)
    - [优化MySQL Server](#优化mysql-server)
    - [衡量/测试性能](#衡量测试性能)
    - [检查线程信息](#检查线程信息)

<!-- /TOC -->

# 第八章 优化

## 优化概要

- 数据库性能取决于数据库级别的几个因素，例如表，查询和配置设置。 这些软件结构导致硬件级别的CPU和I / O操作，您必须尽可能地降低这些操作并使其尽可能高效。 在处理数据库性能时，首先要了解软件方面的高级规则和指南，并使用挂钟时间来衡量性能。 当您成为专家时，您将了解内部发生的更多信息，并开始测量CPU周期和I / O操作等内容。
- 典型用户的目标是从现有的软件和硬件配置中获得最佳的数据库性能。 高级用户寻找改进MySQL软件本身的机会，或者开发自己的存储引擎和硬件设备来扩展MySQL生态系统。

### 在数据库级别进行优化

使数据库应用程序快速运行的最重要因素是其基本设计：
- 表格结构合理吗？ 特别是，列是否具有正确的数据类型，并且每个表是否具有适合工作类型的列？ 例如，执行频繁更新的应用程序通常具有许多表但是较少列，，而分析大量数据的应用程序通常具有很少表但是较多列。
- 是否有适当的索引来提高查询效率？
- 您是否为每个表使用适当的存储引擎，并利用您使用的每个存储引擎的优势和功能？ 特别是，选择事务存储引擎（如InnoDB）或非事务性存储引擎（如MyISAM）对性能和可伸缩性非常重要
    - > NOTE: InnoDB是新表的默认存储引擎。 实际上，先进的InnoDB性能特征意味着InnoDB表通常优于更简单的MyISAM表，尤其是对于繁忙的数据库。
- 每个表是否使用适当的行格式？ 此选择还取决于用于表的存储引擎。 特别是，压缩表使用较少的磁盘空间，因此需要较少的磁盘I / O来读取和写入数据。 压缩适用于InnoDB表的各种工作负载，以及只读MyISAM表。
- 应用程序是否使用适当的锁定策略？ 例如，通过允许共享访问，以便数据库操作可以并发运行，并在适当时请求独占访问，以便关键操作成为首要任务。 同样，存储引擎的选择也很重要。 InnoDB存储引擎可以处理大多数锁定问题而无需您的参与，从而可以在数据库中实现更好的并发性并减少代码的实验和调优量
- 用于缓存的所有内存区域是否正确？ 也就是说，足够大以容纳频繁访问的数据，但不能太大以至于它们会超载物理内存并导致分页。 要配置的主要内存区域是InnoDB缓冲池，MyISAM密钥缓存和MySQL查询缓存。

### 在硬件级别进行优化

随着数据库业务变得越来越繁忙，任何数据库应用程序最终都会达到硬件限制。 DBA必须评估是否可以调整应用程序或重新配置服务器以避免这些瓶颈，或者是否需要更多硬件资源。 系统瓶颈通常来自这些来源：
- 磁盘搜索。 磁盘需要一段时间才能找到一段数据。 对于现代磁盘，平均时间通常低于10毫秒，因此我们理论上可以做到大约100次寻找。 这个时间用新磁盘缓慢改善，并且很难针对单个表进行优化。 优化搜索时间的方法是将数据分发到多个磁盘上。
- 磁盘读写。 当磁盘位于正确位置时，我们需要读取或写入数据。 使用现代磁盘，一个磁盘可提供至少10-20MB / s的吞吐量。 这比搜索更容易优化，因为您可以从多个磁盘并行读取。
- CPU周期。 当数据在主存储器中时，我们必须处理它以获得我们的结果。 将大表与内存量相比是最常见的限制因素。 但是对于小表，速度通常不是问题。
- 内存带宽。 当CPU需要的数据量超过CPU缓存容量时，主内存带宽就成了瓶颈。 对于大多数系统来说，这是一个不常见的瓶颈，但需要注意。

### 平衡可移植性和性能


## SQL语句优化

### Where子句优化
### 范围优化
### 索引融合优化
### 引擎状态下推优化
### 索引状态下推优化
### 嵌套循环连接算法
### 嵌套连接优化
### 左连接和右连接优化
### 外连接简化
### 多范围读取优化
### 阻止嵌套循环和批量密钥访问连接
### IS NULL优化
### ORDER BY优化
### GROUP BY优化
### DISTINCT优化
### LIMIT查询优化
### 函数调用优化
### 行构造函数表达式优化
### 避免全表查询

## 优化和索引

- 提高SELECT操作性能的最佳方法是创建一个或多个列上的索引。 索引条目的作用类似于表行的指针，允许查询快速确定哪些行与WHERE子句中的条件匹配，并检索这些行的其他列值。 可以索引所有MySQL数据类型。
- 尽管为查询中使用的每个可能列创建索引很有诱惑力，但不必要的索引会浪费空间并浪费时间让MySQL确定要使用的索引。 索引还会增加插入，更新和删除的成本，因为必须更新每个索引。 您必须找到适当的平衡，以使用最佳索引集实现快速查询。


### 如何使用索引

- 索引用于快速查找具有特定列值的行。 如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。 表越大，成本越高。 如果表中有相关列的索引，MySQL可以快速确定要在数据文件中间寻找的位置，而无需查看所有数据。 这比按顺序读取每一行要快得多。
- 大多数MySQL索引（PRIMARY KEY，UNIQUE，INDEX和FULLTEXT）都存储在B树中。除了，空间数据类型的索引使用R树; MEMORY表也支持哈希索引; InnoDB对FULLTEXT索引使用反转列表。
- MySQL使用索引进行这些操作：
    - 快速查找与Where子句匹配的行。
    - 考虑消除行。 如果在多个索引之间有选择，MySQL通常使用找到最小行数（最具选择性的索引）的索引。
    - 如果表具有多列索引，则优化程序可以使用索引的任何最左前缀来查找行。 例如，如果在（col1，col2，col3）上有三列索引，则在（col1），（col1，col2）和（col1，col2，col3）上可以应用索引搜索。 有关更多信息，请参见第8.3.5节“多列索引”。
    - 执行join操作时从其他表中检索行。 如果声明它们的类型和尺寸相同，MySQL可以更有效地使用列上的索引。在此上下文中，如果将VARCHAR和CHAR声明为相同大小，则认为它们是相同的。 例如，VARCHAR（10）和CHAR（10）的大小相同，但VARCHAR（10）和CHAR（15）不是。
    - 查找特定索引列key_col的MIN（）或MAX（）值。 这是由预处理器优化的，该预处理器检查您是否在索引中的key_col之前出现的所有关键部分上使用WHERE key_part_N =常量。 在这种情况下，MySQL对每个MIN（）或MAX（）表达式执行单个键查找，并用常量替换它。 如果所有表达式都替换为常量，则查询立即返回。 例如：
        ```sql
        SELECT MIN(key_part2),MAX(key_part2)
            FROM tbl_name WHERE key_part1=10;
        ```
    - 如果对可用索引的最左前缀（例如，ORDER BY key_part1，key_part2）进行排序或分组，则对表进行排序或分组。 如果所有key后面指定DESC，则按相反顺序读取key。 请参见第8.2.1.13节“ORDER BY优化”和第8.2.1.14节“GROUP BY优化”。
    - 在某些情况下，可以优化查询以在不咨询数据行的情况下检索值。 （为查询提供所有必要结果的索引称为覆盖索引。）如果查询仅使用表中包含某些索引的列，则可以从索引树中检索所选值以获得更快的速度：
        ```sql
        SELECT key_part3 FROM tbl_name
            WHERE key_part1=1
        ```
- 对于数据量小的表，或者需要查询大多数行的大表，这种情况下，索引就不太重要。当需要访问大多数行时，顺序读取比通过索引更快。顺序读取可以最大限度地减少磁盘搜索，即使查询不需要所有行也是如此。 有关详细信息，请参见第8.2.1.19节“避免全表扫描”。
- 索引效果特别的地方就是：在大数据量表中检索较少的数据库
    
### 使用主键

- 表的主键表示您在最重要的查询中使用的列或列集。 它具有快速查询性能的关联索引。 查询性能受益于NOT NULL优化，因为它不能包含任何NULL值。 使用InnoDB存储引擎，表格数据在物理上被组织为基于主键或列执行超快速查找和排序。
- 如果您的表很大且很重要，但没有使用明显的列或列集作为主键，则可以创建一个单独的列，其中包含一个自动增量值以用作主键。 使用外键加入表时，这些唯一ID可用作指向其他表中相应行的指针。

### 使用外键

- 如果一个表有很多列，并且您查询了许多不同的列组合，那么将频率较低的数据拆分为每个都有几列的单独表可能会很有效，并通过复制数字ID将它们与主表相关联。 主表中的列。 这样，每个小表都可以有一个主键来快速查找其数据，并且您可以使用连接操作仅查询所需的列集。 根据数据的分布方式，查询可能会执行较少的I / O并占用较少的高速缓存，因为相关列在磁盘上打包在一起。 （为了最大限度地提高性能，查询尝试从磁盘读取尽可能少的数据块;只有几列的表可以在每个数据块中容纳更多行。）

### 列索引

- 最常见的索引类型涉及单个列，在数据结构中存储该列的值的副本，允许快速查找具有相应列值的行。 B树数据结构允许索引在WHERE子句中快速查找特定值，一组值或一系列值，对应于运算符，如=，>，≤，BETWEEN，IN等。
- 每个存储引擎定义每个表的最大索引数和最大索引长度。 请参阅第14章，InnoDB存储引擎和第15章，可选存储引擎。 所有存储引擎每个表至少支持16个索引，总索引长度至少为256个字节。 大多数存储引擎都有更高的限制
- 有关列索引的其他信息，请参见第13.1.14节“CREATE INDEX语法”。

#### 索引前缀

- 使用字符串列的索引规范中的col_name（N）语法，可以创建仅使用列的前N个字符的索引。 以这种方式索引列值的前缀可以使索引文件更小。 索引BLOB或TEXT列时，必须为索引指定前缀长度。 例如：
    ```sql
    CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
    ```
- 前缀最长可达1000个字节（InnoDB表为767个字节，除非您设置了innodb_large_prefix）。
    - > Note:
    - > 前缀限制以字节为单位，而CREATE TABLE，ALTER TABLE和CREATE INDEX语句中的前缀长度被解释为非二进制字符串类型（CHAR，VARCHAR，TEXT）的字符数和二进制字符串类型的字节数（BINARY， VARBINARY，BLOB）。 在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑这一点。
- 有关索引前缀的其他信息，请参见第13.1.14节“CREATE INDEX语法”。
    
#### 全文索引

> 以下还有待理解，暂不清楚···

- FULLTEXT索引用于全文搜索。 只有InnoDB和MyISAM存储引擎支持FULLTEXT索引，并且仅支持CHAR，VARCHAR和TEXT列。 索引始终发生在整个列上，并且不支持列前缀索引。 有关详细信息，请参见第12.9节“全文搜索功能”。
- 优化适用于针对单个InnoDB表的某些类型的FULLTEXT查询。 具有这些特征的查询特别有效：
    - FULLTEXT查询仅返回文档ID，或（文档ID和搜索排名）
    - FULLTEXT查询按分数的降序对匹配的行进行排序，并应用LIMIT子句来获取前N个匹配的行。 要应用此优化，必须没有WHERE子句，并且只能按降序排列单个ORDER BY子句。
    - FULLTEXT查询仅检索与搜索词匹配的行的COUNT（*）值，而没有其他WHERE子句。 将WHERE子句编码为WHERE MATCH（text）AGAINST（'other_text'），不带任何> 0比较运算符。
- 对于包含全文表达式的查询，MySQL在查询执行的优化阶段评估这些表达式。 优化器不只是查看全文表达式并进行估计，它实际上是在开发执行计划的过程中对它们进行评估。
- 这种行为的含义是，对于全文查询，EXPLAIN通常比在优化阶段没有进行表达式评估的非全文查询慢。
- 对于全文查询的EXPLAIN可能会显示由于在优化期间发生匹配而在Extra列中优化的Select表; 在这种情况下，在以后的执行期间不需要进行表访问。

#### 空间索引

- 您可以在空间数据类型上创建索引。 MyISAM和InnoDB支持空间类型的R树索引。 其他存储引擎使用B树来索引空间类型（ARCHIVE除外，它不支持空间类型索引）。

#### MEMORY存储引擎中的索引

- MEMORY存储引擎默认使用HASH索引，但也支持BTREE索引。

### 多列索引

- MySQL可以创建复合索引（即多列上的索引）。 索引最多可包含16列。 对于某些数据类型，您可以索引列的前缀（请参见第8.3.4节“列索引”）。
- MySQL可以使用多列索引查询，测试在索引文件上的所有列，或者只测试第一列，前两列，前三列等。如果你指定的列的顺序是按照索引定义的，则单个复合索引可以加速同一张表上的多张查询。（多种查询，表示指定不同的where条件）
- 多列索引可以视为排序数组，其每行的值，是联合多列索引得到值。
    - > Note
    - > ...
        ```sql
        SELECT * FROM tbl_name
            WHERE hash_col=MD5(CONCAT(val1,val2))
            AND col1=val1 AND col2=val2;
        ```


### 验证索引使用


### InnoDB和MyISAM索引统计集合


### 索引类型比较：B树和哈希


### 使用索引扩展


### 优化器使用生成的列索引



## 优化数据库结构

## 优化InnoDB引擎下的表

## 优化MyISAM引擎下的表

## 理解查询执行计划/步骤

## 控制查询优化器

## 缓冲与缓存

## 优化锁定操作

## 优化MySQL Server

## 衡量/测试性能

## 检查线程信息


