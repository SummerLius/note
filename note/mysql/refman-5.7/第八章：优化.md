<!-- TOC -->

- [第八章 优化](#第八章-优化)
    - [优化概要](#优化概要)
        - [在数据库级别进行优化](#在数据库级别进行优化)
        - [在硬件级别进行优化](#在硬件级别进行优化)
        - [平衡可移植性和性能](#平衡可移植性和性能)
    - [SQL语句优化](#sql语句优化)
        - [Where子句优化](#where子句优化)
        - [Range优化](#range优化)
        - [索引融合优化](#索引融合优化)
        - [4](#4)
        - [5](#5)
        - [6](#6)
        - [7](#7)
        - [8](#8)
        - [9](#9)
        - [10](#10)
        - [11](#11)
        - [12](#12)
        - [13](#13)
        - [14](#14)
        - [15](#15)
        - [16](#16)
        - [17](#17)
        - [18](#18)
        - [19](#19)
    - [优化和索引](#优化和索引)
        - [如何使用索引](#如何使用索引)
        - [使用主键](#使用主键)
        - [使用外键](#使用外键)
        - [列索引](#列索引)
        - [多列索引](#多列索引)
        - [验证索引使用](#验证索引使用)
        - [InnoDB和MyISAM索引统计集合](#innodb和myisam索引统计集合)
        - [索引类型比较：B树和哈希](#索引类型比较b树和哈希)
        - [使用索引扩展](#使用索引扩展)
        - [优化器使用生成的列索引](#优化器使用生成的列索引)
    - [优化数据库结构](#优化数据库结构)
    - [优化InnoDB引擎下的表](#优化innodb引擎下的表)
    - [优化MyISAM引擎下的表](#优化myisam引擎下的表)
    - [理解查询执行计划/步骤](#理解查询执行计划步骤)
    - [控制查询优化器](#控制查询优化器)
    - [缓冲与缓存](#缓冲与缓存)
    - [优化锁定操作](#优化锁定操作)
    - [优化MySQL Server](#优化mysql-server)
    - [衡量/测试性能](#衡量测试性能)
    - [检查线程信息](#检查线程信息)

<!-- /TOC -->

# 第八章 优化

## 优化概要

- 数据库性能取决于数据库级别的几个因素，例如表，查询和配置设置。 这些软件结构导致硬件级别的CPU和I / O操作，您必须尽可能地降低这些操作并使其尽可能高效。 在处理数据库性能时，首先要了解软件方面的高级规则和指南，并使用挂钟时间来衡量性能。 当您成为专家时，您将了解内部发生的更多信息，并开始测量CPU周期和I / O操作等内容。
- 典型用户的目标是从现有的软件和硬件配置中获得最佳的数据库性能。 高级用户寻找改进MySQL软件本身的机会，或者开发自己的存储引擎和硬件设备来扩展MySQL生态系统。

### 在数据库级别进行优化

使数据库应用程序快速运行的最重要因素是其基本设计：
- 表格结构合理吗？ 特别是，列是否具有正确的数据类型，并且每个表是否具有适合工作类型的列？ 例如，执行频繁更新的应用程序通常具有许多表但是较少列，，而分析大量数据的应用程序通常具有很少表但是较多列。
- 是否有适当的索引来提高查询效率？
- 您是否为每个表使用适当的存储引擎，并利用您使用的每个存储引擎的优势和功能？ 特别是，选择事务存储引擎（如InnoDB）或非事务性存储引擎（如MyISAM）对性能和可伸缩性非常重要
    - > NOTE: InnoDB是新表的默认存储引擎。 实际上，先进的InnoDB性能特征意味着InnoDB表通常优于更简单的MyISAM表，尤其是对于繁忙的数据库。
- 每个表是否使用适当的行格式？ 此选择还取决于用于表的存储引擎。 特别是，压缩表使用较少的磁盘空间，因此需要较少的磁盘I / O来读取和写入数据。 压缩适用于InnoDB表的各种工作负载，以及只读MyISAM表。
- 应用程序是否使用适当的锁定策略？ 例如，通过允许共享访问，以便数据库操作可以并发运行，并在适当时请求独占访问，以便关键操作成为首要任务。 同样，存储引擎的选择也很重要。 InnoDB存储引擎可以处理大多数锁定问题而无需您的参与，从而可以在数据库中实现更好的并发性并减少代码的实验和调优量
- 用于缓存的所有内存区域是否正确？ 也就是说，足够大以容纳频繁访问的数据，但不能太大以至于它们会超载物理内存并导致分页。 要配置的主要内存区域是InnoDB缓冲池，MyISAM密钥缓存和MySQL查询缓存。

### 在硬件级别进行优化

随着数据库业务变得越来越繁忙，任何数据库应用程序最终都会达到硬件限制。 DBA必须评估是否可以调整应用程序或重新配置服务器以避免这些瓶颈，或者是否需要更多硬件资源。 系统瓶颈通常来自这些来源：
- 磁盘搜索。 磁盘需要一段时间才能找到一段数据。 对于现代磁盘，平均时间通常低于10毫秒，因此我们理论上可以做到大约100次寻找。 这个时间用新磁盘缓慢改善，并且很难针对单个表进行优化。 优化搜索时间的方法是将数据分发到多个磁盘上。
- 磁盘读写。 当磁盘位于正确位置时，我们需要读取或写入数据。 使用现代磁盘，一个磁盘可提供至少10-20MB / s的吞吐量。 这比搜索更容易优化，因为您可以从多个磁盘并行读取。
- CPU周期。 当数据在主存储器中时，我们必须处理它以获得我们的结果。 将大表与内存量相比是最常见的限制因素。 但是对于小表，速度通常不是问题。
- 内存带宽。 当CPU需要的数据量超过CPU缓存容量时，主内存带宽就成了瓶颈。 对于大多数系统来说，这是一个不常见的瓶颈，但需要注意。

### 平衡可移植性和性能


## SQL语句优化

### Where子句优化

### Range优化

### 索引融合优化

### 4
### 5
### 6
### 7
### 8
### 9
### 10
### 11
### 12
### 13
### 14
### 15
### 16
### 17
### 18
### 19

## 优化和索引

- 


### 如何使用索引

- 索引用于快速查找具有特定列值的行。 如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。 表越大，成本越高。 如果表中有相关列的索引，MySQL可以快速确定要在数据文件中间寻找的位置，而无需查看所有数据。 这比按顺序读取每一行要快得多。
- 大多数MySQL索引（PRIMARY KEY，UNIQUE，INDEX和FULLTEXT）都存储在B树中。除了，空间数据类型的索引使用R树; MEMORY表也支持哈希索引; InnoDB对FULLTEXT索引使用反转列表。

### 使用主键
### 使用外键
### 列索引
### 多列索引
### 验证索引使用
### InnoDB和MyISAM索引统计集合
### 索引类型比较：B树和哈希
### 使用索引扩展
### 优化器使用生成的列索引



## 优化数据库结构

## 优化InnoDB引擎下的表

## 优化MyISAM引擎下的表

## 理解查询执行计划/步骤

## 控制查询优化器

## 缓冲与缓存

## 优化锁定操作

## 优化MySQL Server

## 衡量/测试性能

## 检查线程信息


