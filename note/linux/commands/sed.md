<!-- TOC -->

- [sed](#sed)
    - [概要](#概要)
    - [运行sed](#运行sed)
        - [选项参数](#选项参数)
    - [脚本](#脚本)
        - [sed脚本概述](#sed脚本概述)
        - [sed脚本命令汇总](#sed脚本命令汇总)
        - [命令：s](#命令s)
        - [常用命令](#常用命令)
        - [不常用命令](#不常用命令)
        - [多命令语法](#多命令语法)
    - [地址：选择行](#地址选择行)
        - [地址概述](#地址概述)
        - [数字选择行](#数字选择行)
        - [文本匹配选择行](#文本匹配选择行)
        - [范围地址](#范围地址)
    - [正则表达式：选择文本](#正则表达式选择文本)
        - [在sed中的正则表达式概述](#在sed中的正则表达式概述)
        - [基本BRE和扩展ERE正则表达式](#基本bre和扩展ere正则表达式)
        - [基本表达式语法概述](#基本表达式语法概述)
        - [扩展表达式语法概述](#扩展表达式语法概述)
        - [字符类和方括号表达式](#字符类和方括号表达式)
        - [正则表达式扩展](#正则表达式扩展)
        - [反向引用和子表达式](#反向引用和子表达式)
        - [转义序列](#转义序列)
        - [多字节字符和区域设置注意事项](#多字节字符和区域设置注意事项)
    - [高级特性：循环和缓存空间](#高级特性循环和缓存空间)
        - [sed如何工作](#sed如何工作)
        - [保持空间和模式空间](#保持空间和模式空间)
        - [多行技巧](#多行技巧)
        - [分支和流控制](#分支和流控制)
    - [一些实例](#一些实例)
    - [临时](#临时)
    - [参考链接](#参考链接)

<!-- /TOC -->

# sed

## 概要

> Linux 文本三剑客之一
>   - awk，侧重文本分析、处理
>   - sed，侧重文本编辑
>   - grep，侧重文本搜索、过滤


- [GNU sed文档](https://www.gnu.org/software/sed/manual/sed.html)
- 应用：
    - 文本替换
    - 选择性的输出文本文件
    - 从文本文件的某处开始编辑
    - 无交互式的对文本文件进行编辑等
    - ...
- 简介：
    - sed 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。
- 命令格式：
    - sed通过指定的script来处理文本：`sed SCRIPT INPUTFILE...`
    - `sed [option] [input-file|stdin]`
    - `sed [-hnVi] [-e<script>][-f<script文件>] [文本文件]`
- **注意**
    - NOTE：如果选项 `-e 或 --expression`，`-f 或 --file` 没有指定，那么第一个非选项参数将会被sed当做脚本script去执行。剩下的参数作为输入文件名，如果没有指定输入文件，那么将sed将会从标准输入stdin读取数据。
- sed工作流
    - sed遵循的工作流：读取，执行，显示
        - 读取：sed从输入流（文件、管道、标准输入）中读取一行并且存储到它叫做 模式空间（pattern buffer）的内部缓存区
        - 执行：默认情况下，所有的sed命令都在模式空间中顺序的执行，除非指定了行的地址，否则sed命令会在所有的行上依次执行
        - 显示：发送修改后的内容到输出流。在发送数据后，模式空间将会被清空
    - 在所有文件的内容被处理完成之前，上述过程将会重复执行。
- 其他：
    - 模式空间 （pattern buffer） 是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本
    - 默认情况下，所有的SED命令都是在模式空间中执行，因此输入文件并不会发生改变
    - 还有另外一个缓冲区叫做 保持空间 （hold buffer），在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。在每一个循环结束的时候，SED将会移除模式空间中的内容，但是该缓冲区中的内容在所有的循环过程中是持久存储的。SED命令无法直接在该缓冲区中执行，因此SED允许数据在 保持空间 和 模式空间之间切换
    - 初始情况下，保持空间 和 模式空间 这两个缓冲区都是空的
    - 如果没有提供输入文件的话，SED将会从标准输入接收请求
    - 如果没有提供地址范围的话，默认情况下SED将会对所有的行进行操作


## 运行sed

### 选项参数

- `-e script`
- `--expression=script`：
    - 指定script来让sed处理文本
- `-f script_file`
- `--file=script_file`
    - 指定script文件来让sed处理文本
- `-n`
- `--quiet`
- `--silent`
    - 默认下，每行处理完后，sed会将模式空间的内容打印输出。该选项会禁止这种自动输出。
    - 仅显示script处理后的结果，中间处理不输出
- `-i[SUFFIX]`
- `--in-place[=SUFFIX]`
    - 直接修改至读取的文件，而不是输出到stdout。（默认是输出到stdout）。如果提供了suffix，将会备份原文件，否则将直接覆盖原文件。
- `-s`
- `--separate`
    - 默认情况下，sed在命令行上指定的多个输入文件视作单个连续长流。
    - 但是该选项参数，可以将其视作多个隔开的文件：范围地址不允许跨越多个文件；行号相对于每个文件的开头；$符号表示每个文件的最后一行；等等
- `-E`
- `-r`
- `--regexp-extend`
    - 在script中使用扩展正则表达式，而不是基本正则表达式。
- `--version`
- `-h`

## 脚本

### sed脚本概述

- sed脚本中命令（command）的语法遵循下面的语法：`[addr]X[options]`
    - `X`是单个字符，表示sed的命令。
    - `[addr]`是可选的，表示指定行地址。如果指定地址，那么`X`命令将只会在匹配的行上执行。`[addr]`可以是单行数字、正则表达式或行范围。
    - `[options]`应用上部分sed命令上。
- 例子：
    ```sh
    # 删除行30至35，[addr]-->30,35（行范围） X-->d
    sed '30,35d' input.text > output.txt

    # [addr]--> /^foo/（正则表达式），X-->q
    sed '/^foo/q42' input.text > output.txt
    ```
- 脚本中的多个命令可以由分号 `;` 或换行符（ASCII 0x0A）
- 可以多次使用选项`-e`或`-f`来同时指定多个脚本
    ```sh
    sed '/^foo/d; s/hello/world/' input.txt > output.txt
    sed -e '/^foo/d' -e 's/hello/world/' input.txt > output.txt
    ```
- 对于命令a，c，i，由于其语法不同，其不能使用分号作为命令分隔符号，所以要么使用换行符LF作为分隔符，要么将这样的命令放在脚本的最后。

### sed脚本命令汇总

- 待整理...

### 命令：s

- s命令的语法为：
    - `s/regexp/replacement/flags`
- 基本流程：s 命令尝试用正则表达式`regexp`去匹配模式空间里的内容，如果匹配成功，那么匹配的部分会被替换成`replacement`
- 更多正则的语法，见下面章节
- `replacement` 可以包含`\n`，其中 n 可以是1-9中数字，表示第n个匹配的部分；同时还可以包含 `&` 字符，表示整个模式空间。（这个有待测试确定）
- 作为GNU sed的扩展，可以用反斜杠来表示一些特殊的字符：`\L`，`\l`，`\U`，`\u`，`\E`
    - `\L`：将replacement转化为小写，直到遇到`\U`或`\E`
    - `\l`：将下一个字符转化为小写
    - `\U`：将replacement转化为大写，直到遇到`\L`或`\E`
    - `\u`：将下一个字符转化为大写
    - `\E`：停止由`\L`或`\U`开始的大小写转化
- ...待整理...
- s 命令后面可以跟着0个或多个正则标志（flags）：
    - `g`：将replacement应用到所有regexp匹配的地方，而不仅仅只是第一个匹配位置
    - `number`：仅仅替换第number个regexp匹配到的部分。
    - `P`：...
    - `w filename`：...
    - `e`：
    - `I` 或 `i`：忽略大小写。
    - `M` 或 `m`：多行模式。修饰符^和$分别匹配换行符后的空字符串和换行符前的空字符串。有一些特殊的字符序列（"\\`"和"\\'"）总是匹配缓冲区的开头和结尾。
- ...待整理...

### 常用命令

- `#`
    - 注释，常用语脚本文件（script-file）中
- `q[exit-code]`
    - 作用：退出sed，停止处理其余命令或文件
    - 该命令仅接受单个地址。
- `d`
    - 删除模式空间，并立马开始下一个循环
        ```sh
        seq 3 | sed 2d
        # > 1
        # > 3
        ```
- `p`
    - 打印模式空间内容到标准输出stdout。该命令通常和 "-n" 选项一起使用。
        ```sh
        # 默认输出，没有使用-n，那么除了p命令打印，原每行内容也会打印输出
        seq 3 | sed 2p
        > 1
        > 2
        > 2
        > 3
        
        # -n 禁止自动打印
        seq 3 | sed -n 2p
        > 2
        ```
- `n`
    - 该命令可以跳过忽略一些行（例如，Nth行）
        ```sh
        # 将第三行替换为x，前面两个n命令表示跳过两行
        seq 6 | sed 'n;n;s/./x/'
        > 1
        > 2
        > x
        > 4
        > 5
        > x
        ```
    - GNU sed提供了一个扩展地址语法：first~step
        ```sh
        seq 6 | sed '0~3s/./x/'
        > 1
        > 2
        > x
        > 4
        > 5
        > x
        ```
- `{ commands }`
    - 一组命令可以用`{}`包含。尤其是当你想要在同一个地址上一组命令时。
        ```sh
        # 将第二行的“2”替换成“X”，并打印出来
        seq 3 | sed -n '2{s/2/X/ ; p}'
        > X
        ```

### 不常用命令

### 多命令语法


## 地址：选择行

### 地址概述

```sh
# 用数字指定行号：将144行中的hello替换为world，如果没有指定行号，则应用所有的行
sed '144s/hello/world' input.txt > output.txt

# 正则：将含有'apple'单词的行中的hello替换为world
sed '/apple/s/hello/world' input.txt > output.txt

# 行范围：行4至17
sed '4,17s/hello/world/' input.txt > output.txt

# 地址反向选择：!
sed '/apple/!s/hello/world' input.txt > output.txt
sed '4,17!s/hello/world/' input.txt > output.txt
```

### 数字选择行

数字地址可以是下面形式：
- `number`
    - 指定行号。
    - 注意，除非指定了-i或-s选项，否则sed会从所有文件的连续输入流中计算行数。
- `$`
    - 最后一行。
- `first~step`
    - 匹配 `first + (n * step)`行。
        ```sh
        seq 10 | sed -n '0~4p'
        > 4
        > 8
        
        seq 10 | sed -n '1~3p'
        > 1
        > 4
        > 7
        10
        ```


### 文本匹配选择行

GNU sed支持正则表达式来指定地址。默认的正则表达式是**基本正则表达式（Basic Regular Expression，BRE）**。如果指定了-E或-r选项，那么正则表达式应该是遵循**扩展正则表达式（Extended Regular Expression，ERE）**。
- `/regexp/`
    - 匹配该regexp的行被选中。
        ```sh
        # 打印出结尾为bash的行
        sed -n '/bash$/p' /etc/passwd
        ```
- `\%regexp%`
- `/regexp/I`
- `\%regexp%I`
- `/regexp/M`
- `\%regexp%M`

### 范围地址

## 正则表达式：选择文本

### 在sed中的正则表达式概述

- sed中的正则表达式在两个斜杆之间
    ```sh
    # 下面两个命令作用相同

    sed -n '/hello/p'

    grep 'hello'
    ```
    ```sh
    printf "%s\n" abode bad bed bit bid byte body | sed -n '/^b.d/p'
    > bad
    > bed
    > bid
    > body
    ```

### 基本BRE和扩展ERE正则表达式

- 基本正则表达式：BRE
- 扩展正则表达式：ERE
- BRE和ERE是模式语法的两种变体。
- BRE语法是 `sed` 和 `grep` linux命令的默认正则语法。可以使用指定选项-E或-r或--regexp-extended来开启ERE语法。
- GNU sed命令，BRE和ERE的语法区别主要是一些特殊字符的行为不同：`?`，`+`，`()`，`{}`，`|`。
    - BRE：该语法下，这些特殊字符没有特殊含义，如果前面加反斜杆`/`，则赋予特殊含义
    - ERE：该语法下，这些特殊字符含有特殊含义，如果前面加反斜杆`/`，则不赋予特殊含义，仅表示字符本身
        ```sh
        # BRE
        $ echo 'a+b=c' | sed -n '/a+b/p'
        > a+b=c

        $ echo aab | sed -n '/a\+b/p' foo
        > aab
        
        # ERE
        $ echo 'a+b=c' | sed -E -n '/a\+b/p'
        > a+b=c

        $ echo aab | sed -n '/a+b/p' foo
        > aab
        ```

### 基本表达式语法概述

> ascii 0x27 单引号，闭单引号，撇号
- ascii 0x60 开单引号，抑音符，

- 以下是sed中使用的正则表达式语法简单语法：
    - `char`
        - 一个普通的字符匹配它自身
    - `*`
        - 数量词，[0, +∞)
    - `.`
        - 匹配任何字符，包括换行符
    - `^`
        - ^ 匹配模式空间开头处的空字符串。
        - 在大多数script中，模式空间被输入流中的每行内容初始化。
        - ^ 特殊字符只出现在正则表达式或子正则表达式的开头。
    - `$`
        - 类似上面 `^`，匹配模式空间结尾处的空字符串。
    - `[list]`，`[^list]`
        - 匹配`[]`中的字符，例如 [abc]，[a-zA-Z0-9_]
    - `\+`
        - 数量词，[1, +∞)
    - `\?`
        - 数量词，[0, 1]
    - `\{i\}`
        - 数量词，[i]，（i是十进制数字，为了兼容，最好保持i的范围为[0, 255]）
    - `\{i,j\}`
        - 数量词，[i, j]
    - `\{i,\}`
        - 数量词，[i, +∞)
    - `\(regexp\)`
        - 正则分组
            - 应用后缀运算符。例如`\(abcd\)*` 可以匹配"abcd"。注意posix 1003.1-2001支持该应用，但是许多非GNU实现不支持，因此它不是普遍移植性的，具体使用时要测试以下。
            - 应用反向引用。
    - `regexp1\|regexp2`
        - 使用regexp1或regexp2匹配
    - `\digit`
        - 匹配第digit个括号`\(\)`中的子表达式，这称为反向引用。
    - `\n`
        - 匹配换行字符
    - `\char`
        - 匹配具有特殊含义的字符的字面含义字符，`$`，`*`，`.`，`[`，`\`，`^`。
- 注意，此处的正则表达式是**贪婪**的，也就是，对于含有数量词的表达式会尽可能的匹配多的字符
- 例子:
    ```sh
    /abcdef/ 可以匹配 "abcdef"
    /a*b/ 可以匹配 "aaaaab", "b"
    /a\?b/ 可以匹配 "ab", "b"
    /a\+b\+/ 可以匹配 "ab", "aab"
    ...
    ```
### 扩展表达式语法概述

- BRE和ERE的区别仅仅在于一些字符的含义：`？`，`+`，`()`，`{}`，`|`。
    - BRE默认把它们当做普通字符匹配，如果作为特殊字符，需要使用斜杆`\`转义
    - ERE默认把它们当做特殊字符，如果作为普通字面字符，需要转义，正好和BRE相反

### 字符类和方括号表达式

- 方括号表达式：
    - 用方括号括起来的一列字符。
    - 其可以匹配任何出现在括号中的单个字符。
    - 如果方括号列表中第一个字符是脱字符`^`，那么其匹配任何一个不出现在括号中的一个字符，即非选择。
- 方括号表达式在BRE和ERE都可以使用。
- 在方括号内预定义了一些


### 正则表达式扩展

### 反向引用和子表达式

### 转义序列

### 多字节字符和区域设置注意事项

## 高级特性：循环和缓存空间

### sed如何工作

- sed维持连个数据缓存区：主要活跃的模式空间（pattern space），辅助的保持空间（hold space）。两者初始都为空。
- sed流程如下：
    1. 首先，sed从输入流中读取一行，并去掉尾部的换行符，然后置于模式空间。
    2. 然后，对该行执行命令。每个命令都有关联地址，只有当地址和该行匹配时，命令才会在上面执行。
    3. 当脚本中的命令执行完后，除非使用了 "-n" 选项，模式空间的内容会被输出到输出流，同时将尾部的换行符补充上。
    4. 最后，读取下一行，依次循环。
- 除非使用特殊命令（例如：D），否则两次循环之间，模式空间会被清空。相反，保持空间在两次循环间，它的数据会被保存。（参阅：h，H，x，g，G命令，来将数据在两个空间中转移）

### 保持空间和模式空间

- todo

### 多行技巧

- `D`
- `G`
- `H`
- `N`
- `P`

### 分支和流控制

## 一些实例



## 临时

```sh
# 单引号里面内容就是script，用来具体说明如何操作文本文件

# 注意如果使用引号的话，使用单引号，不要使用双引号

sed -n -e '1,$p' file.txt
```

**参数说明**：
- -e
- -f
- -e
- -n
- -i
- -h
- -V

**动作说明**：
- a
- c
- s
- i
- d
- p

如果没有指定 `-n，-f`选项，那么sed指令将第一个非选项参数当作script内容去解释，即 `-n，-f` 可以省略，其余的参数当作文本文件的name，如果没有指定文本文件，那么从标准输入stdin读取文本内容。



脚本语法：`[Address] [!] <command>`   

**Address**：

sed指令可以不指定地址，在这种情况下，脚本里的操作会应用所有行。

指定了单行地址，则sed只会匹配此行进行操作。

指定了两个地址，则sed会匹配这两个地址内的范围所有行。

## 参考链接

- http://blog.jobbole.com/109088/
- http://man.linuxde.net/sed
- https://www.gnu.org/software/sed/manual/
- https://blog.csdn.net/xj626852095/article/details/26101273
- http://blog.jobbole.com/109088/
