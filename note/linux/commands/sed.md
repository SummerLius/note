<!-- TOC -->

- [sed](#sed)
    - [概要](#概要)
    - [运行sed](#运行sed)
        - [选项参数](#选项参数)
    - [脚本](#脚本)
        - [sed脚本概述](#sed脚本概述)
        - [sed脚本命令汇总](#sed脚本命令汇总)
        - [命令：s](#命令s)
        - [常用命令](#常用命令)
        - [不常用命令](#不常用命令)
        - [sed gurus的命令](#sed-gurus的命令)
        - [GNU sed特有命令](#gnu-sed特有命令)
        - [多命令语法](#多命令语法)
    - [地址：选择行](#地址选择行)
        - [地址概述](#地址概述)
        - [数字选择行](#数字选择行)
        - [文本匹配选择行](#文本匹配选择行)
        - [范围地址](#范围地址)
    - [正则表达式：选择文本](#正则表达式选择文本)
        - [在sed中的正则表达式概述](#在sed中的正则表达式概述)
        - [基本BRE和扩展ERE正则表达式](#基本bre和扩展ere正则表达式)
        - [基本表达式语法概述](#基本表达式语法概述)
        - [扩展表达式语法概述](#扩展表达式语法概述)
        - [字符类和方括号表达式](#字符类和方括号表达式)
        - [正则表达式扩展](#正则表达式扩展)
        - [反向引用和子表达式](#反向引用和子表达式)
        - [转义序列 - 指定特殊字符](#转义序列---指定特殊字符)
        - [多字节字符和区域设置注意事项](#多字节字符和区域设置注意事项)
    - [高级特性：循环和缓存空间](#高级特性循环和缓存空间)
        - [sed如何工作](#sed如何工作)
        - [保持空间和模式空间](#保持空间和模式空间)
        - [多行技巧](#多行技巧)
        - [分支和流控制](#分支和流控制)
    - [一些实例](#一些实例)
    - [参考链接](#参考链接)

<!-- /TOC -->

# sed

## 概要

> Linux 文本三剑客之一
>   - awk，侧重文本分析、处理
>   - sed，侧重文本编辑
>   - grep，侧重文本搜索、过滤


- [GNU sed文档](https://www.gnu.org/software/sed/manual/sed.html)
- 应用：
    - 文本替换
    - 选择性的输出文本文件
    - 从文本文件的某处开始编辑
    - 无交互式的对文本文件进行编辑等
    - ...
- 简介：
    - sed 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。
- 命令格式：
    - sed通过指定的script来处理文本：`sed SCRIPT INPUTFILE...`
    - `sed [option] [input-file|stdin]`
    - `sed [-hnVi] [-e<script>][-f<script文件>] [文本文件]`
- **注意**
    - NOTE：如果选项 `-e 或 --expression`，`-f 或 --file` 没有指定，那么第一个非选项参数将会被sed当做脚本script去执行。剩下的参数作为输入文件名，如果没有指定输入文件，那么将sed将会从标准输入stdin读取数据。
- sed工作流
    - sed遵循的工作流：读取，执行，显示
        - 读取：sed从输入流（文件、管道、标准输入）中读取一行并且存储到它叫做 模式空间（pattern buffer）的内部缓存区
        - 执行：默认情况下，所有的sed命令都在模式空间中顺序的执行，除非指定了行的地址，否则sed命令会在所有的行上依次执行
        - 显示：发送修改后的内容到输出流。在发送数据后，模式空间将会被清空
    - 在所有文件的内容被处理完成之前，上述过程将会重复执行。
- 其他：
    - 模式空间 （pattern buffer） 是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本
    - 默认情况下，所有的SED命令都是在模式空间中执行，因此输入文件并不会发生改变
    - 还有另外一个缓冲区叫做 保持空间 （hold buffer），在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。在每一个循环结束的时候，SED将会移除模式空间中的内容，但是该缓冲区中的内容在所有的循环过程中是持久存储的。SED命令无法直接在该缓冲区中执行，因此SED允许数据在 保持空间 和 模式空间之间切换
    - 初始情况下，保持空间 和 模式空间 这两个缓冲区都是空的
    - 如果没有提供输入文件的话，SED将会从标准输入接收请求
    - 如果没有提供地址范围的话，默认情况下SED将会对所有的行进行操作


## 运行sed

### 选项参数

- `-e script`
- `--expression=script`：
    - 指定script来让sed处理文本
- `-f script_file`
- `--file=script_file`
    - 指定script文件来让sed处理文本
- `-n`
- `--quiet`
- `--silent`
    - 默认下，每行处理完后，sed会将模式空间的内容打印输出。该选项会禁止这种自动输出。
    - 仅显示script处理后的结果，中间处理不输出
- `-i[SUFFIX]`
- `--in-place[=SUFFIX]`
    - 直接修改至读取的文件，而不是输出到stdout。（默认是输出到stdout）。如果提供了suffix，将会备份原文件，否则将直接覆盖原文件。
- `-s`
- `--separate`
    - 默认情况下，sed在命令行上指定的多个输入文件视作单个连续长流。
    - 但是该选项参数，可以将其视作多个隔开的文件：范围地址不允许跨越多个文件；行号相对于每个文件的开头；$符号表示每个文件的最后一行；等等
- `-E`
- `-r`
- `--regexp-extend`
    - 在script中使用扩展正则表达式，而不是基本正则表达式。
- `--version`
- `-h`

## 脚本

### sed脚本概述

- sed脚本中命令（command）的语法遵循下面的语法：`[addr]X[options]`
    - `X`是单个字符，表示sed的命令。
    - `[addr]`是可选的，表示指定行地址。如果指定地址，那么`X`命令将只会在匹配的行上执行。`[addr]`可以是单行数字、正则表达式或行范围。
    - `[options]`应用上部分sed命令上。
- 例子：
    ```sh
    # 删除行30至35，[addr]-->30,35（行范围） X-->d
    sed '30,35d' input.text > output.txt

    # [addr]--> /^foo/（正则表达式），X-->q
    sed '/^foo/q42' input.text > output.txt
    ```
- 脚本中的多个命令可以由分号 `;` 或换行符（ASCII 0x0A）
- 可以多次使用选项`-e`或`-f`来同时指定多个脚本
    ```sh
    sed '/^foo/d; s/hello/world/' input.txt > output.txt
    sed -e '/^foo/d' -e 's/hello/world/' input.txt > output.txt
    ```
- 对于命令a，c，i，由于其语法不同，其不能使用分号作为命令分隔符号，所以要么使用换行符LF作为分隔符，要么将这样的命令放在脚本的最后。

### sed脚本命令汇总

- `a\ 下一行 text`
- `a text`
- `b label`
- `c\ 下一行 text`
- `c text`
- `d`
- `D`
- `e`
- `e command`
- `F`
- `g`
- `G`
- `h`
- `H`
- `i\ 下一行 text`
- `i text`
- `l`
- `n`
- `N`
- `p`
- `P`
- `q[exit-code]`
- `Q[exit-code]`
- `r filename`
- `R filename`
- `s/regexp/replacement/[flags]`
- `t lable`
- `T lable`
- `v [version]`
- `w filename`
- `W filename`
- `x`
- `y/src/dst/`
- `z`
- `#`
- `{cmd;cmd;...}`
- `=`
- `: label`

### 命令：s

- s命令的语法为：
    - `s/regexp/replacement/flags`
- 基本流程：s 命令尝试用正则表达式`regexp`去匹配模式空间里的内容，如果匹配成功，那么匹配的部分会被替换成`replacement`
- 更多正则的语法，见下面章节
- `replacement` 可以包含`\n`，其中 n 可以是1-9中数字，表示第n个匹配的部分；同时还可以包含 `&` 字符，表示整个模式空间。（这个有待测试确定）
- 作为GNU sed的扩展，可以用反斜杠来表示一些特殊的字符：`\L`，`\l`，`\U`，`\u`，`\E`
    - `\L`：将replacement转化为小写，直到遇到`\U`或`\E`
    - `\l`：将下一个字符转化为小写
    - `\U`：将replacement转化为大写，直到遇到`\L`或`\E`
    - `\u`：将下一个字符转化为大写
    - `\E`：停止由`\L`或`\U`开始的大小写转化
- ...待整理...
- s 命令后面可以跟着0个或多个正则标志（flags）：
    - `g`：将replacement应用到所有regexp匹配的地方，而不仅仅只是第一个匹配位置
    - `number`：仅仅替换第number个regexp匹配到的部分。
    - `P`：...
    - `w filename`：...
    - `e`：
    - `I` 或 `i`：忽略大小写。
    - `M` 或 `m`：多行模式。修饰符^和$分别匹配换行符后的空字符串和换行符前的空字符串。有一些特殊的字符序列（"\\`"和"\\'"）总是匹配缓冲区的开头和结尾。
- ...待整理...

### 常用命令

- `#`
    - 注释，常用语脚本文件（script-file）中
- `q[exit-code]`
    - 作用：退出sed，停止处理其余命令或文件
    - 该命令仅接受单个地址。
- `d`
    - 删除模式空间，并立马开始下一个循环
        ```sh
        seq 3 | sed 2d
        # > 1
        # > 3
        ```
- `p`
    - 打印模式空间内容到标准输出stdout。该命令通常和 "-n" 选项一起使用。
        ```sh
        # 默认输出，没有使用-n，那么除了p命令打印，原每行内容也会打印输出
        seq 3 | sed 2p
        > 1
        > 2
        > 2
        > 3
        
        # -n 禁止自动打印
        seq 3 | sed -n 2p
        > 2
        ```
- `n`
    - 该命令可以跳过忽略一些行（例如，Nth行）
        ```sh
        # 将第三行替换为x，前面两个n命令表示跳过两行
        seq 6 | sed 'n;n;s/./x/'
        > 1
        > 2
        > x
        > 4
        > 5
        > x
        ```
    - GNU sed提供了一个扩展地址语法：first~step
        ```sh
        seq 6 | sed '0~3s/./x/'
        > 1
        > 2
        > x
        > 4
        > 5
        > x
        ```
- `{ commands }`
    - 一组命令可以用`{}`包含。尤其是当你想要在同一个地址上一组命令时。
        ```sh
        # 将第二行的“2”替换成“X”，并打印出来
        seq 3 | sed -n '2{s/2/X/ ; p}'
        > X
        ```

### 不常用命令

- `y/source-chars/dest-chars/`
    - 将source-chars中的字符直译成dest-charts对应位置的字符。
    - source-chars和dest-chars列表必须包含相同数量的字符。
        ```sh
        # a 替换成 0
        # b 替换成 1
        # ...
        $ echo hello world | sed 'y/abcdefghij/0123456789/'
        74llo worl3
        ```
- `a text`
    - 将text添加到一行后。
    - 忽略a命令后的前导空格。要添加的文本将被读取，直到行尾。
    - 详细见下方。
- `a\ 下一行 text`
    - 将text添加到一行后
        ```sh
        $ seq 3 | sed '2a\ 
        hello'
        > 1
        > 2
        > hello
        > 3
        ```
    - a命令将在该当前循环结束时或者在读取下一个输入行时输出该命令后面的文本行（结尾的反斜杆\，会从输出中删除）。
    - 作为GNU扩展，此命令接受两个地址。
    - 文本中的转义序列会被处理，因此您应该在文本中使用`\\`来打印单个反斜杠。
    - a命令读取到结尾不是反斜杆的行为止，例如下面的“world”
        ```sh
        # 注意
        # 脚本中的多个命令可以通过分号或换行符分隔
        # 对于命令a，c，i，由于其语法不同，其不能使用分号作为命令分隔符号，所以要么使用换行符LF作为分隔符，要么将这样的命令放在脚本的最后。
        # 
        $ seq 3 | sed '2a\
        hello\
        world
        3s/./X/'
        > 1
        > 2
        > hello
        > world
        > X

        # 同上面例子作用一样
        seq 3 | sed -e '2a hello\nworld' -e '3s/./x/'
        ```
    - 作为gnu扩展，a命令的和text可以分开为两个-e参数指定
        ```sh
        $ seq 3 | sed -e '2a\' -e hello
        1
        2
        hello
        3
        
        $ sed -e '2a\' -e "$VAR"
        ```
- `i text`
    - 在一行前插入文本text。详细见下方。
- `i\ 下一行 text`
    - 在一行前插入文本text。其它要点和命令a类似。
- `c text`
    - 使用text替换一行或多行。详细将下方。
        ```sh
        $ seq 10 | sed '2,9c hello'
        > 1
        > hello
        > 10
        ```
- `c\ 下一行 text`
    - 使用text替换一行或多行。其它要点和命令你a类似。
    - 会将模式空间中匹配的行删除。
- `=`
    - 打印当前行的行号，后面跟着换行符
        ```sh
        $ printf '%s\n' aaa bbb ccc | sed =
        > 1
        > aaa
        > 2
        > bbb
        > 3
        > ccc
        ```
- `l n`
    - 以明确的形式打印模式空间：不可打印字符（和反斜杆字符\ ）以C风格的转义形式打印；长行被拆分，尾部接反斜杆\ 字符表示分割；每行的结尾以$字符标记。
    - n表示，一行多长时被拆分。
- `r filename`
    - 读取文件内容。
    - 将待读取的文件的内容排队，并在当前周期结束时，或在读取下一个输入行时插入到输出流中。
    - 如果，指定的文件不存在，那么sed仅将其视为空文件，不会报错提示。
    - 作为gnu sed扩展，支持将 "/dev/stdin" 作为文件读取。
    - 作为gnu sed扩展，支持接受两个地址。
- `w filename`
    - 将模式空间中的内容输出到文件中（注意是模式空间内容，不是输出流stdout内容）。
    - 作为gnu sed扩展，"/dev/stderr"和"/dev/stdout"这两种文件也支持
- `D`
    - 如果模式空间不包含换行符，则启动正常的新循环，就像发出d命令一样。
    - 否则，删除模式空间文本直到第一个换行符，然后基于剩下的内容重新启动循环，而不读取新的输入行。
- `N`
    - 在模式空间中添加换行符，然后将下一行输入追加到模式空间。如果没有更多输入，那么sed退出而不再处理任何命令
    - 当使用-z选项时，在行之间添加零字节（ascii'NUL'字符）（而不是换行符）
    - 默认情况下，如果没有“下一个”输入行，则sed不会终止。这是一个GNU扩展，可以使用--posix禁用。
- `P`
    - 打印出模式空间的部分内容，直到遇到第一个换行符
- `h`
    - 将模式空间的内容覆盖到保持空间中
- `H`
    - 将保持空间的内容后面添加一个换行符，再将模式空间的内容添加到保持空间内容后
- `g`
    - 将保持空间中的内容覆盖到模式空间
- `G`
    - 将模式空间的内容后面添加一个换行符，再将保持空间的内容添加到模式空间内容后
- `x`
    - 交换模式空间和保持空间的内容

### sed gurus的命令

- 在大多数情况下，使用这些命令表明您最好使用awk或perl之类的语言进行编程。但是偶尔还是有人会坚持使用sed，而这些命令可以让人编写相当复杂的脚本。
    - `: label`
    - `b label`
    - `t label`

### GNU sed特有命令

- 这些命令是特定与GNU sed的，所以需要小心的使用它们，要考虑兼容。它们允许您检查GNU sed扩展或执行经常需要的任务，标准的sed可能不支持这些任务。
    - ``
    - ``
    - ``
    - ``
    - ``
    - ``
    - ``
    - ``
    - ``


### 多命令语法


## 地址：选择行

### 地址概述

```sh
# 用数字指定行号：将144行中的hello替换为world，如果没有指定行号，则应用所有的行
sed '144s/hello/world' input.txt > output.txt

# 正则：将含有'apple'单词的行中的hello替换为world
sed '/apple/s/hello/world' input.txt > output.txt

# 行范围：行4至17
sed '4,17s/hello/world/' input.txt > output.txt

# 地址反向选择：!
sed '/apple/!s/hello/world' input.txt > output.txt
sed '4,17!s/hello/world/' input.txt > output.txt
```

### 数字选择行

数字地址可以是下面形式：
- `number`
    - 指定行号。
    - 注意，除非指定了-i或-s选项，否则sed会从所有文件的连续输入流中计算行数。
- `$`
    - 最后一行。
- `first~step`
    - 匹配 `first + (n * step)`行。
        ```sh
        seq 10 | sed -n '0~4p'
        > 4
        > 8
        
        seq 10 | sed -n '1~3p'
        > 1
        > 4
        > 7
        10
        ```


### 文本匹配选择行

GNU sed支持正则表达式来指定地址。默认的正则表达式是**基本正则表达式（Basic Regular Expression，BRE）**。如果指定了-E或-r选项，那么正则表达式应该是遵循**扩展正则表达式（Extended Regular Expression，ERE）**。
- `/regexp/`
    - 匹配该regexp的行被选中。
        ```sh
        # 打印出结尾为bash的行
        sed -n '/bash$/p' /etc/passwd
        ```
- `\%regexp%`
- `/regexp/I`
- `\%regexp%I`
- `/regexp/M`
- `\%regexp%M`

### 范围地址

## 正则表达式：选择文本

### 在sed中的正则表达式概述

- sed中的正则表达式在两个斜杆之间
    ```sh
    # 下面两个命令作用相同

    sed -n '/hello/p'

    grep 'hello'
    ```
    ```sh
    printf "%s\n" abode bad bed bit bid byte body | sed -n '/^b.d/p'
    > bad
    > bed
    > bid
    > body
    ```

### 基本BRE和扩展ERE正则表达式

- 基本正则表达式：BRE
- 扩展正则表达式：ERE
- BRE和ERE是模式语法的两种变体。
- BRE语法是 `sed` 和 `grep` linux命令的默认正则语法。可以使用指定选项-E或-r或--regexp-extended来开启ERE语法。
- GNU sed命令，BRE和ERE的语法区别主要是一些特殊字符的行为不同：`?`，`+`，`()`，`{}`，`|`。
    - BRE：该语法下，这些特殊字符没有特殊含义，如果前面加反斜杆`/`，则赋予特殊含义
    - ERE：该语法下，这些特殊字符含有特殊含义，如果前面加反斜杆`/`，则不赋予特殊含义，仅表示字符本身
        ```sh
        # BRE
        $ echo 'a+b=c' | sed -n '/a+b/p'
        > a+b=c

        $ echo aab | sed -n '/a\+b/p' foo
        > aab
        
        # ERE
        $ echo 'a+b=c' | sed -E -n '/a\+b/p'
        > a+b=c

        $ echo aab | sed -n '/a+b/p' foo
        > aab
        ```

### 基本表达式语法概述

> ascii 0x27 单引号，闭单引号，撇号
- ascii 0x60 开单引号，抑音符，

- 以下是sed中使用的正则表达式语法简单语法：
    - `char`
        - 一个普通的字符匹配它自身
    - `*`
        - 数量词，[0, +∞)
    - `.`
        - 匹配任何字符，包括换行符
    - `^`
        - ^ 匹配模式空间开头处的空字符串。
        - 在大多数script中，模式空间被输入流中的每行内容初始化。
        - ^ 特殊字符只出现在正则表达式或子正则表达式的开头。
    - `$`
        - 类似上面 `^`，匹配模式空间结尾处的空字符串。
    - `[list]`，`[^list]`
        - 匹配`[]`中的字符，例如 [abc]，[a-zA-Z0-9_]
    - `\+`
        - 数量词，[1, +∞)
    - `\?`
        - 数量词，[0, 1]
    - `\{i\}`
        - 数量词，[i]，（i是十进制数字，为了兼容，最好保持i的范围为[0, 255]）
    - `\{i,j\}`
        - 数量词，[i, j]
    - `\{i,\}`
        - 数量词，[i, +∞)
    - `\(regexp\)`
        - 正则分组
            - 应用后缀运算符。例如`\(abcd\)*` 可以匹配"abcd"。注意posix 1003.1-2001支持该应用，但是许多非GNU实现不支持，因此它不是普遍移植性的，具体使用时要测试以下。
            - 应用反向引用。
    - `regexp1\|regexp2`
        - 使用regexp1或regexp2匹配
    - `\digit`
        - 匹配第digit个括号`\(\)`中的子表达式，这称为反向引用。
    - `\n`
        - 匹配换行字符
    - `\char`
        - 匹配具有特殊含义的字符的字面含义字符，`$`，`*`，`.`，`[`，`\`，`^`。
- 注意，此处的正则表达式是**贪婪**的，也就是，对于含有数量词的表达式会尽可能的匹配多的字符
- 例子:
    ```sh
    /abcdef/ 可以匹配 "abcdef"
    /a*b/ 可以匹配 "aaaaab", "b"
    /a\?b/ 可以匹配 "ab", "b"
    /a\+b\+/ 可以匹配 "ab", "aab"
    ...
    ```
### 扩展表达式语法概述

- BRE和ERE的区别仅仅在于一些字符的含义：`？`，`+`，`()`，`{}`，`|`。
    - BRE默认把它们当做普通字符匹配，如果作为特殊字符，需要使用斜杆`\`转义
    - ERE默认把它们当做特殊字符，如果作为普通字面字符，需要转义，正好和BRE相反

### 字符类和方括号表达式

- 方括号表达式：
    - 用方括号括起来的一列字符。
    - 其可以匹配任何出现在括号中的单个字符。
    - 如果方括号列表中第一个字符是脱字符`^`，那么其匹配任何一个不出现在括号中的一个字符，即非选择。
- 方括号表达式在BRE和ERE都可以使用。
- 在方括号内，可以使用连字符`-`表示一个范围，例如 `[a-d]` 和 `[abcd]` 一样
- 在方括号内预定义了一些字符类，只能在方括号内使用，类名为这种形式：`[:name:]`，放在方括号内：`[[:name:]]`。
    - `[:alnum:]`
    - `[:alpha:]`
    - `[:blank:]`
    - `[:cntrl:]`
    - `[:digit:]`
    - `[:graph:]`
    - `[:lower:]`
    - `[:print:]`
    - `[:space:]`
    - `[:upper:]`
    - `[:xdigit:]`
- 有些元字符在括号表达式中会失去其特殊含义，即和在方括号外的含义不一样
    - `]`：其作为方括号的组成部分之一，如果想要表示其字面含义，则必须将其置于`[`之前。
    - `-`：表示范围，如果将其放在方括号的开头和结尾，则表示其字面量。
    - `^`：将其置于方括号的开头，表示非选择，如果不放在开头，则表示其字面量
    - `$`、`*`、`.`、`[`、`\`：这些字符在方括号内也没有特殊含义。例如`[\*]`匹配字符`\`或`*`。但是，里面也含有一些特殊含义的表示，例如：`[.ch.]`（collating symbols），`[=a=]`（equivalence classes），`[:space:]`（字符类）。一些特殊的转义序列，例如`\n`、`\t`，在方括号内可以使用。

### 正则表达式扩展

- 下面的序列在正则表达式中含有特殊的含义（用在`address`和`s`命令中的正则表达式）
- 在BRE和ERE均适用
    - `\w`：匹配任何属于“word（单词）”字符。“word（单词）”范围为：[a-zA-Z_]
    - `\W`：[^\w]
    - `\b`：匹配单词边界。即匹配左右两边为“word”和“non-word”的字符。两边都是word或都是non-word的字符，则不匹配。
        ```sh
        $ echo "abc %-= def." | sed 's/\b/X/g'
        XabcX %-= XdefX.
        ```
    - `\B`：同`\b`相反，匹配非单词边界
        ```sh
        $ echo "abc %-= def." | sed 's/\B/X/g'
        aXbXc X%X-X=X dXeXf.X
        ```
    - `\s`：匹配空白字符，例如space、tab、换行符。
    - `\S`：匹配非空白字符
    - `\<`：匹配word的开头
        ```sh
        $ echo "abc %-= def." | sed 's/\</X/g'
        Xabc %-= Xdef.
        ```
    - `\>`：匹配word的结尾
        ```sh
        $ echo "abc %-= def." | sed 's/\>/X/g'
        abcX %-= defX.
        ```
    - `\开单引号`： 匹配模式空间的开头。这和多行模式中的`^`不同
        ```sh
        $ printf "a\nb\nc\n" | sed 'N;N;s/^/X/gm'
        Xa
        Xb
        Xc
        
        $ printf "a\nb\nc\n" | sed 'N;N;s/\`/X/gm'
        Xa
        b
        c
        ```
    - `\'`：匹配模式空间的结尾。这和多行模式中的`$`不同。

### 反向引用和子表达式

- 反向引用，用来引用正则表达式前面组成部分匹配到的序列。即，引用部分也匹配和前面相同的内容。
- 反向引用通过反斜杆和一个数字组成。例如"\1"。
- 被引用的部分，称为子表达式，用圆括号"()"包括。
    ```sh
    $ sed -E -n '/^(.)o\1$/p' /usr/share/dict/words
    bob
    mom
    non
    pop
    sos
    tot
    wow
    ```
    ```sh
    $ sed -E -n '/^(.)(.)(.)\3\2\1$/p' /usr/share/dict/words
    redder
    ```
- 在s命令（`s/regexp/replacement/flags`）中可以在replacement部分适应反向引用，来引用regexp中的子表达式。
    ```sh
    $ echo "James Bond" | sed -E 's/(.*) (.*)/The name is \2, \1 \2./'
    The name is Bond, James Bond.
    ```


### 转义序列 - 指定特殊字符

- 转义序列，提供了一种方法可见的方式，将正则表达式中不可打印、不可见的字符进行特殊编码（使用反斜杆），从而使这样的字符可表示出来。
    - `\a`：匹配 BEL 字符，（ASCII 7）
    - `\f`：匹配 换页 字符，（ASCII 12）
    - `\n`：匹配 换行 字符，（ASCII 10）
    - `\r`：匹配 回车 字符，（ASCII 13）
    - `\t`：匹配 水平制表 字符，（ASCII 9）
    - `\v`：匹配 垂直制表 字符，（ASCII 11）
    - `\cx`：匹配控制字符：*CONTROL-X*，x可以是任何字符。`\cx`的确切效果如下：
        1. 如果x是小写字符，则会被转化为大写
        2. 然后该x字符的第六位bit位（即Hex 40）被反转。（注意一个字节有8bit位，一般以0~7排序，而不是1~8）
        3. 例如，`\cz`-> `hex 1A`，`\c{`-> `hex 3B`，`\c;`-> `hex 7B`，
    - `\dxxx`：匹配十进制ASCII值为 xxx 的字符
    - `\oxxx`：匹配八进制ASCII值为 xxx 的字符
    - `\xxx`：匹配十六进制ASCII值为 xx 的字符
- 在`s///命令`和`address`表示中，sed会提前处理转义序列，然后再传入到正则表达式中，所以以下表示是等价的。
    ```sh
    # 等价
    $ echo 'a^c' | sed 's/^/b/'
    ba^c
    
    $ echo 'a^c' | sed 's/\x5e/b/'
    ba^c

    # 等价
    $ echo abc | sed 's/[a]/x/'
    Xbc
    $ echo abc | sed 's/\x5ba\x5d/x/'
    Xbc

    # 不等价，
    # 但是，建议避免由于意外的边缘情况而导致的此类特殊字符。
    $ echo 'a^c' | sed 's/\^/b/'
    abc
    
    $ echo 'a^c' | sed 's/\\\x5e/b/'
    a^c
    ```


### 多字节字符和区域设置注意事项

- GNU sed 在多字节语言环境（locales）中处理有效的多字节字符（例如UTF-8）
- 示例：下面以字母 "Σ" 为例，Unicode码点为0x03A3。在机器locale为utf8时，sed会正确的将 "Σ" 视为一个字符，尽管其为2个字节长度。
    ```sh
    $ locale | grep LANG
    LANG=en_US.UTF-8
    
    $ printf 'a\u03A3b'
    aΣb
    
    $ printf 'a\u03A3b' | sed 's/./X/g'
    XXX
    
    $ printf 'a\u03A3b' | od -tx1 -An
     61 ce a3 62
    ```
- 可以使用 `c locale（即 posix locale）` 来使sed将多字节字符作为单字节字符处理。
    ```sh
    $ printf 'a\u03A3b' | LC_ALL=C sed 's/./X/g'
    XXXX
    ```
- **无效的多字节字符**
    - sed的正则表达式不匹配多字节语言环境中的无效多字节序列。
    - sed提供了特殊的z命令来清楚当前模式空间中的无效的多字节字符。
    - ...待整理...
- **大小写转换**
    - sed的s命令支持大小写转换，使用`\U`，`\L`。这个转换支持多字节字符。
        ```sh
        $ printf 'ABC\u03a3\n'
        ABCΣ
        
        $ printf 'ABC\u03a3\n' | sed 's/.*/\L&/'
        abcσ
        ```
- **多字节正则字符类**
    - 在其他语言环境中，字符的排序方式是未定的，例如"[a-d]"，可能是"[abcd]"，可能是"[aBbCcDd]"，或者不能匹配任何字符，或者其匹配的字符集不稳定。
    - 为了时正则中的方括号表达式内的字符列表，有传统的、稳定的解释，可以将语言环境变量设置为`C`环境，`LC_ALL=C`。
        ```sh
        # TODO: is there any real-world system/locale where 'A'
        #       is replaced by '-' ?
        $ echo A | sed 's/[a-z]/-/'
        A
        ```
        ```sh
        # TODO: this works on glibc systems, not on musl-libc/freebsd/macosx.
        $ printf 'clichÃ©\n' | LC_ALL=fr_FR.utf8 sed 's/[[=e=]]/X/g'
        clichX
        ```

## 高级特性：循环和缓存空间

### sed如何工作

- sed维持连个数据缓存区：主要活跃的模式空间（pattern space），辅助的保持空间（hold space）。两者初始都为空。
- sed流程如下：
    1. 首先，sed从输入流中读取一行，并去掉尾部的换行符，然后置于模式空间。
    2. 然后，对该行执行命令。每个命令都有关联地址，只有当地址和该行匹配时，命令才会在上面执行。
    3. 当脚本中的命令执行完后，除非使用了 "-n" 选项，模式空间的内容会被输出到输出流，同时将尾部的换行符补充上。
    4. 最后，读取下一行，依次循环。
- 除非使用特殊命令（例如：D），否则两次循环之间，模式空间会被清空。相反，保持空间在两次循环间，它的数据会被保存。（参阅：h，H，x，g，G命令，来将数据在两个空间中转移）

### 保持空间和模式空间

- todo

### 多行技巧

- `D`
- `G`
- `H`
- `N`
- `P`

### 分支和流控制

## 一些实例



<!-- 
```sh
# 单引号里面内容就是script，用来具体说明如何操作文本文件

# 注意如果使用引号的话，使用单引号，不要使用双引号

sed -n -e '1,$p' file.txt
```

**参数说明**：
- -e
- -f
- -e
- -n
- -i
- -h
- -V

**动作说明**：
- a
- c
- s
- i
- d
- p

如果没有指定 `-n，-f`选项，那么sed指令将第一个非选项参数当作script内容去解释，即 `-n，-f` 可以省略，其余的参数当作文本文件的name，如果没有指定文本文件，那么从标准输入stdin读取文本内容。



脚本语法：`[Address] [!] <command>`   

**Address**：

sed指令可以不指定地址，在这种情况下，脚本里的操作会应用所有行。

指定了单行地址，则sed只会匹配此行进行操作。

指定了两个地址，则sed会匹配这两个地址内的范围所有行。 -->

## 参考链接

- http://blog.jobbole.com/109088/
- http://man.linuxde.net/sed
- https://www.gnu.org/software/sed/manual/
- https://blog.csdn.net/xj626852095/article/details/26101273
- http://blog.jobbole.com/109088/
