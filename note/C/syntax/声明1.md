<!-- TOC -->

- [声明](#声明)
    - [声明说明符](#声明说明符)
        - [存储类型](#存储类型)
            - [变量存储类型](#变量存储类型)
                - [变量性质](#变量性质)
                - [auto存储类型](#auto存储类型)
                - [static存储类型](#static存储类型)
                - [extern存储类型](#extern存储类型)
                - [register存储类型](#register存储类型)
            - [函数存储类型](#函数存储类型)
        - [类型限定符](#类型限定符)
        - [类型说明符](#类型说明符)
    - [声明符](#声明符)
        - [简单的声明符](#简单的声明符)
        - [复杂的声明符](#复杂的声明符)
    - [初始化式](#初始化式)
    - [内联函数](#内联函数)
    - [总结](#总结)
        - [声明是否分配存储空间](#声明是否分配存储空间)
    - [参考](#参考)

<!-- /TOC -->


# 声明

变量和函数必须先声明后使用，声明向编译器提供有关变量和函数的标识符的信息。

声明对象
- 声明变量
- 声明函数

声明格式： **`[声明说明符 声明符]`**：
- `声明说明符`：有以下类型。类型限定符和类型说明符必须在存储类型后面，但两者顺序没有限制，不过一般约定类型限定符置于类型说明符前面。
    - **存储类型**：auto、static、extern和register。声明中最多存在以上一种类型。如果存在，必须置于最前。
    - **类型限定符**：const、volatile、restrict（c99）。声明可以包含零个或多个限定符。
    - **类型说明符**：void、char、int、short、long、float、signed、unsinged、struct、enum、union...等都是类型说明符。还有使用typedef创建的类型名也是。
    - **函数说明符（c99）**：仅一种类型，即inline。
- `声明符`：有以下取值。声明符之前用逗号分隔。表示变量的声明符后边可以跟随初始化式。
    - 标识符
    - 后跟随[]的标识符（数组名）：标识符[]
    - 前放置*的标识符（指针名）：\*标识符
    - 后跟随()的标识符（函数名）：标识符()

示例：
```c
/**
 *
 * extern:   存储类型
 * const：   限定符
 * unsigned: 类型说明符
 * long：    类型说明符
 * int：     类型说明符
 * a[10]：   声明符（后跟随[]的标识符）
 * b：       声明符（前置*标识符）
 * c：       声明符（普通标识符）
 *
 */
extern const unsigned long int a[10],*b,c;
```

## 声明说明符

### 存储类型

#### 变量存储类型

##### 变量性质

C程序中每个变量都具有以下3个性质：
- **存储期限**：即生命周期。具有**自动存储期限**的变量，在所属块被执行时获得内存单元，并在块终止时释放内存单元。具有**静态存储期限**的变量，在程序运行期间占有同一块存储单元，即同进程的声明周期一致。
- **作用域**：变量的作用域指可以引用变量的那部分程序文本。两种作用域，**块作用域**（变量声明的地方~所在块的末尾）和**文本作用域**（变量声明的地方~文件的末尾）。
- **链接**：确定了程序的不同部分可以共享此变量的范围。具有**外部链接**的变量可以被程序中几个或全部文件共享；具有**内部链接**的变量只能属于单独一个文件，此文件的函数可以共享这个变量。**无链接**的变量属于单独的一个函数，不能被共享。


变量**默认**的性质依赖与变量声明的位置：
- 块内：自动存储期限、块作用域、无链接
- 程序最外层：静态存储期限、文件作用域、外部链接

一般情况下，变量默认的性质就符合要求了，当无法满足要求时可以指定明确的**存储类型**来改变变量的性质。

##### auto存储类型

auto存储类型只能声明**块变量有效**。如果对最外层变量用auto声明，则编译器会报错。

auto存储类型声明的变量性质：自动存储期限、块作用域、无链接。

auto存储类型几乎不需要显示指定，因为在块内部声明的变量，默认就是auto。

##### static存储类型

static存储类型可以适用全部变量，无论块内外，但是造成的效果不同。
- 作用于块内变量：
    - 静态存储期限
    - 块作用域
    - 无链接
- 作用于块外变量：
    - 静态存储期限
    - 文本作用域
    - 内部链接

static变量有趣一些点：
- **块内static变量只在程序执行前进行一次初始化**（即使该变量所在的块被执行多次），而auto变量则在每次出现时初始化（假设它有初始化式）。下面给出代码示例。
- 每次函数被递归调用时，它都会获得一组新的auto变量。但是函数含有static变量，那么此函数的全部调用都共享这个static变量
- 函数不能返回指向auto变量的指针，但是可以返回指向static变量的指针
- ...

```c
#include <stdio.h>
#include <stdlib.h>

void p() {
    auto int autoValue = 1;
    static int staticValue = 1;

    autoValue++;
    staticValue++;

    printf("auto和static：%d  %d \n", autoValue, staticValue);
}

int main() {
    p();
    p();
    p();
    
    return 0;
}


// 执行结果：
// auto和static：2 2
// auto和static：2 3
// auto和static：2 4


// 结论：函数内（块内）static变量声明时的初始化，仅执行一次，即使之后该函数（块内）多次被调用执行。
```


##### extern存储类型

extern存储类型可以使几个源文件共享同一个变量。

- `extern int i;`：这是一种**特殊的声明**，这样的声明不会导致编译器为变量i分配存储单元。它只是提示编译器需要访问定义在别处的变量。程序中可以多次声明，但只能一次定义。
- `extern int i = 1`：带有初始化式的extern变量声明也是变量的定义，等同于`int i = 1`

extern变量声明位置：
- 块内：
    - 静态存储期限
    - 块作用域
    - 什么链接？
- 块外：
    - 静态作用域
    - 文件作用域
    - 什么链接？

被extern声明的变量在块内外都是静态作用域，可以推测变量的定义必须在块外，即必须拥有的性质为：静态存储期限和文本作用域。

> 分析一下块内的extern变量为什么是静态存储期限？  
> 首先声明在块内的extern变量，其定义必须在函数外层，如果定义也在函数内或块内，那么编译器或链接器会提示错误，而定义在函数外层的变量其存储期限固然为静态存储期限。

一般变量的声明都会分配存储空间，但是extern存储类型声明的变量，编译器不会给其分配存储空间。

有待进一步测试。

##### register存储类型

略


#### 函数存储类型

变量的存储类型有四种：auto、static、extern、register。  

而函数的存储类型仅两种：static、extern。


extern声明的函数具有外部链接，即允许其它文件调用次函数；  
static声明的函数具有内部链接，即只能在定义函数的文件内调用此函数；  

默认是extern类型，即具有外部链接。

注意：函数的声明不会被分配存储空间，只有定义时才会分配存储空间。

### 类型限定符

限定符：
- const：常用限定符，是变量“只读”
- volatile：主要用于底层编程中
- restrict：c99标准才添加，只用于指针（受限指针）

### 类型说明符

略

## 声明符

声明符组成包含：**`标识符、*、[]、()`**。

### 简单的声明符

```c
int a;   // 普通变量
int a[]; // 数组
int *a;  // 指针
int a(); // 函数
```

### 复杂的声明符

两个常见的例子：
- 指针函数：**返回指针的函数，本体是函数**
    - 格式：`类型名 *函数名(参数列表)`
    - 含义：声明一个函数，且返回为指针
    - 要点：其中标识符优先与后面()结合，故该标识符表示函数
- 函数指针：**指向函数的指针，本体是指针**
    - 格式：`类型名 (*指针名)(参数列表)`
    - 含义：声明一个指向函数的指针变量，且规定了该指向函数的返回值和参数列表
    - 要点：其中标识符优先与*结合，故该标识符表示指针

```c
int *a();   // 指针函数
int (*b)(); // 函数指针
```

## 初始化式

C语言允许在声明变量时为它们指定初始值。在声明的后面加上` = 初始化式`。

> 注意初始化和赋值是有区别的：
> - 初始化： `int a = 1`
> - 赋值：`int a;  a = 1;`

关于初始化式的一些要求：
- **具有静态存储期限的变量的初始化式必须是常量。**这是可以理解的，具有静态存储期限的变量在程序启动的时候就分配了存储空间，这时候如果赋值的话必须是有效的值。
- 如果变量具有自动存储期限，那么它的初始化可为变量可为常量。
- 包含在{花括号}中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量或函数调用。

未初始化的变量：
- 具有自动存储期限的变量，没有默认的初始值。不能预测自动变量的初始值，每次变量变为有效时其值可能不同。
- 具有静态存储期限的变量，默认值为0。整型为0，浮点为0.0，指针为null。用calloc分配的内存是简单的给字节的位置零。

一般，关于静态类型的变量最好提供初始化式，而不是依赖默认的初始值。

## 内联函数

c99标准。

详细略。

## 总结

### 声明是否分配存储空间

- 变量：不带初始化式的变量的声明，会分配存储空间，唯一一个例外，使用extern且不带初始化的变量声明不会分配存储空间。如果带初始化式，无论什么存储类型声明的变量，那肯定会分配存储空间。
- 函数：函数的声明均不会分配存储空间，只有定义时才会分配。


## 参考

- 《c语言程序设计 现代方法 第二版》
- C99标准（ISO/IEC 9899:1999(E)）


