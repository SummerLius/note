<!-- TOC -->

- [预处理器](#预处理器)
    - [宏定义](#宏定义)
        - [简单的宏](#简单的宏)
        - [带参数的宏](#带参数的宏)
        - ["#"运算符](#运算符)
        - ["##"运算符](#运算符)
        - [宏的通用属性](#宏的通用属性)
        - [C语言预定义宏](#c语言预定义宏)
        - [空的宏参数(c99)](#空的宏参数c99)
        - [参数个数可变宏(c99)](#参数个数可变宏c99)
    - [文件包含](#文件包含)
    - [条件编译](#条件编译)
        - ["#if"指令和"#endif"指令](#if指令和endif指令)
        - [预处理运算符defined](#预处理运算符defined)
        - ["#ifdef"和"#ifndef"预处理指令](#ifdef和ifndef预处理指令)
        - ["#elif"和"#else"与处理指令](#elif和else与处理指令)
        - [条件编译应用](#条件编译应用)
    - [其它指令](#其它指令)
        - ["#error"预处理指令](#error预处理指令)
        - ["#line"预处理指令](#line预处理指令)
        - ["#pragma"预处理指令](#pragma预处理指令)
    - [参考](#参考)

<!-- /TOC -->

# 预处理器

功能及预处理指令：
- 宏定义：
    - `#define`：定义一个宏
    - `#undef`：删除一个宏定义
- 文件包含：
    - `#include`：指定一个文件，将其内容插入当前文件中
- 条件编译：预处理器根据预处理指令可以用来确定一段文本块包含到程序中还是排除到程序外
    - `#if`
    - `#ifdef`
    - `#ifndef`
    - `#elif`
    - `#else`
    - `#endif`
- 其它：
    - `#error`
    - `#line`
    - `#pragma`

预处理命令的一些规则说明：
- **都以#开始**。不需要是行首，只需前面是空白即可。
- **在指令的符号之间可以插入任意数量的空格或水平制表符**。
- **指令总是在第一个换行符处结束，除非使用反斜杠\指明延续**。
- **指令可以出现在程序任何地方**。但通常将#define和#include放在文件开始。
- **注释可以与指令放在同一行**。
- **注意所有预处理指令语句后面不要接分号;**

```c
// 中间多个空白，是合法的
#       define N     100;

// 延续一行使用反斜杠\
#define A (1 * \
           2 * \
           3)

// 以下都是错误Wrong，不要带分号
#include<stdio.h>;// 错误
#define N 100;// 错误
```

预处理器运算符：
- `#`
- `##`
- `defined`

## 宏定义

### 简单的宏

格式：**`#define 标识符 替换列表`**
- 宏的替换列表：其实什么都可以替换，因为预处理根本不涉及语法理解，仅作文本替换而已
    - 标识符
    - 关键字
    - 数值常量
    - 字符常量
    - 字符串字面量
    - 操作符
    - 排列（这是啥）
    - ...
    - 啥都可以，只要替换后符合C语法

简单的宏主要用来定义那些称为“明示常量”或“符号常量”的东西，即用一个符号来表示C常量。这样的做的好处有：
- 程序更易读。
- 程序易于更改。
- 可帮助避免前后不一致或键盘输入错误。例如3.14159大量出现时，某些地方可能输入不一致。
- 可以对C语法做小修改。
- 对类型重命名。
- 控制条件编译。

```c
// 为一些常量给一个易读的标识符，即明示常量、符号常量
#define PI 3.14159
#define EOS '\0'
#define TRUE 1
#define FALSE 0

// c语法的小修改
#define BEGIN (
#define END )
#define LOOP for(;;)

// 重命名类型
#define BOOL int
```

### 带参数的宏

带参数的宏，也称函数式宏。

格式：**`#define 标识符(x1,x2,...,xn) 替换列表`**
- 宏的名字和左括号之间必须**没有空格**，否者会认为是简单的宏。
- 这样宏使用的方式像函数一样，所以称为函数式宏。
- 注意函数式宏的替换列表的参数和整体最好多用(括号)。

示例：
```c
// 定义
#define MAX(x,y)  ((x)>(y)?(x):(y))
#define IS_EVEN(n) ((n)%2==0)

// 使用
i = MAX(j+k, m-n);
if (IS_EVEN(n)) i++;
```


使用函数式宏替代真正的函数有以下优缺点：

优点：
- **程序稍微快一点**。程序调用函数通常会有一点额外开销。但是c99标准提供的，内联函数，为我们提供了一种不使用宏而避免这一开销的办法。
- **宏更“通用”**。宏的参数是没有类型的。例如上面例子中的MAX(x,y)，参数可以为int、long、float、double等。

缺点：
- **编译后的代码通常会变大**。每一处宏的调用都会导致插入宏的替换列表，由此导致源代码增加。
- **嵌套使用函数式宏可能会得到意外的结果或编译错误**。为了安全，最好对整体和参数都使用(括号)括起来。
- **宏参数没有类型检查**。
- **无法用一个指针来指向宏**。c语言允许指针指向函数，这些在特点编程条件是有用的。而宏在预处理过程中会被删除，所以不存在指向宏的指针，不能处理有关函数指针的特定编程。
- **宏可能会不止一次的计算它的参数**。多次计算宏的参数而导致的错误可能非常难发现，最好避免带有副作用的参数，例如i++，++i等。

```c
// 嵌套使用，没有使用括号造成的问题
#define MAX_1(x,y) ((x)>(y)?(x):(y))
#define MAX_2(x,y) x>y?x:y

int v1 = MAX_1(1, MAX_1(2, 3));
int v2 = MAX_2(1, MAX_2(2, 3));

// 预处理宏替换后
int v1 = ((1)>(((2)>(3)?(2):(3)))?(1):(((2)>(3)?(2):(3)))); // 结果正常：3
int v2 = 1>2>3?2:3?1:2>3?2:3;

// v2实际上的执行顺序为
int v2 = (1>2>3?2:3) ? 1 : (2>3?2:3); // 结果不是预期：1

// 结论：
// 不带括号的函数宏，如果多层嵌套的话，可能执行顺序不符合预期，
// 保险最好(括号)，表达式整体和个体都括起来。

```

### "#"运算符

宏定义可以包含两个专用的运算符：#和##。编译器不会识别这两种运算符，它们会在预处理时被执行。

"#"运算符作用： 
- 将宏的一个参数转换为字符串字面量。
- 它仅允许出现在带参数的宏的替换列表中。

```c
#define PRINT_INT(n) printf(#n " = %d\n", n);

PRINT_INT(i/j);

// 宏替换后

printf("i/j" " = %d\n", i/j);

// C语言中相邻的字符串字面量会被合并，因此上面语句等价于：
printf("i/j = %d\n", i/j);
```

### "##"运算符

"##" 运算符可以将两个记号（如标识符）粘合在一起，成为一个记号。

```c
#define INT_ID(n) i##n

int INT_ID(1), INT_ID(2);

// 宏替换后

int i1, i2;
```

> 其实 `#` 预处理运算符和 `##` 预处理运算符并不是很常用。

### 宏的通用属性

宏的一些遵循的规则：
- **宏的替换列表可以包含对其它宏的调用**。预处理器会不断重新检查替换列表，直到所有的宏名字都替换掉为止。
- **预处理器只会替换完整的记号，不会替换记号的片段**。预处理会忽略嵌在标识符、字符常量、字符串字面量之中的宏名。例如宏SIZE，不会替换标识符BUFFER_SIZE中的SIZE。
- **宏定义的作用范围通常到该文件的末尾**。宏是预处理器处理的，他们不遵循C变量的作用域规则。定义在函数中的宏不仅作用在函数内，而是一直到该文件末尾。
- **宏不可以被定义两遍，除非新的和旧的定义相同**。
- **宏可以使用 `#undef` 取消定义**。例如，`#undef N`，如果N之前没有被定义成宏，那么该指令不会产生任何作用。

```c
// 宏可以包含其它的宏
#define PI 3.14159
#define TWO_PI (PI*2)

// 取消宏
#define N 1
#undef N
```

### C语言预定义宏

### 空的宏参数(c99)

### 参数个数可变宏(c99)

## 文件包含

格式：`#include <文件名>` 或 `#include "文件名"` 或 `#include 记号`    
- 功能：`#include`指令告诉预处理器打开指定文件，并把此文件的内容插入到当前的文件中。这种文件内容的改变，是在编译之前。
- 记号：表示可以是一个宏标识符

```c
// #include 记号
#if defined(IA32)
#define CPU_FILE "ia32.h"
#elif defined(IA64)
#define CPU_FILE "ia64.h"
#elif defined(AMD64)
#define CPU_FILE "amd64.h"
#else
#error No operating system specified
#endif

#include CPU_FILE
``` 

## 条件编译

### "#if"指令和"#endif"指令

格式：`#if 常量表达式`   
```c
#if 常量表达式
xxx;
xxx;
#endif
```
- 其中的常量表达式可以是符号常量，即宏定义一个标识符表示常量
- 非0值为真，0值为假
- `#if` 会把没有定义过的标识符当作值为0的宏对待。

### 预处理运算符defined

格式：`defined(标识符)` 或 `defined 标识符`
- 表达式返回值：返回 1 或 0  
- 功能：检测一个标识符是否是定义过的**宏**。
- 步骤：当defined应用于标识符时，如果标识符是定义过的**宏**，则返回1，否者返回0

### "#ifdef"和"#ifndef"预处理指令

- `#ifdef 标识符`：判断一个标识符是否已经定义为宏，等价于 `#if defined(标识符)`
- `#ifndef 标识符`：判断一个标识符是否没有定义为宏，等价于 `#if !defined(标识符)`

### "#elif"和"#else"与处理指令

`#if`、`#ifdef`、`#ifndef`、`#endif`、`#else`、`#elif` 这些预处理指令可以像`if...else`的语法一样使用。

格式：
- `#elif 常量表达式`
- `#else`

示例：
```c
#if 表达式1
xxx;
#elif 表达式2
xxx;
#else
xxx;
#endif
```

### 条件编译应用

- 调试处理
- **编译在多台机器或多种操作系统之间的可移植的程序**。
```c
#ifdef WIN32
...
#elif defined(MAC_OS)
...
#elif defined(LINUX)
...
#endif
```
- **编写可以用不同的编译器编译的程序**。例如判断编译器是否符合C标准(c89或c99)，可以使用预定义宏`__STDC__`，如果符合，该值为1
- **为宏提供默认定义**。
```c
#ifndef BUFFER_SIZE
#define BUFFER_SIZE 256
#endif
```
- ...



## 其它指令

`error`、`line`、`pragma`这些指令较之前较专业，使用频率较低

### "#error"预处理指令

格式：`#error 消息`
- 消息：可以是任何字符序列，其实含义就是一段error显示文本。
- 功能：`#error`指令预示着程序中出现了严重的错误，有些编译器会立即终止编译，抛出错误。
- 应用：`#error`指令常与条件编译指令一起使用，来检测正常编译过程中不应该出现的情况。

```c
#if defined(WIN32)
...
#elif defined(MAC_OS)
...
#elif defined(LINUX)
...
#else
#error No operating system specified
#endif
```

### "#line"预处理指令

暂不做了解

### "#pragma"预处理指令

暂不做了解

## 参考

- 《C语言程序设计 现代方法 第二版》
