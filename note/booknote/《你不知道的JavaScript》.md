<!-- TOC -->

- [《你不知道的JavaScript》](#你不知道的javascript)
    - [概要](#概要)
    - [入门与进阶](#入门与进阶)
        - [第一章：进入编程](#第一章进入编程)
        - [第二章：进入JavaScript](#第二章进入javascript)
        - [第三章：进入YDKJS](#第三章进入ydkjs)
    - [作用域与闭包](#作用域与闭包)
        - [第一章：什么是作用域？](#第一章什么是作用域)
        - [第二章：词法作用域](#第二章词法作用域)
        - [第三章：函数与块儿作用域](#第三章函数与块儿作用域)
        - [第四章：提升](#第四章提升)
        - [第五章：作用域闭包](#第五章作用域闭包)
        - [附录A：动态作用域](#附录a动态作用域)
        - [附录B：填补块儿作用域](#附录b填补块儿作用域)
        - [附录C：词法this](#附录c词法this)
    - [this与对象原型](#this与对象原型)
        - [第一章: this是什么?](#第一章-this是什么)
        - [第二章: this豁然开朗!](#第二章-this豁然开朗)
        - [第三章: 对象](#第三章-对象)
        - [第四章: 混合（淆）“类”的对象](#第四章-混合淆类的对象)
        - [第五章: 原型](#第五章-原型)
        - [第六章: 行为委托](#第六章-行为委托)
        - [附录A: ES6 class](#附录a-es6-class)
    - [类型与文法](#类型与文法)
        - [第一章：类型](#第一章类型)
        - [第二章：值](#第二章值)
        - [第三章：原生类型](#第三章原生类型)
        - [第四章：强制转换](#第四章强制转换)
        - [第五章：文法](#第五章文法)
        - [附录A：混合环境下的JavaScript](#附录a混合环境下的javascript)
    - [异步与性能](#异步与性能)
        - [第一章: 异步:现在与稍后](#第一章-异步现在与稍后)
        - [第二章: 回调](#第二章-回调)
        - [第三章: Promise](#第三章-promise)
        - [第四章: Generator](#第四章-generator)
        - [第五章: 程序性能](#第五章-程序性能)
        - [第六章: 基准分析与调优](#第六章-基准分析与调优)
        - [附录A：库：asynquence](#附录a库asynquence)
        - [附录B：高级异步模式](#附录b高级异步模式)
    - [ES6与未来](#es6与未来)
        - [第一章：ES？现在与未来](#第一章es现在与未来)
        - [第二章：语法](#第二章语法)
        - [第三章：组织](#第三章组织)
        - [第四章：异步流程控制](#第四章异步流程控制)
        - [第五章：集合](#第五章集合)
        - [第六章：新增API](#第六章新增api)
        - [第七章：元编程](#第七章元编程)
        - [第八章：ES6之后](#第八章es6之后)

<!-- /TOC -->

# 《你不知道的JavaScript》

## 概要

- [Github You-Dont-Know-JS 英文](https://github.com/getify/You-Dont-Know-JS)
    - [Up & Going](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20&%20going/README.md#you-dont-know-js-up--going)
    - [Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&%20closures/README.md#you-dont-know-js-scope--closures)
    - [this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)
    - [Types & Grammar](https://github.com/getify/You-Dont-Know-JS/blob/master/types%20&%20grammar/README.md#you-dont-know-js-types--grammar)
    - [Async & Performance](https://github.com/getify/You-Dont-Know-JS/blob/master/async%20&%20performance/README.md#you-dont-know-js-async--performance)
    - [ES6 & Beyond](https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20&%20beyond/README.md#you-dont-know-js-es6--beyond)
- [Github You-Dont-Know-JS 中文](https://github.com/JoeHetfield/You-Dont-Know-JS)
    - [入门与进阶](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/up%20&%20going/README.md#you-dont-know-js-up--going)
    - [作用域与闭包](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/scope%20&%20closures/README.md#you-dont-know-js-scope--closures)
    - [this 与对象原型](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)
    - [类型与文法](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/types%20&%20grammar/README.md#you-dont-know-js-types--grammar)
    - [异步与性能](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/async%20&%20performance/README.md#you-dont-know-js-async--performance)
    - [ES6与未来](https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/es6%20&%20beyond/README.md#you-dont-know-js-es6--beyond)
- 这里先阅读中文版，有模棱两可处再参考英文版

## 入门与进阶
### 第一章：进入编程

10. 函数
    1. 作用域
        - 作用域（技术上讲称为 词法作用域）；
        - 在JavaScript中，每个函数都有自己的作用域；
        - 作用域基本上就是变量的集合，也是如何使用名称访问这些变量的规则；
        - 只有在这个函数内部的代码才能访问这个函数 作用域内 的变量；
        - 在同一个作用域内变量名必须是唯一的 —— 不能有两个不同的变量a并排出现。但是相同的变量名a可以出现在不同的作用域中；
        - 另外，一个作用域可以嵌套在另一个作用域中，如果一个作用域嵌套在另一个中，那么在内部作用域中的代码就可以访问这两个作用域中的变量；
        - 词法作用域规则说，在一个作用域中的代码既可以访问这个作用域中的变量，又可以访问任何在它外面的作用域的变量；
        - 注意： 关于词法作用域的更多信息，参见本系列的 作用域与闭包 的前三章。

### 第二章：进入JavaScript
### 第三章：进入YDKJS

## 作用域与闭包
### 第一章：什么是作用域？

- 临时笔记：
    - 回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组规则为：作用域。
    - 作用域 是通过标识符名称查询变量的一组规则。

### 第二章：词法作用域

- 临时笔记：
    - 我们将“作用域”定义为一组规则，它主宰着 引擎 如何通过标识符名称在当前的 作用域，或者在包含它的任意 嵌套作用域 中来查询一个变量。
    - 词法作用域是一组关于 引擎 如何查询变量和它在何处能够找到变量的规则。
        - 词法作用域的关键性质是，它是在代码编写时被定义的（假定你不使用 eval() 或 with 作弊的话）。
    - 词法作用域是在词法分析时被定义的作用域。
    - 换句话说，词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理你的代码时（基本上）是固定不变的。

### 第三章：函数与块儿作用域

- 临时笔记：
    - 区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。
    - (function foo(){ .. }) 作为一个表达式意味着标识符 foo 仅能在 .. 代表的作用域中被找到，而不是在外部作用域中。将名称 foo 隐藏在它自己内部意味着它不会没必要地污染外围作用域。

### 第四章：提升

- 临时笔记：
    - 提升是 以作用域为单位的。
    - 函数声明会被提升，就像我们看到的。但是函数表达式不会。
    - 函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。
    - 避免在块儿中声明函数可能是最好的做法。
    - 多个/重复的 var 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个

### 第五章：作用域闭包

- 临时笔记：
    - 闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。
    
### 附录A：动态作用域

- 临时笔记：
    - 动态作用域看起来在暗示，有充分的理由，存在这样一种模型，它的作用域是在运行时被确定的，而不是在编写时静态地确定的。
    - 相比之下，动态作用域本身不关心函数和作用域是在哪里和如何被声明的，而是关心 它们是从何处被调用的。换句话说，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。
    - 关键的差异：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。
    - 最后：this 关心的是 函数是如何被调用的，这揭示了 this 机制与动态作用域的想法有多么紧密的关联。要了解更多关于 this 的细节，请阅读 “this与对象原型”。
    
### 附录B：填补块儿作用域
### 附录C：词法this

- 临时笔记：
    - 

## this与对象原型
### 第一章: this是什么?

- 临时笔记：
    - this是一个在每个函数作用域中自动定义的特殊标识符关键字。
    - this机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。
        - 你的使用模式越复杂，你就会越清晰地看到：将执行环境作为一个明确参数传递，通常比传递this执行环境要乱。当我们探索对象和原型时，你将会看到一组可以自动引用恰当执行环境对象的函数是多么有用。
    - this误解
        - 误解一：第一种常见的倾向是认为this指向函数自己。
        - 误解二：第二常见的对this的含义的误解，是它不知怎的指向了函数的作用域。
            - 明确地说，this不会以任何方式指向函数的 词法作用域。作用域好像是一个将所有可用标识符作为属性的对象，这从内部来说是对的。但是JavasScript代码不能访问作用域“对象”。它是 引擎 的内部实现。
    - this不是编写时绑定，而是运行时绑定。
    - 它依赖于函数调用的上下文条件。
    - this绑定和函数声明的位置无关，反而和函数被调用的方式有关。
    - 当一个函数被调用时，会建立一个活动记录，也称为执行环境。这个记录包含函数是从何处（call-stack）被调用的，函数是 如何 被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的this引用。
    - this既不是函数自身的引用，也不是函数词法作用域的引用。
    - this实际上是在函数被调用时建立的一个绑定，它指向 什么 是完全由函数被调用的调用点来决定的。

### 第二章: this豁然开朗!

- 临时记录：
    - this是一个完全根据调用点（函数是如何被调用的）而为每次函数调用建立的绑定。
    - 调用点：函数在代码中被调用的位置（不是被声明的位置）。
    - 当在函数前面被加入new调用时，也就是构造器调用时，下面这些事情会自动完成：
        1. 一个全新的对象会凭空创建（就是被构建）
        2. 这个新构建的对象会被接入原形链（[[Prototype]]-linked）
        3. 这个新构建的对象被设置为函数调用的this绑定
        4. 除非函数返回一个它自己的其他 对象，这个被new调用的函数将 自动 返回这个新构建的对象。
    - 与使用4种标准的this规则不同的是，箭头函数从封闭它的（function或global）作用域采用this绑定。
    - 一个箭头函数的词法绑定是不能被覆盖的（就连new也不行！）。
    - 为执行中的函数判定this绑定需要找到这个函数的直接调用点。找到之后，4种规则将会以 这个 优先顺序施用于调用点：
        1. 被new调用？使用新构建的对象。
        2. 被call或apply（或 bind）调用？使用指定的对象。
        3. 被持有调用的环境对象调用？使用那个环境对象。
        4. 默认：strict mode下是undefined，否则就是全局对象。
    - 小心偶然或不经意的 默认绑定 规则调用。如果你想“安全”地忽略this绑定，一个像ø = Object.create(null)这样的“DMZ”对象是一个很好的占位值，来保护global对象不受意外的副作用影响。

### 第三章: 对象
### 第四章: 混合（淆）“类”的对象

- 临时笔记：
    - “类/继承”描述了一种特定的代码组织和结构形式——一种在我们的软件中对真实世界的建模方法。
    - 类是一种设计模式。许多语言提供语法来启用自然而然的面向类的软件设计。JS也有相似的语法，但是它的行为和你在其他语言中熟悉的工作原理 有很大的不同。
    - 类意味着拷贝。
    - JavaScript 不会自动地 （像类那样）在对象间创建拷贝。
    - 一般来讲，在JS中模拟类通常会比解决当前 真正 的问题埋下更多的坑。
    
### 第五章: 原型

- 临时笔记：
    - 在JavaScript中，更合适的说法是，“构造器”是在前面 用new关键字调用的任何函数。
    - 函数不是构造器，但是当且仅当new被使用时，函数调用是一个“构造器调用”。
    - a1.constructor是极其不可靠的，在你的代码中不应依赖的不安全引用。一般来说，这样的引用应当尽量避免。
    - Object.create(null)，这种典型的用途是在属性中存储数据，这种特殊的空`[[Prototype]]`对象经常被称为“dictionaries（字典）”，这主要是因为它们没有可能受到在`[[Prototype]]`链上任何委托属性/函数的影响，所以它们是纯粹的扁平数据存储。
    - 注意： 在ES6中，引入了一个称为Proxy（代理）的高级功能，它可以提供某种“方法未找到”类型的行为。
    

### 第六章: 行为委托

- 临时笔记：
    - `[[Prototype]]`机制是一种存在于一个对象上的内部链接，它指向一个其他对象。
        - 当一个属性/方法引用在第一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。
        - 在这种情况下，`[[Prototype]]`链接告诉引擎去那个被链接的对象上寻找该属性/方法。
        - 接下来，如果那个对象也不能满足查询，就沿着它的`[[Prototype]]`查询，如此继续。这种对象间一系列的链接构成了所谓的“原形链”。
    - 委托更适于作为内部实现的细节，而不是直接暴露在API接口的设计中。在上面的例子中，我们的API设计没必要有意地让开发者调用XYZ.setID()（当然我们可以！）。我们以某种隐藏的方式将委托作为我们API的内部细节，即XYZ.prepareTask(..)委托到Task.setID(..)。

### 附录A: ES6 class

## 类型与文法
### 第一章：类型
### 第二章：值
### 第三章：原生类型
### 第四章：强制转换
### 第五章：文法
### 附录A：混合环境下的JavaScript

## 异步与性能
### 第一章: 异步:现在与稍后
### 第二章: 回调
### 第三章: Promise
### 第四章: Generator
### 第五章: 程序性能
### 第六章: 基准分析与调优
### 附录A：库：asynquence
### 附录B：高级异步模式

## ES6与未来
### 第一章：ES？现在与未来
### 第二章：语法

- 临时笔记：
    - 默认参数
        - 注意默认参数，只会将`undefined`视为没有传参数，像`0`、`false`、`""`、`null`这些falsy值会视为传了值，从而不使用默认值；
            - 像 `x = x || 123;` 这样使用默认赋值，要注意区别；
        - 一个 “扩散/收集” 不能使用默认值，例如 `function (...vals=[1,2,3]) {}` 这种写法不支持；
        - 默认值表达式
            - 默认值，可以是任何合法表达式，甚至是函数调用；

### 第三章：组织
### 第四章：异步流程控制
### 第五章：集合
### 第六章：新增API
### 第七章：元编程
### 第八章：ES6之后

