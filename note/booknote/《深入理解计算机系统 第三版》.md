<!-- TOC -->

- [深入理解计算机系统 第三版](#深入理解计算机系统-第三版)
    - [目录](#目录)
    - [第2章 信息的表示和处理](#第2章-信息的表示和处理)
        - [概要](#概要)
        - [2.1 信息存储](#21-信息存储)
            - [概要](#概要-1)
            - [2.1.1 十六进制表示法](#211-十六进制表示法)
            - [2.1.2 字数据大小](#212-字数据大小)
            - [2.1.3 寻址和字节顺序](#213-寻址和字节顺序)
            - [2.1.4 表示字符串](#214-表示字符串)
            - [2.1.5 表示代码](#215-表示代码)
            - [2.1.6 布尔代数简介](#216-布尔代数简介)
            - [2.1.7 C语言中的位级运算](#217-c语言中的位级运算)
            - [2.1.8 C语言中的逻辑运算](#218-c语言中的逻辑运算)
            - [2.1.9 C语言中的移位运算](#219-c语言中的移位运算)
        - [2.2 整数表示](#22-整数表示)
            - [概要](#概要-2)
            - [2.2.1 整型数据类型](#221-整型数据类型)
            - [2.2.2 无符号数的编码](#222-无符号数的编码)
            - [2.2.3 补码编码](#223-补码编码)
            - [2.2.4 有符号数和无符号数之间的转换](#224-有符号数和无符号数之间的转换)
            - [2.2.5 C语言中的有符号数和无符号数](#225-c语言中的有符号数和无符号数)
            - [2.2.6 扩展一个数字的位表示](#226-扩展一个数字的位表示)
            - [2.2.7 截断数字](#227-截断数字)
            - [2.2.8 关于有符号数和无符号数的建议](#228-关于有符号数和无符号数的建议)
        - [2.3 整数运算](#23-整数运算)
            - [概要](#概要-3)
            - [2.3.1 无符号加法](#231-无符号加法)
            - [2.3.2 补码加法](#232-补码加法)
            - [2.3.3 补码的非](#233-补码的非)
            - [2.3.4 无符号乘法](#234-无符号乘法)
            - [2.3.5 补码乘法](#235-补码乘法)
            - [2.3.6 乘以常数](#236-乘以常数)
            - [2.3.7 除以2的幂](#237-除以2的幂)
            - [2.3.8 关于整数运算的最后思考](#238-关于整数运算的最后思考)
        - [2.4 浮点数](#24-浮点数)
            - [概要](#概要-4)
            - [2.4.1 二进制小数](#241-二进制小数)
            - [2.4.2 IEEE浮点表示](#242-ieee浮点表示)
            - [2.4.3 数字示例](#243-数字示例)
            - [2.4.4 舍入](#244-舍入)
            - [2.4.5 浮点运算](#245-浮点运算)
            - [2.4.6 C语言中的浮点数](#246-c语言中的浮点数)
        - [2.5 小结](#25-小结)

<!-- /TOC -->

# 深入理解计算机系统 第三版

## 目录

- 第1章 计算机系统漫游
- 第一部分：程序结构和执行
    - 第2章 信息的表示和处理
    - 第3章 程序的机器级表示
    - 第4章 处理器体系结构
    - 第5章 优化程序性能
    - 第6章 存储器层次结构
- 第二部分：在系统上运行程序
    - 第7章 链接
    - 第8章 异常控制流
    - 第9章 虚拟内存
- 第三部分：程序间的交流和通信
    - 第10章 系统级I/O
    - 第11章 网络编程
    - 第12章 并发编程

## 第2章 信息的表示和处理

### 概要

- 对于有10个手指的人类来说，使用十进制表示法是很自然的事情；
- 对于构造存储和处理信息的机器时，二进制值工作的更好，二进制信号能够很容易地被表示、存储和传输；
- 对于二值信号进行存储和执行计算的电子电路非常简单和可靠；
- 二进制位作用：
    - 孤立的讲，单个位用处不大，然而，当把位组合在一起，再加上某种**解释**（interpretation），即赋予不同的位组合以含义，我们就能表示任何有限集合的元素；
    - 比如：
        - 使用一个二进制数字系统，我们能够用位组来编码非负数；
        - 通过使用标准的字符码，我们能够对文档中的字母和符号进行编码；
        - ...
- 我们研究3种重要的数字表示：
    - **无符号（unsigned）编码**：基于传统的二进制表示法，表示大于或者等于0的数字；
    - **补码（two's-complement）编码**：是表示有符号整数最常见的方式，有符号整数就是可以为正或者为负的数字；
    - **浮点数（floating-point）编码**：是表示实数的科学计数法，已2为基数的版本；
- 在计算机系统上，整数运算和浮点数运算会有不同的数学属性，是因为它们处理数字表示有限性的方式不同：
    - 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；
    - 而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的；
> - 怎样阅读本章？
>   - 本章我们研究在计算机上如何表示数字和其它形式数据的基本属性，以及计算机对这些数据执行操作的属性；
>   - 这就要求我们深入研究数学语言，编写公式和方程式，以及展示重要属性的推导；
>   - 为了帮助阅读，这部分内容安排如下：
>       - 首先，给出以数学形式表示的属性，作为原理；
>       - 然后，用例子和非形式化的讨论来解释这个原理；
>   - 我们建议你反复阅读原理描述和它的示例和讨论，直到你对该属性的说明内容及其重要性有了牢固的直觉；
>   - 对于更加复杂的属性，还会提供推导，其结构看上去会像一个数学证明，虽然最终你应该尝试理解这些推导，但在第一次阅读时你可以跳过它们；

### 2.1 信息存储

#### 概要

- 大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位；
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（Virtual memory）；
- 内存的每个字节都由一个唯一的数字来标识，称为它的地址（adress），所有可能地址的集合就称为虚拟地址空间（Virtual address space）。
    - 顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。
    - 实际的实现将动态随机访问存储器（DRAM）、内存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

#### 2.1.1 十六进制表示法

- 一个字节由8位组成;
- 在二进制表示法中，它的值域是 `000000₂ ~ 11111111₂`，如果看成十进制整数，它的值域就是 `0₁₀~255₁₀`;
    - 这两种符号表示法对于描述位模式来说都不是非常方便；
    - 二进制表示法太冗长，而十进制表示法与位模式的相互转化很麻烦；
    - 替代的方法是使用16位基数，或者叫做十六进制数（hexadecimal），来表示位模式；
- 在C语言中，以`0x`或`0X`开头的数字常量被认为是十六进制的值，字符 A ~ F，大小写都可以；

#### 2.1.2 字数据大小

- 每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）；
- 因为虚拟地址是以这样一个 “字” 来编码，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小；
    - 也就是说，一个字长为 `w` 位的机器而言，虚拟地址的范围为 `0 ~ 2ʷ - 1`，程序最多访问 `2ʷ` 个字节；
    - 32位字长机器，虚拟地址空间为 `2³²`，即4GB；
    - 64为字长机器，虚拟地址空间为 `2⁶⁴`；
- 大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容；
    - `gcc -m32 prog.c`：该程序可以在32位和64位机器上正确运行；
    - `gcc -m64 prog.c`：该程序只能在64位机器上运行；
    - 因此，我们将程序称为 “32位程序” 或 “64位程序” 时，区别在于该程序是如何编译的，而不是其运行的机器类型；

#### 2.1.3 寻址和字节顺序

- todo

#### 2.1.4 表示字符串

- C语言中，字符串被编码为一个以null（其值为0）字符结尾的字符数组；
- 每个字符都由某个标准编码来表示，最常见的是ASCII字符码；
    - 因此，如果我们以参数“12345”来运行函数 `show_bytes`，我们得到结果 31 32 33 34 35 00;

#### 2.1.5 表示代码
#### 2.1.6 布尔代数简介
#### 2.1.7 C语言中的位级运算
#### 2.1.8 C语言中的逻辑运算
#### 2.1.9 C语言中的移位运算

### 2.2 整数表示

#### 概要

- 在本节中，我们描述用位来编码证书的两种不同方式：
    1. 一种只能表示非负数
    2. 另一种能够表示负数、零和正数
- 后面，我们将会看到它们在数学属性和机器级实现方面密切相关；
- 下图列出了我们引入的数学术语，用于精确定义和描述计算机如何编码和操作正数；
    - |符号|类型|含义|
      |:--:|:--:|:--:|
      |B2T|函数|二进制转补码|
      |B2T|函数|二进制转无符号数|
      |U2B|函数|无符号数转二进制|
      |T2B|函数|无符号转补码|
      |T2U|函数|补码转无符号数|
      |TMin|函数|最小补码值|
      |TMax|函数|最大补码值|
      |UMax|函数|最大无符号数|
      |+ᵗ|操作|补码加法|
      |+ᵘ|操作|无符号数加法|
      |*ᵗ|操作|补码乘法|
      |*ᵘ|操作|无符号数乘法|
      |-ᵗ|操作|补码取反|
      |-ᵘ|操作|无符号数取反|

#### 2.2.1 整型数据类型
#### 2.2.2 无符号数的编码
#### 2.2.3 补码编码
#### 2.2.4 有符号数和无符号数之间的转换
#### 2.2.5 C语言中的有符号数和无符号数
#### 2.2.6 扩展一个数字的位表示
#### 2.2.7 截断数字
#### 2.2.8 关于有符号数和无符号数的建议

### 2.3 整数运算
#### 概要
#### 2.3.1 无符号加法
#### 2.3.2 补码加法
#### 2.3.3 补码的非
#### 2.3.4 无符号乘法
#### 2.3.5 补码乘法
#### 2.3.6 乘以常数
#### 2.3.7 除以2的幂
#### 2.3.8 关于整数运算的最后思考

### 2.4 浮点数
#### 概要
#### 2.4.1 二进制小数
#### 2.4.2 IEEE浮点表示
#### 2.4.3 数字示例
#### 2.4.4 舍入
#### 2.4.5 浮点运算
#### 2.4.6 C语言中的浮点数

### 2.5 小结

- 计算机将信息编码为位（比特），通常组织成字节序列。
- 通过不同的编码方式，可以表示整数、实数和字符串。
- **大多数机器对整数使用补码编码，而对浮点数使用 IEEE 标准 754 编码。** 在位级上理解这些编码，并且理解算数运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。
- 由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于0.0，从而转换为0时，也会下溢。
- 浮点表示通过将数字编码为`x * 2^y`的形式来近似地表示实数。最常见的浮点表示方法是由 IEEE 标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。IEEE浮点也能够表示特殊值 `+∞`、`-∞`和`NaN`。
- 必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算数属性，比如结合性。