<!-- TOC -->

- [第八章 优化](#第八章-优化)
    - [优化概要](#优化概要)
        - [在数据库级别进行优化](#在数据库级别进行优化)
        - [在硬件级别进行优化](#在硬件级别进行优化)
        - [平衡可移植性和性能](#平衡可移植性和性能)
    - [SQL语句优化](#sql语句优化)
        - [Where子句优化](#where子句优化)
        - [范围优化](#范围优化)
            - [单列索引的范围访问方法](#单列索引的范围访问方法)
            - [多列索引的范围访问方法](#多列索引的范围访问方法)
            - [多值比较的等价范围优化](#多值比较的等价范围优化)
            - [限制内存使用范围优化](#限制内存使用范围优化)
            - [行构造函数表达式的范围优化](#行构造函数表达式的范围优化)
        - [索引融合优化](#索引融合优化)
        - [引擎状态下推优化](#引擎状态下推优化)
        - [索引状态下推优化](#索引状态下推优化)
        - [嵌套循环连接算法](#嵌套循环连接算法)
        - [嵌套连接优化](#嵌套连接优化)
        - [左连接和右连接优化](#左连接和右连接优化)
        - [外连接简化](#外连接简化)
        - [多范围读取优化](#多范围读取优化)
        - [阻止嵌套循环和批量密钥访问连接](#阻止嵌套循环和批量密钥访问连接)
        - [IS NULL优化](#is-null优化)
        - [ORDER BY优化](#order-by优化)
        - [GROUP BY优化](#group-by优化)
        - [DISTINCT优化](#distinct优化)
        - [LIMIT查询优化](#limit查询优化)
        - [函数调用优化](#函数调用优化)
        - [行构造函数表达式优化](#行构造函数表达式优化)
        - [避免全表查询](#避免全表查询)
    - [优化和索引](#优化和索引)
        - [如何使用索引](#如何使用索引)
        - [使用主键](#使用主键)
        - [使用外键](#使用外键)
        - [列索引](#列索引)
            - [索引前缀](#索引前缀)
            - [全文索引](#全文索引)
            - [空间索引](#空间索引)
            - [MEMORY存储引擎中的索引](#memory存储引擎中的索引)
        - [多列索引](#多列索引)
        - [验证索引使用](#验证索引使用)
        - [InnoDB和MyISAM索引统计集合](#innodb和myisam索引统计集合)
        - [索引类型比较：B树和哈希](#索引类型比较b树和哈希)
            - [B树索引特征](#b树索引特征)
            - [Hash索引特征](#hash索引特征)
        - [使用索引扩展](#使用索引扩展)
        - [优化器使用生成的列索引](#优化器使用生成的列索引)
    - [优化数据库结构](#优化数据库结构)
    - [优化InnoDB引擎下的表](#优化innodb引擎下的表)
    - [优化MyISAM引擎下的表](#优化myisam引擎下的表)
    - [理解查询执行计划/步骤](#理解查询执行计划步骤)
    - [控制查询优化器](#控制查询优化器)
    - [缓冲与缓存](#缓冲与缓存)
    - [优化锁定操作](#优化锁定操作)
    - [优化MySQL Server](#优化mysql-server)
    - [衡量/测试性能](#衡量测试性能)
    - [检查线程信息](#检查线程信息)

<!-- /TOC -->

# 第八章 优化

## 优化概要

- 数据库性能取决于数据库级别的几个因素，例如表，查询和配置设置。 这些软件结构导致硬件级别的CPU和I / O操作，您必须尽可能地降低这些操作并使其尽可能高效。 在处理数据库性能时，首先要了解软件方面的高级规则和指南，并使用挂钟时间来衡量性能。 当您成为专家时，您将了解内部发生的更多信息，并开始测量CPU周期和I / O操作等内容。
- 典型用户的目标是从现有的软件和硬件配置中获得最佳的数据库性能。 高级用户寻找改进MySQL软件本身的机会，或者开发自己的存储引擎和硬件设备来扩展MySQL生态系统。

### 在数据库级别进行优化

使数据库应用程序快速运行的最重要因素是其基本设计：
- 表格结构合理吗？ 特别是，列是否具有正确的数据类型，并且每个表是否具有适合工作类型的列？ 例如，执行频繁更新的应用程序通常具有许多表但是较少列，，而分析大量数据的应用程序通常具有很少表但是较多列。
- 是否有适当的索引来提高查询效率？
- 您是否为每个表使用适当的存储引擎，并利用您使用的每个存储引擎的优势和功能？ 特别是，选择事务存储引擎（如InnoDB）或非事务性存储引擎（如MyISAM）对性能和可伸缩性非常重要
    - > NOTE: InnoDB是新表的默认存储引擎。 实际上，先进的InnoDB性能特征意味着InnoDB表通常优于更简单的MyISAM表，尤其是对于繁忙的数据库。
- 每个表是否使用适当的行格式？ 此选择还取决于用于表的存储引擎。 特别是，压缩表使用较少的磁盘空间，因此需要较少的磁盘I / O来读取和写入数据。 压缩适用于InnoDB表的各种工作负载，以及只读MyISAM表。
- 应用程序是否使用适当的锁定策略？ 例如，通过允许共享访问，以便数据库操作可以并发运行，并在适当时请求独占访问，以便关键操作成为首要任务。 同样，存储引擎的选择也很重要。 InnoDB存储引擎可以处理大多数锁定问题而无需您的参与，从而可以在数据库中实现更好的并发性并减少代码的实验和调优量
- 用于缓存的所有内存区域是否正确？ 也就是说，足够大以容纳频繁访问的数据，但不能太大以至于它们会超载物理内存并导致分页。 要配置的主要内存区域是InnoDB缓冲池，MyISAM密钥缓存和MySQL查询缓存。

### 在硬件级别进行优化

随着数据库业务变得越来越繁忙，任何数据库应用程序最终都会达到硬件限制。 DBA必须评估是否可以调整应用程序或重新配置服务器以避免这些瓶颈，或者是否需要更多硬件资源。 系统瓶颈通常来自这些来源：
- 磁盘搜索。 磁盘需要一段时间才能找到一段数据。 对于现代磁盘，平均时间通常低于10毫秒，因此我们理论上可以做到大约100次寻找。 这个时间用新磁盘缓慢改善，并且很难针对单个表进行优化。 优化搜索时间的方法是将数据分发到多个磁盘上。
- 磁盘读写。 当磁盘位于正确位置时，我们需要读取或写入数据。 使用现代磁盘，一个磁盘可提供至少10-20MB / s的吞吐量。 这比搜索更容易优化，因为您可以从多个磁盘并行读取。
- CPU周期。 当数据在主存储器中时，我们必须处理它以获得我们的结果。 将大表与内存量相比是最常见的限制因素。 但是对于小表，速度通常不是问题。
- 内存带宽。 当CPU需要的数据量超过CPU缓存容量时，主内存带宽就成了瓶颈。 对于大多数系统来说，这是一个不常见的瓶颈，但需要注意。

### 平衡可移植性和性能


## SQL语句优化

- 查询以SELECT语句的形式执行数据库中的所有查找操作。 调整这些语句是首要任务，无论是为动态网页实现亚秒响应时间，还是为了产生巨大的隔夜报告而缩短工作时间。
- 除了SELECT语句，查询的调优技术也适用于其他构造，例如`CREATE TABLE...AS SELECT`，`INSERT INTO...SELECT`，和`DELETE`语句中的`WHERE`子句等等。这些语句具有额外的性能考虑因素，因为它们将写操作与读取的查询操作相结合。
- NDB Cluster支持连接下推优化，从而将合格连接完整地发送到NDB Cluster数据节点，在NDB Cluster数据节点中可以将它们分布在NDB Cluster数据节点中并并行执行。 有关此优化的更多信息，请参阅第二十一章 NDB下推连接的条件
- 优化查询主要考虑因素是：
    - 使慢查询SELECT...WHERE语句更快，首先要检查是否可以添加索引。
        - 使用join和外键等功能下，索引对于引用不同表的查询尤其重要。 您可以使用EXPLAIN语句来确定哪些索引用于SELECT。 请参见第8.3.1节“MySQL如何使用索引”和第8.8.1节“使用EXPLAIN优化查询”。
    - 隔离并调整查询的任何部分，例如函数调用，这会占用过多时间。 根据查询的结构，可以为结果集中的每一行调用一次函数，甚至可以为表中的每一行调用一次函数，从而大大减轻低效率。
    - 最大限度地减少查询中的全表扫描次数，尤其是对于大型表。
    - 通过定期使用 ANALYZE TABLE 语句使表统计信息保持最新，因此优化程序具有构建有效执行计划所需的信息。
    - 了解特定于每个表的存储引擎的调优技术，索引技术和配置参数。 InnoDB和MyISAM都有一套指导方针，可以在查询中实现和维持高性能。 有关详细信息，请参见第8.5.6节“优化InnoDB查询”和第8.6.1节“优化MyISAM查询”。
    - 您可以使用第8.5.3节“优化InnoDB只读事务”中的技术优化InnoDB表的单查询事务。
    - 避免以难以理解的方式转换查询，尤其是在优化程序自动执行某些相同转换的情况下。
    - 如果其中一个基本准则无法轻松解决性能问题，请通过阅读EXPLAIN计划并调整索引，WHERE子句，join子句等来调查特定查询的内部详细信息。 （当您达到一定的专业水平时，阅读EXPLAIN计划可能是您每次查询的第一步。）
    - 调整MySQL用于缓存的内存区域的大小和属性。 通过有效使用InnoDB缓冲池，MyISAM密钥缓存和MySQL查询缓存，重复查询运行得更快，因为在第二次及以后的时间内从内存中检索结果。
    - 即使对于使用高速缓存存储区快速运行的查询，您仍可以进一步优化，以便它们需要更少的高速缓存，从而使您的应用程序更具可伸缩性。 可伸缩性意味着您的应用程序可以处理更多的并发用户，更大的请求等，而不会出现性能大幅下降的情况。
    - 处理锁定问题，其中查询的速度可能会受到同时访问表的其他会话的影响。

### Where子句优化

- 本节讨论可以为处理WHERE子句进行的优化。 这些示例使用SELECT语句，但相同的优化适用于DELETE和UPDATE语句中的WHERE子句。
    - > Note
    - > 由于MySQL优化器的工作正在进行中，因此并未记录MySQL执行的所有优化。
- 您可能想要重写查询以更快地进行算术运算，同时牺牲可读性。 因为MySQL会**自动执行**类似的优化，所以通常可以避免这种工作，并使查询保持更易理解和可维护的形式。 **MySQL执行的一些优化如下**：
    - 删除不必要的括号：
        ```sql
           ((a AND b) AND c OR (((a AND b) AND (c AND d))))
            -> (a AND b AND c) OR (a AND b AND c AND d)
        ```
    - 常量折叠：
        ```sql
           (a<b AND b=c) AND a=5
            -> b>5 AND b=c AND a=5
        ```
    - 常量状态移除
        ```sql
           (B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
            -> B=5 OR B=6
        ```
    - 索引使用的常量表达式仅计算一次
    - 在没有WHERE的单个表上的COUNT（*）直接从MyISAM和MEMORY表的表信息中检索。 当仅与一个表一起使用时，也可以对任何NOT NULL表达式执行此操作。（不是很懂这句话意思？）
    - 早期检测无效常量表达式。 MySQL快速检测到某些SELECT语句是不可能的，并且不返回任何行。
    - 如果不使用GROUP BY或聚合函数（COUNT（），MIN（）等），HAVING将与WHERE合并。
    - 对于连接中的每个表，构造一个更简单的WHERE以获得对表的快速WHERE评估，并且还尽快跳过行。
    - 在查询中的其他任何表之前，首先读取所有常量表。 常量表是以下任何一种：
        - 一张空表或一行表
        - 与PRIMARY KEY或UNIQUE索引上的WHERE子句一起使用的表，其中所有索引部分都与常量表达式进行比较并定义为NOT NULL。
        - 以下所有表都用作常量表：
            ```sql
            SELECT * FROM t WHERE primary_key=1;
            SELECT * FROM t1,t2
              WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
            ```
    - 通过尝试所有可能性，可以找到加入表格的最佳连接组合。 如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在加入时首先首选该表。
    - ...待后续继续整理！！！！！！！！！！！！！！！！！！！！！！！...
    - ...

### 范围优化

- 范围访问方法使用单个索引来检索包含在一个或多个索引值间隔内的表行的子集。 它可用于单个或多个索引。 以下部分介绍优化程序使用范围访问的条件。

#### 单列索引的范围访问方法
#### 多列索引的范围访问方法
#### 多值比较的等价范围优化
#### 限制内存使用范围优化
#### 行构造函数表达式的范围优化

### 索引融合优化
### 引擎状态下推优化
### 索引状态下推优化
### 嵌套循环连接算法
### 嵌套连接优化
### 左连接和右连接优化
### 外连接简化
### 多范围读取优化
### 阻止嵌套循环和批量密钥访问连接
### IS NULL优化
### ORDER BY优化
### GROUP BY优化
### DISTINCT优化
### LIMIT查询优化
### 函数调用优化
### 行构造函数表达式优化
### 避免全表查询

## 优化和索引

- 提高SELECT操作性能的最佳方法是创建一个或多个列上的索引。 索引条目的作用类似于表行的指针，允许查询快速确定哪些行与WHERE子句中的条件匹配，并检索这些行的其他列值。 可以索引所有MySQL数据类型。
- 尽管为查询中使用的每个可能列创建索引很有诱惑力，但不必要的索引会浪费空间并浪费时间让MySQL确定要使用的索引。 索引还会增加插入，更新和删除的成本，因为必须更新每个索引。 您必须找到适当的平衡，以使用最佳索引集实现快速查询。


### 如何使用索引

- 索引用于快速查找具有特定列值的行。 如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。 表越大，成本越高。 如果表中有相关列的索引，MySQL可以快速确定要在数据文件中间寻找的位置，而无需查看所有数据。 这比按顺序读取每一行要快得多。
- 大多数MySQL索引（PRIMARY KEY，UNIQUE，INDEX和FULLTEXT）都存储在B树中。除了，空间数据类型的索引使用R树; MEMORY表也支持哈希索引; InnoDB对FULLTEXT索引使用反转列表。
- MySQL使用索引进行这些操作：
    - 快速查找与Where子句匹配的行。
    - 考虑消除行。 如果在多个索引之间有选择，MySQL通常使用找到最小行数（最具选择性的索引）的索引。
    - 如果表具有多列索引，则优化程序可以使用索引的任何最左前缀来查找行。 例如，如果在（col1，col2，col3）上有三列索引，则在（col1），（col1，col2）和（col1，col2，col3）上可以应用索引搜索。 有关更多信息，请参见第8.3.5节“多列索引”。
    - 执行join操作时从其他表中检索行。 如果声明它们的类型和尺寸相同，MySQL可以更有效地使用列上的索引。在此上下文中，如果将VARCHAR和CHAR声明为相同大小，则认为它们是相同的。 例如，VARCHAR（10）和CHAR（10）的大小相同，但VARCHAR（10）和CHAR（15）不是。
    - 查找特定索引列key_col的MIN（）或MAX（）值。 这是由预处理器优化的，该预处理器检查您是否在索引中的key_col之前出现的所有关键部分上使用WHERE key_part_N =常量。 在这种情况下，MySQL对每个MIN（）或MAX（）表达式执行单个键查找，并用常量替换它。 如果所有表达式都替换为常量，则查询立即返回。 例如：
        ```sql
        SELECT MIN(key_part2),MAX(key_part2)
            FROM tbl_name WHERE key_part1=10;
        ```
    - 如果对可用索引的最左前缀（例如，ORDER BY key_part1，key_part2）进行排序或分组，则对表进行排序或分组。 如果所有key后面指定DESC，则按相反顺序读取key。 请参见第8.2.1.13节“ORDER BY优化”和第8.2.1.14节“GROUP BY优化”。
    - 在某些情况下，可以优化查询以在不咨询数据行的情况下检索值。 （为查询提供所有必要结果的索引称为覆盖索引。）如果查询仅使用表中包含某些索引的列，则可以从索引树中检索所选值以获得更快的速度：
        ```sql
        SELECT key_part3 FROM tbl_name
            WHERE key_part1=1
        ```
- 对于数据量小的表，或者需要查询大多数行的大表，这种情况下，索引就不太重要。当需要访问大多数行时，顺序读取比通过索引更快。顺序读取可以最大限度地减少磁盘搜索，即使查询不需要所有行也是如此。 有关详细信息，请参见第8.2.1.19节“避免全表扫描”。
- 索引效果特别的地方就是：在大数据量表中检索较少的数据库
    
### 使用主键

- 表的主键表示您在最重要的查询中使用的列或列集。 它具有快速查询性能的关联索引。 查询性能受益于NOT NULL优化，因为它不能包含任何NULL值。 使用InnoDB存储引擎，表格数据在物理上被组织为基于主键或列执行超快速查找和排序。
- 如果您的表很大且很重要，但没有使用明显的列或列集作为主键，则可以创建一个单独的列，其中包含一个自动增量值以用作主键。 使用外键加入表时，这些唯一ID可用作指向其他表中相应行的指针。

### 使用外键

- 如果一个表有很多列，并且您查询了许多不同的列组合，那么将频率较低的数据拆分为每个都有几列的单独表可能会很有效，并通过复制数字ID将它们与主表相关联。 主表中的列。 这样，每个小表都可以有一个主键来快速查找其数据，并且您可以使用连接操作仅查询所需的列集。 根据数据的分布方式，查询可能会执行较少的I / O并占用较少的高速缓存，因为相关列在磁盘上打包在一起。 （为了最大限度地提高性能，查询尝试从磁盘读取尽可能少的数据块;只有几列的表可以在每个数据块中容纳更多行。）

### 列索引

- 最常见的索引类型涉及单个列，在数据结构中存储该列的值的副本，允许快速查找具有相应列值的行。 B树数据结构允许索引在WHERE子句中快速查找特定值，一组值或一系列值，对应于运算符，如=，>，≤，BETWEEN，IN等。
- 每个存储引擎定义每个表的最大索引数和最大索引长度。 请参阅第14章，InnoDB存储引擎和第15章，可选存储引擎。 所有存储引擎每个表至少支持16个索引，总索引长度至少为256个字节。 大多数存储引擎都有更高的限制
- 有关列索引的其他信息，请参见第13.1.14节“CREATE INDEX语法”。

#### 索引前缀

- 使用字符串列的索引规范中的col_name（N）语法，可以创建仅使用列的前N个字符的索引。 以这种方式索引列值的前缀可以使索引文件更小。 索引BLOB或TEXT列时，必须为索引指定前缀长度。 例如：
    ```sql
    CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
    ```
- 前缀最长可达1000个字节（InnoDB表为767个字节，除非您设置了innodb_large_prefix）。
    - > Note:
    - > 前缀限制以字节为单位，而CREATE TABLE，ALTER TABLE和CREATE INDEX语句中的前缀长度被解释为非二进制字符串类型（CHAR，VARCHAR，TEXT）的字符数和二进制字符串类型的字节数（BINARY， VARBINARY，BLOB）。 在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑这一点。
- 有关索引前缀的其他信息，请参见第13.1.14节“CREATE INDEX语法”。
    
#### 全文索引

> 以下还有待理解，暂不清楚···

- FULLTEXT索引用于全文搜索。 只有InnoDB和MyISAM存储引擎支持FULLTEXT索引，并且仅支持CHAR，VARCHAR和TEXT列。 索引始终发生在整个列上，并且不支持列前缀索引。 有关详细信息，请参见第12.9节“全文搜索功能”。
- 优化适用于针对单个InnoDB表的某些类型的FULLTEXT查询。 具有这些特征的查询特别有效：
    - FULLTEXT查询仅返回文档ID，或（文档ID和搜索排名）
    - FULLTEXT查询按分数的降序对匹配的行进行排序，并应用LIMIT子句来获取前N个匹配的行。 要应用此优化，必须没有WHERE子句，并且只能按降序排列单个ORDER BY子句。
    - FULLTEXT查询仅检索与搜索词匹配的行的COUNT（*）值，而没有其他WHERE子句。 将WHERE子句编码为WHERE MATCH（text）AGAINST（'other_text'），不带任何> 0比较运算符。
- 对于包含全文表达式的查询，MySQL在查询执行的优化阶段评估这些表达式。 优化器不只是查看全文表达式并进行估计，它实际上是在开发执行计划的过程中对它们进行评估。
- 这种行为的含义是，对于全文查询，EXPLAIN通常比在优化阶段没有进行表达式评估的非全文查询慢。
- 对于全文查询的EXPLAIN可能会显示由于在优化期间发生匹配而在Extra列中优化的Select表; 在这种情况下，在以后的执行期间不需要进行表访问。

#### 空间索引

- 您可以在空间数据类型上创建索引。 MyISAM和InnoDB支持空间类型的R树索引。 其他存储引擎使用B树来索引空间类型（ARCHIVE除外，它不支持空间类型索引）。

#### MEMORY存储引擎中的索引

- MEMORY存储引擎默认使用HASH索引，但也支持BTREE索引。

### 多列索引

- MySQL可以创建复合索引（即多列上的索引）。 索引最多可包含16列。 对于某些数据类型，您可以索引列的前缀（请参见第8.3.4节“列索引”）。
- MySQL可以使用多列索引查询，测试在索引文件上的所有列，或者只测试第一列，前两列，前三列等。如果你指定的列的顺序是按照索引定义的，则单个复合索引可以加速同一张表上的多张查询。（多种查询，表示指定不同的where条件）
- 多列索引可以视为排序数组，其每行的值，是联合多列索引得到值。
    - > Note
    - > 作为复合/多列索引的一种替代品，你可以引入一列，该列的值是基于其它几列值的hash值。如果此列很短，独一，且有该列的索引，则它可能比多列索引更快。在MySQL中，使用这个额外的列非常容易：
        ```sql
        SELECT * FROM tbl_name
            WHERE hash_col=MD5(CONCAT(val1,val2))
            AND col1=val1 AND col2=val2;
        ```
- 假设一个表具有以下规范：
    ```sql
    CREATE TABLE test (
        id         INT NOT NULL,
        last_name  CHAR(30) NOT NULL,
        first_name CHAR(30) NOT NULL,
        PRIMARY KEY (id),
        INDEX name (last_name,first_name)
    );
    ```
- name索引是last_name和first_name列的索引。 该索引可用于查询中的查找，这些查询为last_name和first_name值的组合指定已知范围内的值。 它也可以用于仅指定last_name值的查询，因为该列是索引的最左前缀（如本节后面所述）。 因此，名称索引用于以下查询中的查找：
    ```sql
    SELECT * FROM test WHERE last_name='Widenius';

    SELECT * FROM test
      WHERE last_name='Widenius' AND first_name='Michael';
    
    SELECT * FROM test
      WHERE last_name='Widenius'
      AND (first_name='Michael' OR first_name='Monty');
    
    SELECT * FROM test
      WHERE last_name='Widenius'
      AND first_name >='M' AND first_name < 'N';
    ```
- 但是，名称索引不用于以下查询中的查找：
    ```sql
    SELECT * FROM test WHERE first_name='Michael';

    SELECT * FROM test
      WHERE last_name='Widenius' OR first_name='Michael';
    ```
- 假设你给出以下的SELECT语句：
    ```sql
    SELECT * FROM tbl_name
      WHERE col1=val1 AND col2=val2;
    ```
- 如果col1和col2上存在多列索引，则可以直接获取相应的行。 如果col1和col2上存在单独的单列索引，优化程序将尝试使用索引合并优化（请参见第8.2.1.3节“索引合并优化”），或尝试通过确定哪个索引排除更多行来查找限制性最强的索引 并使用该索引来获取行。
- 如果表具有多列索引，则优化程序可以使用索引的任何最左前缀来查找行。 例如，如果在（col1，col2，col3）上有三列索引，则在（col1），（col1，col2）和（col1，col2，col3）上编制索引搜索功能。
- 如果列不形成索引的最左前缀，则MySQL无法使用索引执行查找。 假设您有这里显示的SELECT语句：
    ```sql
    SELECT * FROM tbl_name WHERE col1=val1;
    SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
    
    SELECT * FROM tbl_name WHERE col2=val2;
    SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
    ```
- 如果（col1，col2，col3）上存在索引，则只有前两个查询使用索引。 第三个和第四个查询确实涉及索引列，但是（col2）和（col2，col3）不是（col1，col2，col3）的最左前缀。


### 验证索引使用

- 始终检查所有查询是否确实使用您在表中创建的索引。 使用EXPLAIN语句，如第8.8.1节“使用EXPLAIN优化查询”中所述。

### InnoDB和MyISAM索引统计集合


### 索引类型比较：B树和哈希

- 了解B树和哈希数据结构有助于预测不同查询在索引中使用这些数据结构的不同存储引擎上的执行情况，特别是对于允许您选择B树或哈希索引的MEMORY存储引擎。

#### B树索引特征

- B树索引可用于使用=，>，> =，<，<=或BETWEEN运算符的表达式中的列比较。 如果LIKE的参数是不以通配符开头的常量字符串，则索引也可用于LIKE比较。 例如，以下SELECT语句使用索引：
    ```sql
    SELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';
    SELECT * FROM tbl_name WHERE key_col LIKE 'Pat%_ck%';
    ```
- 在第一个语句中，只考虑带有'Patrick'<= key_col <'Patricl'的行。 在第二个语句中，仅考虑具有'Pat'<= key_col <'Pau'的行。
- 以下SELECT语句不使用索引：
    ```sql
    SELECT * FROM tbl_name WHERE key_col LIKE '%Patrick%';
    SELECT * FROM tbl_name WHERE key_col LIKE other_col;
    ```
- 在第一个语句中，LIKE值以通配符开头。 在第二个语句中，LIKE值不是常量。
- 如果您使用... LIKE'％string％'且string超过三个字符，MySQL使用Turbo Boyer-Moore算法初始化string的模式，然后使用此模式更快地执行搜索。
- 如果col_name被索引，则使用col_name IS NULL的搜索使用索引。
- 任何未跨越WHERE子句中所有AND级别的索引都不用于优化查询。 换句话说，为了能够使用索引，必须在每个AND组中使用索引的前缀。
- 以下WHERE子句使用索引：
    ```sql
    ... WHERE index_part1=1 AND index_part2=2 AND other_column=3

        /* index = 1 OR index = 2 */
    ... WHERE index=1 OR A=10 AND index=2
    
        /* optimized like "index_part1='hello'" */
    ... WHERE index_part1='hello' AND index_part3=5
    
        /* Can use index on index1 but not on index2 or index3 */
    ... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3;
    ```
- 以下WHERE子句不使用索引：
    ```sql
        /* index_part1 is not used */
    ... WHERE index_part2=1 AND index_part3=2
    
        /*  Index is not used in both parts of the WHERE clause  */
    ... WHERE index=1 OR A=10
    
        /* No index spans all rows  */
    ... WHERE index_part1=1 OR index_part2=10
    ```
- 有时MySQL不使用索引，即使有索引也是如此。 发生这种情况的一种情况是，优化器估计使用索引将需要MySQL访问表中的很大一部分行。 （在这种情况下，表扫描可能会快得多，因为它需要更少的搜索。）但是，如果这样的查询使用LIMIT只检索一些行，MySQL无论如何都使用索引，因为它可以更快地找到 结果中返回的几行。

#### Hash索引特征

- 散列索引与刚才讨论的特征有些不同：
    - 它们仅用于使用=或<=>运算符的相等比较（但速度非常快）。 它们不用于比较运算符，例如<找到一系列值。 依赖于这种类型的单值查找的系统被称为“键值存储”; 要将MySQL用于此类应用程序，请尽可能使用哈希索引。
    - 优化程序无法使用哈希索引来加速ORDER BY操作。 （此类型的索引不能用于按顺序搜索下一个条目。）
    - MySQL无法确定两个值之间大约有多少行（范围优化器使用它来决定使用哪个索引）。 如果将MyISAM或InnoDB表更改为哈希索引的MEMORY表，则可能会影响某些查询。
    - 只有整个键可用于搜索行。 （使用B树索引，键的任何最左边的前缀都可用于查找行。）


### 使用索引扩展


### 优化器使用生成的列索引



## 优化数据库结构

## 优化InnoDB引擎下的表

## 优化MyISAM引擎下的表

## 理解查询执行计划/步骤

## 控制查询优化器

## 缓冲与缓存

## 优化锁定操作

## 优化MySQL Server

## 衡量/测试性能

## 检查线程信息


