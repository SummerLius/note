<!-- TOC -->

- [sass](#sass)
    - [概要](#概要)
    - [快速入门](#快速入门)
    - [中文文档](#中文文档)
        - [特色功能](#特色功能)
        - [语法格式](#语法格式)
        - [使用Sass](#使用sass)
        - [css功能扩展](#css功能扩展)
        - [注释](#注释)
        - [SassScript](#sassscript)
        - [@规则与指令](#规则与指令)
        - [控制指令和表达式](#控制指令和表达式)
        - [混合指令（Mixin Directives）](#混合指令mixin-directives)
        - [函数指令](#函数指令)
        - [输出格式](#输出格式)
        - [拓展Sass](#拓展sass)

<!-- /TOC -->

# sass

## 概要

- [官方](https://sass-lang.com/)
- [中文网](https://www.sass.hk/)

## 快速入门



## 中文文档

Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。

### 特色功能

- 完全兼容 CSS3
- 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins)等功能
- 通过函数进行颜色值与属性值的运算
- 提供控制指令 (control directives)等高级功能
- 自定义输出格式

### 语法格式

Sass 有两种语法格式。
1. 首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。
2. 另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 "Sass"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference。这种格式以 .sass 作为拓展名。

任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式：
```scss
# Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
```

### 使用Sass

Sass可以通过以下三种方式使用：作为命令行；作为独立的Ruby模块；作为Rack-enabled框架的插件。

1. Rack/Rails/Merb Plugin
    - 略
2. 缓存
    - 略
3. 配置选项
    - 略
4. 判断语法格式
    - Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。
5. 编码格式
    - 略

### css功能扩展

1. 嵌套规则
    - Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器。
    - 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理。
        ```scss
        #main {
          width: 97%;
        
          p, div {
            font-size: 2em;
            a { font-weight: bold; }
          }
        
          pre { font-size: 3em; }
        }
        ```
        ```css
        #main {
          width: 97%; }
          #main p, #main div {
            font-size: 2em; }
            #main p a, #main div a {
              font-weight: bold; }
          #main pre {
            font-size: 3em; }
        ```
2. 父选择器 `&`
    - 在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 `&` 代表嵌套规则外层的父选择器。
    - 编译后的 CSS 文件中 `&` 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递。
        ```scss
        #main {
          color: black;
          a {
            font-weight: bold;
            &:hover { color: red; }
          }
        }
        ```
        ```css
        #main {
          color: black; }
          #main a {
            font-weight: bold; }
            #main a:hover {
              color: red; }
        ```
    - `&` 其后可以跟随后缀生成复合的选择器
        ```scss
        #main {
          color: black;
          &-sidebar { border: 1px solid; }
        }
        ```
        ```css
        #main {
          color: black; }
          #main-sidebar {
            border: 1px solid; }
        ```
3. 属性嵌套
    - 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。
    - 为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，一个冒号标识 `:`
        ```scss
        .funky {
          font: {
            family: fantasy;
            size: 30em;
            weight: bold;
          }
        }
        ```
        ```css
        .funky {
          font-family: fantasy;
          font-size: 30em;
          font-weight: bold; }
        ```
    - 命名空间也可以包含自己的属性值。
        ```scss
        .funky {
          font: 20px/24px {
            family: fantasy;
            weight: bold;
          }
        }
        ```
        ```css
        .funky {
          font: 20px/24px;
            font-family: fantasy;
            font-weight: bold; }
        ```
4. 占位符选择器 `%foo`
    - Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。
    - 与常用的 id 与 class 选择器写法相似，只是 `#` 或 `.` 替换成了 `%`。必须通过 `@extend` 指令调用，更多介绍请查阅 @extend-Only Selectors。
    - 当占位符选择器单独使用时（未通过 `@extend` 调用），不会编译到 CSS 文件中。

### 注释

- Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会。
- 插值语句 (interpolation) 也可写进多行注释中输出变量值。
    ```scss
    $version: "1.2.3";
    /* This CSS is generated by My Snazzy Framework version #{$version}. */
    ```
    ```css
    /* This CSS is generated by My Snazzy Framework version 1.2.3. */
    ```

### SassScript

在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。

通过插值，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。

1. Interactive Shell
    - Interactive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：
        ```sh
        $ sass -i
        >> "Hello, Sassy World!"
        "Hello, Sassy World!"
        >> 1px + 1px + 1px
        3px
        >> #777 + #777
        #eeeeee
        >> #777 + #888
        white
        ```
2. 变量：`$`
    - SassScript 最普遍的用法就是变量，变量以美元符号 `$` 开头，赋值方法与 CSS 属性的写法一样。
    - 直接使用即调用变量。
        ```scss
        $width: Sem;
        
        #main {
            width: $width;
        }
        ```
    - 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。
    - 将局部变量转换为全局变量可以添加 `!global` 声明。
        ```scss
        #main {
          $width: 5em !global;
          width: $width;
        }
        
        #sidebar {
          width: $width;
        }
        ```
        ```css
        #main {
          width: 5em;
        }
        
        #sidebar {
          width: 5em;
        }
        ```
3. 数据类型
    - 概要
        - SassScript支持8种数据类型：
            - 数字。`数字，1, 2, 13, 10px`
            - 字符串，有引号字符串与无引号字符串。`"foo", 'bar', baz`
            - 颜色。`blue, #04a3f9, rgba(255,0,0,0.5)`
            - 布尔值。`true, false`
            - 空值。`null`
            - 列表，用空格或逗号做分隔符。`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`
            - maps，键值对，相当于js中的对象。`(key1: value1, key2: value2)`
            - function references。
        - SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。
    1. Strings
        - SassScript 支持 CSS 的两种字符串类型：
            - 有引号字符串，单引号或双引号。
            - 无引号字符串 。
        - 注意编译css文件时，不会改变其字符串类型。只有一种情况例外，使用`#{}`插值时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名。
            ```scss
            @mixin firefox-message($selector) {
              body.firefox #{$selector}:before {
                content: "Hi, Firefox users!";
              }
            }
            @include firefox-message(".header");
            ```
            ```css
            body.firefox .header:before {
              content: "Hi, Firefox users!"; }
            ```
    2. Lists
        - list 指 Sass 如何处理 CSS 中 "margin: 10px 15px 0 0" 或者 "font-face: Helvetica, Arial, sans-serif" 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为list —— 只包含一个值的数组。
        - list 本身没有太多功能，但是相关list函数赋予了list跟多功能。
            - 例如，`nth` 函数可以直接访问list中的某一项；`join` 函数可以将多个数组连接在一起；`append` 函数可以在数组中添加新值；`@each` 指令能够遍历list中每一项。
        - 数组中可以包含子list。
            - 例如：`1px 2px, 5px 6px`，`(1px 2px) (5px 6px)`
    3. Maps
        - Maps可以看做键值对的对象。
            - `$map: (key1: value1, key2: value2, key3: value3);`
        - 类似list，map对象也通过 SassScript 函数来操作。
            - `map-get` 函数从map中获取值；`map-merge` 函数向map中添加值。
        - list能应用的地方map对象都能应用。在list应用的地方，会将map当做键值对列表，如 " key1 value1, key2 value2"。但是反过来不行。
        - `()` 既可以看做空map，也可以看做空list。
        - 任何类型的值，都可以作为map的key。
    4. Colors
        - 在scss中任何css颜色表达式，都表示一个SassScript颜色值。
    5. First Class Functions
        - 一个函数引用通过函数`get-function($function-name)`返回。
        - 该引用可以通过函数`call($function, $args...)`调用。
4. 运算符
    - 所有的运算符均支持相等运算符 `==` 或 `!=`。此外，每种数据类型也有其各自支持的运算方式。
    1. 数字运算符
        - SassScript支持数字的加减乘除等运算（`+, -, *, /, %`）。
        - 关系运算符（`<, >, <=, >=`）也可用于数字运算。
        - 相等运算符（`==, !=`）可用于任何类型。
            1. 除法运算和`/`
                - 以下几种情况`/`会被视为除法运算符：
                    - 如果值，或值的一部分，是变量或者函数的返回值
                    - 如果值被圆括号包裹
                    - 如果值是算数表达式的一部分
                        ```scss
                        p {
                              font: 10px/8px;             // Plain CSS, no division
                              $width: 1000px;
                              width: $width/2;            // Uses a variable, does division
                              width: round(1.5)/2;        // Uses a function, does division
                              height: (500px/2);          // Uses parentheses, does division
                              margin-left: 5px + 8px/2px; // Uses +, does division
                              font: (italic bold 10px/8px); // In a list, parentheses don't count
                            }
                        ```
                        ```css
                        p {
                            font: 10px/8px;
                            width: 500px;
                            height: 250px;
                            margin-left: 9px; }
                        ```
                - 如果需要使用变量，同时又要确保 `/` 不做除法运算而是完整地编译到 CSS 文件中，只需要用 `#{}` 插值语句将变量包裹。
                    ```scss
                    p {
                      $font-size: 12px;
                      $line-height: 30px;
                      font: #{$font-size}/#{$line-height};
                    }
                    ```
                    ```css
                    p {
                      font: 12px/30px; }
                    ```
    2. 颜色运算符
        - 较旧版本的Sass支持颜色值的算术运算，它们分别为每个颜色通道工作。 这意味着该操作依次在红色，绿色和蓝色通道上执行。
        - 然而，这些操作很少与人类对颜色在实践中的理解相一致。 它们已被弃用，并且在最新版本的Sass中不再受支持。样式表应使用 **颜色函数** 来操作颜色。
            ```scss
            p {
              color: #010203 + #040506;
            }
            ```
            ```css
            p {
              color: #050709; }
            ```
    3. 字符串运算符
        - `+` 可用于连接字符串
        - 如果有引号字符串（位于 `+` 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 `+` 左侧）连接有引号字符串，运算结果则没有引号。
        - 在有引号的文本字符串中使用 `#{}` 插值语句可以添加动态的值，空的值被视作插入了空字符串。
            ```scss
            p:before {
              content: "I ate #{5 + 10} pies!";
            }
            ```
            ```css
            p:before {
              content: "I ate 15 pies!"; }
            ```
    4. 布尔运算符
        - SassScript 支持布尔型的 `and` `or` 以及 `not` 运算。
    5. list运算符
        - 数组不支持任何运算方式，只能使用 list 函数操作。
5. 圆括号
    - 圆括号可以用来影响运算的顺序。
        ```scss
        p {
          width: 1em + (2em * 3);
        }
        ```
        ```css
        p {
          width: 7em; }
        ```
6. 函数
    - SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用。
        ```scss
        p {
          color: hsl(0, 100%, 50%);
        }
        ```
        ```css
        p {
          color: #ff0000; }
        ```
    - 关键词参数
        - Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成
            ```scss
            p {
              color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
            }
            ```
        - 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。
    - 访问[Module: Sass::Script::Functions](https://sass-lang.com/documentation/Sass/Script/Functions.html)查看完整的 Sass 函数列表，参数名，以及如何自定义函数。
7. 插值
    - 通过 `#{}` 插值语句可以在 选择器 或 属性名 中使用变量
    - `#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译 CSS
8. SassScript中的`&`
9. 变量默认：`!default`
    - 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。
        ```scss
        $content: "First content";
        $content: "Second content?" !default;
        $new_content: "First time reference" !default;
        
        #main {
          content: $content;
          new-content: $new_content;
        }
        ```
        ```css
        #main {
          content: "First content";
          new-content: "First time reference"; }
        ```
    - 变量是 null 空值时将视为未被 !default 赋值。
        ```scss
        $content: null;
        $content: "Non-null content" !default;
        
        #main {
          content: $content;
        }
        ```
        ```css
        #main {
          content: "Non-null content"; }
        ```

### @规则与指令

- Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。
1. `@import`
    - Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。
    - 被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。
    - 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。
        - 文件拓展名是 .css
        - 文件名以 http:// 开头
        - 文件名是 url()
        - @import 包含 media queries。
    - 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。
    - Sass 允许同时导入多个文件。
        - `@import "rounded-corners", "text-shadow";`
    - 导入文件也可以使用 #{} 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式
        ```scss
        $family: unquote("Droid+Sans");
        @import url("http://fonts.googleapis.com/css?family=\#{$family}");
        ```
    - 片段（Partials）
        - 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。
        - 例如，将文件命名为 "_colors.scss"，便不会编译 "_colours.css" 文件。
        - 注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。
    - Index Files
        - 当你import一个目录时，会默认导入该目录下的index文件，例如："_index.scss"
    - 嵌套@import
        - 大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。
        - > Directives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context.
        - > It's not possible to nest @import within mixins or control directives.
2. `@media`
    - Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。
    - 如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。
    - 这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。
        ```scss
        .sidebar {
          width: 300px;
          @media screen and (orientation: landscape) {
            width: 500px;
          }
        }
        ```
        ```css
        .sidebar {
          width: 300px; }
          @media screen and (orientation: landscape) {
            .sidebar {
              width: 500px; } }
        ```
    - @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and
        ```scss
        @media screen {
          .sidebar {
            @media (orientation: landscape) {
              width: 500px;
            }
          }
        }
        ```
        ```css
        @media screen and (orientation: landscape) {
          .sidebar {
            width: 500px; } }
        ```
    - @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值
        ```scss
        $media: screen;
        $feature: -webkit-min-device-pixel-ratio;
        $value: 1.5;
        
        @media #{$media} and ($feature: $value) {
          .sidebar {
            width: 500px;
          }
        }
        ```
        ```css
        @media screen and (-webkit-min-device-pixel-ratio: 1.5) {
          .sidebar {
            width: 500px; } }
        ```
3. `@extend`
    - @extend提高样式的重用。
    1. 如何工作
        - 将被继承的选择器的样式插入到待继承的样式中。
            ```scss
            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .error.intrusion {
              background-image: url("/image/hacked.png");
            }
            .seriousError {
              @extend .error;
              border-width: 3px;
            }
            ```
            ```css
            .error, .seriousError {
              border: 1px #f00;
              background-color: #fdd; }
            
            .error.intrusion, .seriousError.intrusion {
              background-image: url("/image/hacked.png"); }
            
            .seriousError {
              border-width: 3px; }
            ```
        - 当合并选择器的时候，@extend可以灵活的避免不必要的重复，会将".seriousError.seriousError" 这样的选择器转换为 ".seriousError"。此外，也不会产生不会匹配任何元素的选择器，例如 "#main#footer"
        - **工作流程**：
            - 看上面的代码，初步看上去，很有意思的一点是，在 ".seriousError" 选择器内继承选择器".error"，最后还会生成一个 ".seriousError.intrusion" 新选择器。这个继承逻辑过于“玄学”
            - 猜想：目前初步的猜想是这样，A选择器继承B选择器，那么会将 B 和 包含B的复合选择器 全部复制一遍，然后将复制的部分中的B替换成A。
    2. 多重继承
        - 一个选择器可以继承多个选择器。
        - 如果多个选择器中，有定义重复的样式，那么后面的会覆盖前面的。
        - 多重继承可以用逗号分隔选择器名。例如，`@extend .error, .attention;` 与 `@extend .error; @extend .attention;` 有相同的效果
            ```scss
            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .attention {
              font-size: 3em;
              background-color: #ff0;
            }
            .seriousError {
              @extend .error;
              @extend .attention;
              border-width: 3px;
            }
            ```
            ```css
            .error, .seriousError {
              border: 1px #f00;
              background-color: #fdd; }
            
            .attention, .seriousError {
              font-size: 3em;
              background-color: #ff0; }
            
            .seriousError {
              border-width: 3px; }
            ```
    3. 继承链
        - 当一个选择器继承给第二个选择器，可以继续将第二个选择器继承给第三个
            ```scss
            .error {
              border: 1px #f00;
              background-color: #fdd;
            }
            .seriousError {
              @extend .error;
              border-width: 3px;
            }
            .criticalError {
              @extend .seriousError;
              position: fixed;
              top: 10%;
              bottom: 10%;
              left: 10%;
              right: 10%;
            }
            ```
            ```css
            .error, .seriousError, .criticalError {
              border: 1px #f00;
              background-color: #fdd; }
            
            .seriousError, .criticalError {
              border-width: 3px; }
            
            .criticalError {
              position: fixed;
              top: 10%;
              bottom: 10%;
              left: 10%;
              right: 10%; }
            ```
    4. 选择器序列
        - 目前不可以将选择器序列继承给其它元素，但是却可以将其它元素继承给选择器序列。（例如，`.foo .bar` 或 `.foo + .bar`）
            ```scss
            #fake-links .link {
              @extend a;
            }
            
            a {
              color: blue;
              &:hover {
                text-decoration: underline;
              }
            }
            ```
            ```css
            a, #fake-links .link {
              color: blue; }
              a:hover, #fake-links .link:hover {
                text-decoration: underline; }
            ```
        - 合并选择器列
            - 略
    5. @extend-only
        - 有时，需要定义一套样式并不是给某个元素用，而是只通过 `@extend` 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。
        - 如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 `#` 或 `.` 被替换成了 `%`。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。
        - 占位符选择器需要通过继承指令使用，用法与 class 或者 id 选择器一样，被继承后，占位符选择器本身不会被编译。
            ```scss
            // This ruleset won't be rendered on its own.
            #context a%extreme {
              color: blue;
              font-weight: bold;
              font-size: 2em;
            }

            .notice {
              @extend %extreme;
            }
            ```
            ```css
            #context a.notice {
              color: blue;
              font-weight: bold;
              font-size: 2em; }
            ```
    6. `!optional` 声明
        - 该声明可以使`@extend`不产生任何新选择器。（有待测试）
    7. 在指令内部使用@extend
        - 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。
        - 也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。
        - 可以理解为像变量一样，有作用域限制。
    8. 继承复合选择器
        - 在新的sass版本中，不支持复合选择器的继承，例如 `.special.cool`、`a:hover` 等。
        - 总结下：也就是不继承序列选择器、复合选择器。
4. `@at-root`
5. `@debug`
6. `@warn`
7. `@error`

### 控制指令和表达式

- 概要
    - SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。
    - 控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。
1. `if()`
    - 内置函数`if()`，根据条件进行判断，返回两个结果中的一个。
        ```
        if(true, 1px, 2px) => 1px
        if(false, 1px, 2px) => 2px
        ```
2. `@if`
    - 若表达式返回非 false 或 null，则会使用内嵌的样式。
    - 同时，指令后面还可以跟 `@else if` 或 `@else` 语句。
        ```scss
        $type: monster;
        p {
          @if $type == ocean {
            color: blue;
          } @else if $type == matador {
            color: red;
          } @else if $type == monster {
            color: green;
          } @else {
            color: black;
          }
        }
        ```
        ```css
        p { 
          color: green; }
        ```
3. `@for`
    - 格式：
        - `@for $var from <start> through <end>`
        - `@for $var from <start> to <end>`
        - `$var`可以是任何变量名。
        - `<start>` 和 `<end>` 是SassScript脚本返回值为整数的表达式，当start大于end时，则循环自动调整为降序。
        - 使用 `through` 范围为 [start, end]；使用 `to` 范围为 [start, end)，不包含end。
    - 例子
        ```scss
        @for $i from 1 through 3 {
          .item-#{$i} { width: 2em * $i; }
        }
        ```
        ```css
        .item-1 {
          width: 2em; }
        .item-2 {
          width: 4em; }
        .item-3 {
          width: 6em; }
        ```
4. `@each`
    - 格式：
        - `@each $var in <list or map>`
        - `$var` 可以为任何变量。
        - `<list or map>` 是一个返回list或map的SassScript表达式。
            ```scss
            @each $animal in puma, sea-slug, egret, salamander {
              .#{$animal}-icon {
                background-image: url('/images/#{$animal}.png');
              }
            }
            ```
            ```css
            .puma-icon {
              background-image: url('/images/puma.png'); }
            .sea-slug-icon {
              background-image: url('/images/sea-slug.png'); }
            .egret-icon {
              background-image: url('/images/egret.png'); }
            .salamander-icon {
              background-image: url('/images/salamander.png'); }
            ```
    - 多重赋值
        - list多重赋值
            ```scss
            @each $animal, $color, $cursor in (puma, black, default),
                                              (sea-slug, blue, pointer),
                                              (egret, white, move) {
              .#{$animal}-icon {
                background-image: url('/images/#{$animal}.png');
                border: 2px solid $color;
                cursor: $cursor;
              }
            }
            ```
            ```css
            .puma-icon {
              background-image: url('/images/puma.png');
              border: 2px solid black;
              cursor: default; }
            .sea-slug-icon {
              background-image: url('/images/sea-slug.png');
              border: 2px solid blue;
              cursor: pointer; }
            .egret-icon {
              background-image: url('/images/egret.png');
              border: 2px solid white;
              cursor: move; }
            ```
        - map作为键值对列表
            ```scss
            @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
              #{$header} {
                font-size: $size;
              }
            }
            ```
            ```css
            h1 {
              font-size: 2em; }
            h2 {
              font-size: 1.5em; }
            h3 {
              font-size: 1.2em; }
            ```
4. `@while`
    ```scss
    $i: 6;
    @while $i > 0 {
      .item-#{$i} { width: 2em * $i; }
      $i: $i - 2;
    }
    ```
    ```css
    .item-6 {
      width: 12em; }
    
    .item-4 {
      width: 8em; }
    
    .item-2 {
      width: 4em; }
    ```

### 混合指令（Mixin Directives）

- 概要
    - 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。
    - 混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。
1. 定义Mixin：`@mixin`
    - Mixins通过指令 `@mixin` 定义，后面跟着mixin名、可选参数、内容块。
        ```scss
        @mixin large-text {
          font: {
            family: Arial;
            size: 20px;
            weight: bold;
          }
          color: #ff0000;
        }
        ```
    - Mixin也可以包含选择器、属性、父选择器引用`&`。
        ```scss
        @mixin clearfix {
          display: inline-block;
          &:after {
            content: ".";
            display: block;
            height: 0;
            clear: both;
            visibility: hidden;
          }
          * html & { height: 1px }
        }
        ```
    - 由于历史原因，mixin名可以将连字符和下划线互换。例如你定义了一个mixin名为add-column，然后你可以通过名add_column引用。
2. 引用Mixin：`@include`
    - 将mixin样式引用到某个样式规则中。
        ```scss
        .page-title {
          @include large-text;
          padding: 4px;
          margin-top: 10px;
        }
        ```
        ```css
        .page-title {
          font-family: Arial;
          font-size: 20px;
          font-weight: bold;
          color: #ff0000;
          padding: 4px;
          margin-top: 10px; }
        ```
    - mixin可以在任何样式规则外被引用，即在文档的最外层，不过这种mixin不能直接定义属性或父引用&。
        ```scss
        @mixin silly-links {
          a {
            color: blue;
            background-color: red;
          }
        }
        
        @include silly-links;
        ```
        ```css
        a {
          color: blue;
          background-color: red; }
        ```
    - 在mixin的定义中，可以引用其它的mixin
        ```scss
        @mixin compound {
          @include highlighted-background;
          @include header-text;
        }
        
        @mixin highlighted-background { background-color: #fc0; }
        @mixin header-text { font-size: 20px; }
        ```
3. 参数
    - mixin 可以接受SassScript值作为参数，同时可以指定参数的默认值。
        ```scss
        @mixin sexy-border($color, $width: 1in) {
          border: {
            color: $color;
            width: $width;
            style: dashed;
          }
        }
        p { @include sexy-border(blue); }
        h1 { @include sexy-border(blue, 2in); }
        ```
        ```css
        p {
          border-color: blue;
          border-width: 1in;
          border-style: dashed; }
        
        h1 {
          border-color: blue;
          border-width: 2in;
          border-style: dashed; }
        ```
    - **关键词参数**
        - 调用mixin时，传参数时可以指定准确的参数名，虽然不够简洁，但是可读性高、而且不用考虑参数顺序。
        - 另外，参数名被视为变量名时，下划线、短横线可以互换使用。
            ```scss
            p { @include sexy-border($color: blue); }
            h1 { @include sexy-border($color: blue, $width: 2in); }
            ```
    - **Trailing Commmas**
    - **可变参数**
        - 有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 'shadow' 会被用到。这时，可以使用参数变量 `…`声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：
            ```scss
            @mixin box-shadow($shadows...) {
              -moz-box-shadow: $shadows;
              -webkit-box-shadow: $shadows;
              box-shadow: $shadows;
            }
            .shadows {
              @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
            }
            ```
            ```css
            .shadowed {
              -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
              -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
              box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
            }
            ```
        - 在调用mixin时，也可以传入可变参数
            ```scss
            @mixin colors($text, $background, $border) {
              color: $text;
              background-color: $background;
              border-color: $border;
            }
            $values: #ff0000, #00ff00, #0000ff;
            .primary {
              @include colors($values...);
            }
            ```
            ```css
            .primary {
              color: #ff0000;
              background-color: #00ff00;
              border-color: #0000ff;
            }
            ```
4. 传递内容块到Mixin
    - 在引用mixin的时候，可以将一段代码传递到mixin中，然后再整合输出。传递的部分将出现在 `@content` 标记的地方：
        ```scss
        @mixin apply-to-ie6-only {
          * html {
            @content;
          }
        }
        @include apply-to-ie6-only {
          #logo {
            background-image: url(/logo.gif);
          }
        }
        ```
        ```css
        * html #logo {
          background-image: url(/logo.gif);
        }
        ```
    - 为了便于书写，`@minxin` 可以用 `=` 表示，而 `@include` 可以用 `+` 表示。
        ```scss
        =apply-to-ie6-only
          * html
            @content
        
        +apply-to-ie6-only
          #logo
            background-image: url(/logo.gif)
        ```
    - **变量作用域和内容块**
        - 传递给mixin的内容块的作用域在块定义的位置，而不是mixin内。
        - 这意味着mixin内的本地变量，不能在内容块中使用。
            ```scss
            $color: white;
            @mixin colors($color: blue) {
              background-color: $color;
              @content;
              border-color: $color;
            }
            .colors {
              @include colors { color: $color; }
            }
            ```
            ```css
            .colors {
              background-color: blue;
              color: white;
              border-color: blue;
            }
            ```
        - 内容块中的变量取决于其定义的位置。
            ```scss
            #sidebar {
              $sidebar-width: 300px;
              width: $sidebar-width;
              @include smartphone {
                width: $sidebar-width / 3;
              }
            }
            ```

### 函数指令

- sass支持自定义函数。
- 自定义函数参数同minxin类似，支持可变参数、关键词参数。
- 一个函数可以含有多条语句，需要调用 `@return` 输出结果。
- 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。
    ```scss
    $grid-width: 40px;
    $gutter-width: 10px;
    
    @function grid-width($n) {
      @return $n * $grid-width + ($n - 1) * $gutter-width;
    }
    
    #sidebar { width: grid-width(5); }
    ```
    ```css
    #sidebar {
      width: 240px; }
    ```

### 输出格式

- 概要
    - Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。
    - Sass 提供了四种输出格式，可以通过 `:style option` 选项设定，或者在命令行中使用 `--style` 选项。
1. `:nested`
    - Nested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。
    - 选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。
    - 当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。
        ```css
        #main {
          color: #fff;
          background-color: #000; }
          #main p {
            width: 10em; }
        
        .huge {
          font-size: 10em;
          font-weight: bold;
          text-decoration: underline; }
        ```
2. `:expanded`
    - Expanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。
        ```css
        #main {
          color: #fff;
          background-color: #000;
        }
        #main p {
          width: 10em;
        }
        
        .huge {
          font-size: 10em;
          font-weight: bold;
          text-decoration: underline;
        }
        ```
3. `:compact`
    - Compact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。
    - 嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。
        ```css
        #main { color: #fff; background-color: #000; }
        #main p { width: 10em; }
        
        .huge { font-size: 10em; font-weight: bold; text-decoration: underline; }
        ```
4. `:compressed`
    - Compressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。
        ```css
        #main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline}
        ```

### 拓展Sass

1. 自定义Sass函数
    - Sass为具有独特要求的用户提供了许多高级自定义。使用这些功能需要对Ruby有深刻的理解。
2. 存储缓存
    - Sass缓存已解析的文档，以便可以重复使用它们，而无需再次解析它们，除非它们已更改
    -  默认情况下，Sass会将这些缓存文件写入文件系统上的一个位置：cache_location。
    -  如果您无法写入文件系统或需要跨ruby进程或计算机共享缓存，则可以定义自己的缓存存储并设置：cache_store option。
3. 自定义导入
    - Sass导入器负责将路径传递给@import并为这些路径找到合适的Sass代码。 
    - 默认情况下，此代码是从文件系统加载的，但可以添加导入程序以通过HTTP从数据库加载，或使用与Sass预期不同的文件命名方案。
    - 可以将导入程序放在：load_paths数组中，与常规文件系统路径一起放置。
    - 解析@import时，Sass将通过加载路径查找成功导入路径的导入程序。找到一个后，将使用导入的文件。

