<!-- TOC -->

- [CSS](#css)
    - [概述](#概述)
    - [语法](#语法)
        - [@规则](#规则)
        - [选择器](#选择器)
            - [选择器分组](#选择器分组)
            - [元素选择器](#元素选择器)
            - [类选择器](#类选择器)
            - [ID选择器](#id选择器)
            - [通配选择器](#通配选择器)
            - [属性选择器](#属性选择器)
            - [相邻兄弟选择器](#相邻兄弟选择器)
            - [普通兄弟选择器](#普通兄弟选择器)
            - [子选择器](#子选择器)
            - [后代选择器](#后代选择器)
            - [伪类 Pseudo-class](#伪类-pseudo-class)
            - [伪元素 Pseudo-elements](#伪元素-pseudo-elements)
    - [结构和层叠](#结构和层叠)
        - [特殊性](#特殊性)
        - [继承](#继承)
        - [层叠](#层叠)
        - [小节](#小节)
    - [CSS声明](#css声明)
        - [尺寸属性](#尺寸属性)
        - [定位声明](#定位声明)
        - [文本声明](#文本声明)
        - [背景属性](#背景属性)
    - [//////////////////////////////////////](#)
    - [单位](#单位)
    - [//////////////////////////////////////](#-1)
    - [w3c官网css2.2标准](#w3c官网css22标准)
        - [第八章 box model](#第八章-box-model)
        - [第九章 visual formatting model](#第九章-visual-formatting-model)
    - [参考](#参考)

<!-- /TOC -->

# CSS

## 概述

- CSS指层叠样式表（Cascading Style Sheets）
- 作用：样式决定如何显示HTML元素
- 样式除了在样式表css中定义外，还可以在html文档内定义
- 把样式从html抽离出来定义，是为了将**内容和表现分离，从而提高工作效率**


样式层叠次序，优先级由低到高：
1. 浏览器缺省设置
2. 外部样式表
3. 内部样式表（位于head标签内部）
4. 内联样式（HTML元素内部）

## 语法

- **CSS规则**：
    - CSS规则由两个主要部分构成：**选择器**，**声明**
    - 一对选择器与声明块称为规则集（ruleset），简称为规则（rule）。
    - 一个元素Element可能被多个选择器选中，因此会有多个规则，有可能以不同的值去设置同一属性。CSS标准会规定优先级最高的那个生效，称之为 **层叠 cascade** 算法。
- **CSS语句**：
    - 规则是样式表的主体，通常样式表会包括大量的规则列表。
    - 除了规则语句外，还包括一些其它信息语句，用于设置字符集、引入其它外部样式表、引入字体等等
    - 语句类型：
        1. 规则。即选择器和声明对。
        2. at规则。以`@`开始，随后是标识符，一直到分号`;`或右大括号`}`结束。每个at规则由其标识符定义，可能有它自己的语法。at规则涵盖了meta信息（如@charset @import），条件信息（如 @media @document），描述信息（@font-face）。
        3. 不是上面类型的语句则是非法，被忽略
    - 条件规则组（conditional group rules）是特殊的at规则，可以嵌套语句。
- **注释**：
    - `/* xxx */`
- **选择器**：
    - 作用：选择HTML元素
- **声明**：
    - 构成：每条声明由一个属性和一个值组成
    - 属性：样式属性（style attribute）
    - 值：每个属性对应值
    - 属性和值被冒号分开
    - 格式：`h1 {color:red; font-size:14px;}`






### @规则

一个@规则是一个CSS语句，以`@`符号开头，后跟一个标识符，并包括到下一个分号`;`或右大括号`}`。

下面是一些@规则，由它们的标识符指定，每种规则都有不同的语法：
- `@charset`：定义样式表使用的字符集
- `@import`：告诉CSS引擎引入一个外部样式表
- `@namespace`：告诉CSS引擎必须考虑XML命名空间
- 嵌套@规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
    - `@media`：如果满足媒介查询条件则条件规则组里的规则生效
    - `@page`：描述打印文档时布局的变化
    - `@font-face`：描述将下载的外部的字体
    - `@keyframes`：描述CSS动画的中间步骤
    - `@supports`：如果满足给定条件规则，条件规则组里的规则生效
    - `@document`：如果文档样式表满足给定条件规则，条件规则组里的规则生效（推延至CSS4 规范）
- [详情见MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule)



条件规则组：
- 有一些@规则可以归为一类：**条件规则组**
- 这些语句使用相同的语法，都嵌套语句，或者是规则或@规则
- 条件规则组作用：它们所指的条件总等于true或false，如果为true，那么它们里面的语句生效。
- 条件规则组由**CSS3**定义：
    - `@media`
    - `@supports`
    - `@document`：（推延至CSS4规范）

### 选择器

- 基本选择器
    - 元素选择器
    - 类选择器
    - ID选择器
    - 通配选择器
    - 属性选择器
- 组合选择器
    - 相邻兄弟选择器：`+`
    - 普通兄弟选择器：`~`
    - 子选择器：`>`
    - 后代选择器：`_`
- 伪类
- 伪元素

#### 选择器分组

同时指定多个选择器对应同一个声明块

```css
p,div {xxx;}
```

#### 元素选择器

通过node节点名称匹配元素

语法：`元素 { 样式声明 }`

```css
span {
    color: #ffffff
}
```

#### 类选择器

使用 `.` 符号，类选择器会根据**元素的类属性中的内容匹配元素**。

可以指定元素名使用class组合使用，可以多个class组合使用。

语法：`.类名 { 样式声明 }`、`元素名.类名 { 样式声明}`、`.类名.类名 {}`

> 注意class名第一个字符不能使用数字，它无法在mozilla和firefox中起作用

```css
.myclass {xxx;}

span.myclass {xxx;}

.myclass1.myclass2 {xxx;}
```

#### ID选择器

匹配元素ID属性

语法：`#id属性 { 样式声明 }`

```css
#myid {xxx;}

div#sidebar {xxx;}

p#main[href] {xxx;}
```

#### 通配选择器

星号（\*）是通配选择器，它可以匹配任意类型的HTML元素。通配符号可以和其它选择器组合。

在CSS3中，星号可以和命名空间组合使用：
- xx
- xx
- xx

```css
*#myid {xxx;}
*.warning {xxx;}
```

#### 属性选择器

属性选择器通过元素**属性名**或**属性值**匹配元素。

语法：
- `[attr]`
    - 匹配含有以attr命名的属性的元素
- `[attr=value]`
    - 匹配含有以attr命名的属性，且值为value的元素
- `[attr~=value]`
    - 匹配含有以attr命名的属性，并且该属性是一个以空格space作为分隔的值列表，其中至少含有一个值为value
- `[attr|=value]`
    - 匹配含有以attr命名的属性，且该属性值是以"value"或"value-"为开头的元素
- `[attr^=value]`
    - 匹配含有以attr命名的属性，且该属性值以value开头的元素
- `[attr$=value]`
    - 匹配含有以attr命名的属性，且该属性值以value结尾的元素
- `[attr*=value]`
    - 匹配含有以attr命名的属性，且该属性值含有value的元素
- `[attr operator value i]`
    - 在上述所有选择器中，可以添加一个字符 `i` ，表示可以忽略属性值大小写（ascii范围内字母）


```css
a[href] {xxx;}

a[href="https://www.duoyi.com"] { xxx; }

a[href^="https"] { xxx; }

a[href$="https" i] { xxx; }
```

#### 相邻兄弟选择器

也被称为相邻选择器，它只会匹配紧跟前方元素的同胞元素。（同胞元素：表示元素处于同一层次，有同一个父元素）

语法：`前方元素 + 目标元素 { 样式声明 }`

```css
li + li {
    color: red;
}
```

#### 普通兄弟选择器

在使用 `~` 连接两个元素的时候，它会匹配第二个元素，条件是它必须在第二个元素之后（不一定相邻），且他们都有同一个父元素（即同胞元素，处于同一层次）

语法：`元素 ~ 元素 { 样式声明 }`

```css
p ~ span {
    xxx;
}
```

#### 子选择器

使用 `>` 连接两个元素时，它只会匹配那些作为第一个元素直接后代（子元素）的第二元素。

语法：`父元素 > 子元素 { 样式声明 }`

```css
div > span { xxx; }
```

#### 后代选择器
 使用 `_`（空白字符，一个或多个空白字符）连接两个元素时，仅匹配祖先是第一个元素的第二个元素。

 后代选择器和子选择器比较相似，前者仅要求同祖同族，后者严格要求父子。

 语法：`祖先元素 后代元素 { 样式声明 }`

 ```css
 div span {xxx;}
 ```

#### 伪类 Pseudo-class

CSS伪类：是添加到选择器的关键字，指定元素的特殊状态。

**伪类和伪元素，它们允许你不仅仅根据文档DOM树中的内容（元素名、属性、dom树结构等）对元素应用样式，而且还允许你根据外部动态因素来应用样式，例如内容的状态、鼠标的位置等等。**

语法：`selector:pseudo-class {样式声明}`

详情见：
- [MDN 伪类参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)
- [MDN CSS参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference)


#### 伪元素 Pseudo-elements

伪元素同伪类相似，伪元素添加到选择器，但不描述特殊状态，它们允许你为元素的某些部分（或子元素）设置样式。

语法：`selector::pseudo-element { 样式声明 }`

- ::after
- ::before
- ::first-letter
- ::first-line
- ::selection
- ...
- [MDN CSS参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference)
- [MDN 伪元素参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements)

## 结构和层叠

每个合法的HTML文档，都会生成一个结构树。有了这个结构树，选择器才能起作用，这也是CSS另外一个重要方面（继承）的核心。

继承，是从一个元素向其后代元素传递属性值所采用的机制。确定向一个元素具体应用那些样式时，用户代理不仅要考虑继承，还要考虑声明的特殊性，例外需要考虑声明本身的来源，这个过程就称为层叠（cascade）。

### 特殊性

对于每个规则（选择器+声明块），用户代理会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明。如果元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出。

选择器特殊性规则如下：
1. ID属性值，加 0.1.0.0
2. 类属性值、属性选择或伪类，加 0.0.1.0
3. 元素或伪元素，加 0.0.0.1
4. 结合符和通配符，没有任何贡献，即0特殊性

```css
h1 { color: red; } /* 0.0.0.1 */
p em { color: purple; } /* 0.0.0.2 */
.grape { color: purple; } /* 0.0.1.0 */
*.bright { color: yellow; } /* 0.0.0.1 */
p.bright em.dark { color: maroon; } /* 0.0.2.2 */
#id110 {  color: blue; } /* 0.1.0.0 */
div#sidebar *[href] { color: silver; } /* 0.1.1.1 */
```

- **声明和特殊性**
    - 一旦确定一个选择器的特殊性，这个值将会赋予对应每条相关声明
    - 对于每个CSS规则，由于特殊性的缘故，用户代理会将每个CSS规则 “解组” 为单独的规则，即将“分组选择器”和“声明块”解组为最小规则：单个选择器+单条声明，显然用户代理这样做是为了更好的处理
    - 若多个规则匹配同一个元素，且样式声明相互冲突时，特殊性则其作用

    ```css
    h1, h2.section { color: silver; background: black;}

    </* 用户代理解组 */>
    h1 { color: silver; }
    h1 { background: black; }
    h2.section { color: silver; }
    h2.section { background: black; }
    ```
- **通配选择器特殊性**
- **ID和属性选择器的特殊性**
    - ID特殊性 `#id`：0.1.0.0
    - 属性特殊性　`[id=id]`：0.0.1.0
- **内联样式特殊性**
    - 特殊性的第一位0，是为内联样式声明保留，它比所有其它声明的特殊性都高。
    - `<h1 style="color: green;">The head title</h1>`：1.0.0.0
- **重要性**
    - `!important`：使用重要标志的声明，不会添加特殊性值，用户代理不会将“重要性”和“特殊性”分为两类规则处理
    - 用户代理将声明分为：“重要声明” 和 “非重要声明” 两类处理
        - “重要声明”的特殊值冲突，会在重要声明内部处理
        - “非重要声明”的特殊值冲突，会在非重要声明内部处理
        - 若“重要声明”和“非重要声明”冲突，则总是“重要声明”胜出
    - 使用：`!important`总放在声明的最后，即分号的前面

### 继承

- 概念：
    - 基于继承机制，指定样式应用某元素，则样式不仅应用该元素，还可能会应用到它的后代元素。
- 继承是CSS最基本的内容，除非有必要的理由，否则一般不会特别考虑。
- 注意点：
    - 有些属性不能继承。例如，属性border就不能继承，其用于设置元素边框。如果border能继承，文档会变得更混乱，除非创作人员另外花功夫去掉继承的边框。
    - 一般的，大多数框模型属性都不能继承，例如外边距、内边距、背景和边框都不能继承，原因和上面也是一样。毕竟你肯定不希望一个段落中的所有链接都从其父元素继承30像素的左外边距。
    - 继承的值没有特殊性，甚至连0特殊性也没有。即css中0特殊性的规则（如通配符）要胜于继承的值。

### 层叠

层叠规则是最终决定元素的样式应用，其结合了特殊性和继承特性，**CSS2.1**层叠规则如下：

1. 找出所有相关规则，这些规则都包含与一个给定元素匹配的选择器。
2. 按显示权重对应用到该元素的所有声明排序。
    - 标志`!important`的规则的权重高于没有`!important`的标志的规则。
    - 按照来源对应用到给定元素的所有声明排序。
        - 来源：创作人员、读者、用户代理
        - 正常情况下，创作人员的样式要胜于读者的样式
        - 有`!important`标志的读者样式要强于其它所有样式，包括强于有`!important`标志的创作人员样式
        - 创作人员和读者样式都比用户代理默认样式强
3. 按特殊性对应用到给定元素的所有声明排序。有较高特殊性的声明的权重高于较低的。
4. 按出现的顺序排序。
    - 一个声明在样式表或文档中越后出现，它的权重越大。
    - 如果样式表中有导入样式表，一般认为导入的样式在前，主样式表中的所有声明在后


**具体的规则流程**：
- **按权重与来源排序**
    - 在规则声明的权重方面可以分为5级，权重由大到小顺序依次为：
        1. 读者的重要声明
        2. 创作人员的重要声明
        3. 创作人员的正常声明
        4. 读者的正常声明
        5. 用于代理声明
    - 创作人员通常只需要考虑前4个权重级别，因为任何声明都会胜过用户代理样式。
    - 虽说如此，作为创作人员，感觉仅需要考虑2个即可，即创作人员重要声明和创作人员正常声明。因为创作人员仅能控制自己的样式，无法控制读者样式。故创作人员样式处理时，仅需要考虑特殊性排序和顺序排序。
- **按特殊性排序**
    - 如果向一个元素应用多个声明并产生了冲突，而且他们的**权重相同**，则按特殊性排序，最特殊的声明优先。
- **按顺序排序**
    - 如果权重、特殊性都相同，那么在样式表中**后出现**的一个胜出
    - 一个应用顺序排序的重要例子就是：链接样式，如下代码，可见其权重、特殊性均相同，则按顺序最后一个胜出。一般推荐排序为link-visited-hover-active (LVHA)，当然搞清楚其中逻辑之后，你可以自定义不同的顺序，从而产生不同的效果。
    ```css
    <!-- 推荐顺序为：lvha -->
    a:link { color: blue;}
    a:visited { color:gray;}
    a:hover { color: red;}
    a:active { color: orange;}
    ```

### 小节

层叠样式表中最基本方面即层叠：冲突的声明要通过这个层叠过程排序，并由此最终决定最终的文档样式显示。

这个过程的核心是选择器及其相关声明的特殊性、继承机制。


## CSS声明

### 尺寸属性

- `height`：
    - 作用：设置元素高度，具体来讲是**元素内容区**高度，整个元素高度还包括margin、border、padding
    - 值选项：
        - auto：默认
        - length：
        - %：基于包含它的块级对象百分比高度
        - inherit
- `max-height`
    - 作用：给元素的高度设置一个最高限制，**不允许负值**
    - 值选项：
        - auto：默认值。没有最高限制。
        - ...
- `min-height`
    - 作用：给元素高度设置一个最低限制，**不允许负值**
- `width`
- `max-width`
- `min-width`

### 定位声明

- `display`
    - 作用：设置元素如何显示
    - 值选项：
        - none：使元素不显示
        - block：使元素显示为块级元素，前后会带有换行符
        - inline：默认。使元素显示为内联元素，前后没有换行符
        - table：使元素以块级元素显示，类似table元素
        - list-item：
        - run-in：
        - ...
- `visibility`
    - 作用：设置元素是否可见
    - 区别：注意`visibility:hidden` 和 `display:none` 区别，前者元素还在渲染树上占一个位置，可以看作仅透明；而后者是直接没有在渲染树上，不会占位置
    - 值选项：
        - visible：显示，默认
        - hidden：隐藏
        - collapse：
        - inherit
- `position`
    - 作用：设置元素的定位类型，与left、right、top、bottom一起起作用
    - 说明：建立元素布局所用的定位机制，任何元素都可以定位，**不过absolute或fixed元素会生成一个块级框**，而不论元素本身是什么类型。relative定位元素会相对于它在正常流中的默认位置偏移。
    - 值选项：
        - static：
            - 默认。元素正常布局,即元素在文档常规流中当前布局位置。此时top、right、bottom、left、z-index属性无效。
        - absolute：
            - 不为该元素在正常文档流中预留位置。
            - 通过相对于该元素最近的非static定位的祖先元素偏移，如果沿着父元素依次向上，只要发现是非static定位，则对其偏移，否则直到根元素html
        - fixed：
            - 不为该元素在正常文档流中预留位置。
            - 且相对与屏幕视口位置偏移。
        - relative：
        - inherit：
    - 注意：
        - 定位相对偏移时，fixed、absolute、relative，如果没有指定top、right、bottom、left值，但是浏览器可能会根据元素当前的位置来绘制，不会默认top、right等这些值为0，这点需要注意，例如如果定位设置为fixed，按理说相对屏幕偏移，应该在最左上方，当实际可能不是，除非开发者指定top:0、right:0等属性
- `left`
    - 作用：规定元素的左边缘。定义了定位元素左外边距与其包含块左边界之间的偏移。
    - 值选项：
        - auto：默认值。
        - %：元素包含块的宽度的百分比。可负值
        - length：使用px、cm等单位设置元素左边位置。可负值
        - inherit：
- `right`
- `top`
- `bottom`
- `float`
    - 作用：定义元素向那个方向浮动
    - 说明：
        - **浮动元素会生成一个块级框，而不论它本身是何种元素**
        - 该float影响的block，其不会单独占一行，也不会宽度占满父元素，而是宽度随内容变化，有点类似与display:inline-block
    - 值选项：
        - left：
        - right：
        - none：默认值
        - inherit：
- `clear`
    - 作用：规定元素哪一侧不允许其它浮动元素，与 `float` 作用相反
    - 值选项：
        - none：默认
        - left：
        - right：
        - both：
        - inherit：
- `overflow`
    - 作用：规定当内容溢出元素框时处理的方式
    - 值选项：
        - visible：默认值。内容不会被修剪，会呈现在元素框之外
        - hidden：内容会被修剪，故其余内容是不可见的
        - scroll：内容会被修剪，当可以通过滚动条查看其余内容（不管是否修剪，强制会出现滚动条）
        - auto：如果内容被修剪时，才会出现滚动条
        - inherit：
- ``
- ``
- ``
- ``
- ``
- ``

### 文本声明

- `line-height`：
    - 作用：设置行高
    - 说明：
        - 不允许使用负值
        - line-height和font-size的计算之差，即为行间距，其分为两半，分别加到行内容的顶部和底部。
        - 对于block元素，它指定了元素中的最小宽度
    - 值选项：
        - normal：默认
        - number：此数字会与当前的字体尺寸相乘来设置行间距
        - length：设置固定的行间距
        - %：基于当前字体尺寸百分比行间距
        - inherit：

### 背景属性

- `background-color`
    - 作用：设置元素的背景颜色
    - 说明：
        - 范围：content-area、padding、border，不包括margin
        - margin总是透明背景
    - 值选项：
        - *color_name*：
        - *hex_number*：
        - *rgb_number*：
        - *transparent*：默认值，透明
        - *inherit*：

## //////////////////////////////////////

## 单位

- 尺寸：%、in、cm、mm、em、ex、pt、pc、px等等
    - 常用：
        - %
        - em：1em与当前元素的字体大小相同（更具体地说，一个大写字母M的宽度）。CSS样式被应用之前，浏览器给网页设置的默认基础字体大小是16像素，这意味着对一个元素来说1em的计算值默认为16像素。但是要小心—em单位是会继承父元素的字体大小，所以如果在父元素上设置了不同的字体大小，em的像素值就会变得复杂。现在不要过于担心这个问题，我们将在后面的文章和模块中更详细地介绍继承和字体大小设置。em是Web开发中最常用的相对单位。
        - px： 是一种绝对单位（absolute units）， 因为无论其他相关的设置怎么变化，像素指定的值是不会变化的
- 颜色
    - 颜色名
    - rgb(x,x,x)
    - rgb(x%, x%, x%)
    - #rrggbb

## //////////////////////////////////////

## w3c官网css2.2标准

### 第八章 box model

### 第九章 visual formatting model

1. 简介
    - 可视化格式模型下，根据盒模型box model，dom-tree上的每个元素产生0至多个box，这些boxs的布局通过一下几个方面控制：
        1. box尺寸和类型
        2. 定位方案（正常流，浮动，绝对定位）
        3. dom-tree上元素的相互关系
        4. 外部信息（例如，视口尺寸，图片的固定尺寸等等）
    - 
2. 视口 viewport
3. 包含块 containing blocks
    - 在css2.2中，许多盒子的位置和大小是相对于称为**包含块**的矩形盒的边缘计算的。一般而言，当前的box充当后代box的包含块。
    - 每个box相对于其包含块被赋予一个位置，但是它的尺寸显示不受包含块的限制，它可能溢出
4. 控制box生成
5. 块级元素和块级盒
    - 块级元素会生成块级主盒（block-level principal box）
    - 使元素生成块级的 display为：block、list-item、table
    - 块级盒（block-level box）参与进BFC
    - 块级盒还是块容器盒，除了table box、或替换元素的主盒
    - 一个block container box，期内要么只包含块级盒，要么建立一个IFC内联格式上下文，该ifc内只包含内联盒子
    - 主盒为块容器盒的元素，是**块容器元素**
    - 重点：
        - 块级元素，即对应display为block、list-item、table的元素，肯定对应是 block-level box
        - block-level box 不一定是 block container box
        - block container box 不一定是 block-level box
        - block box：既是block-level box，也是block container box
        - 举例：
            - display:inlie-block的元素是container box，不是block-level box
6. 匿名block boxes
    - 亟待整理
7. 内联级别元素和内联盒
    - 内联级元素，不构成新内容块，其内容按行分布
    - 使元素为内联级：display：inline、inline-table、inline-block
    - 内联级元素生成内联级盒（inline-level boxes），这些boxes参与内联格式化上下文ifc
    - inline box，既是内联级别的，其contents也参与其内的ifc（内联格式化上下文）。
    - display值为inline的非替换元素，会生成inline box
    - 不是inline boxes的inline-level boxes称为**atomic inline-level boxex**，因为它们参与它们的ifc，作为单个不透明的box。（例如替换的inline-level元素，inline-block元素，inline-table元素）





<!-- - **长度单位**
    - 介绍：
        - 长度单位可为正数和负数，不过有些属性可能只接受正数。
        - 一个般情况下，数字后均需要带单位，只有一个例外：0
        - 长度单位可分为两类：绝对长度单位和相对长度单位
    -  -->




## 参考

- [MDN CSS参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference)
- [w3c CSS参考](http://www.w3school.com.cn/cssref/index.asp)
- 《css权威指南》
- [CDN参考：值与单位](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Values_and_units)
- [深入理解CSS中的长度单位](https://www.cnblogs.com/xiaohuochai/p/5485683.html)
- [w3c css2.2标准](https://www.w3.org/TR/CSS22)
