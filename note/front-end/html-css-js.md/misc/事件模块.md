<!-- TOC -->

- [DOM Event](#dom-event)
    - [整理](#整理)
        - [事件捕获机制](#事件捕获机制)
    - [Temp](#temp)
    - [//////////////////////////////////////////////////////////](#)
    - [DOM4 (2015-11-19)](#dom4-2015-11-19)
        - [第一章 一致性](#第一章-一致性)
        - [第二章 术语](#第二章-术语)
        - [第三章 事件 Events](#第三章-事件-events)
        - [第四章 节点 Nodes](#第四章-节点-nodes)
        - [第五章 节点范围 Nodes Ranges](#第五章-节点范围-nodes-ranges)
        - [第六章 遍历](#第六章-遍历)
        - [第七章 集合](#第七章-集合)
        - [第八章 历史](#第八章-历史)
        - [A：异常和错误](#a异常和错误)
        - [B：CSS 概念](#bcss-概念)
    - [DOM2 Events Specification (2000-11-13)](#dom2-events-specification-2000-11-13)
        - [第一章 dom2 事件模型概述](#第一章-dom2-事件模型概述)
        - [第二章 事件流](#第二章-事件流)
        - [第三章 事件监听器注册](#第三章-事件监听器注册)
        - [第四章 Event 接口](#第四章-event-接口)
        - [第五章 DocumentEvent 接口](#第五章-documentevent-接口)
        - [第六章 Event 模块定义](#第六章-event-模块定义)
    - [链接](#链接)

<!-- /TOC -->

# DOM Event

事件机制涉及的几个对象：
1. 事件：object --> 

2. 事件UI：object --> EventTarget --> Node --> Element --> ...
3. 事件监听器 / 事件处理器


## 整理

### 事件捕获机制

相关设置涉及到的对象或方法：
1. new Event(type, {bubbles:true})
2. target.addEventListener(type, listener, capture)
3. 分析：
    1. 首先，事件event对象中，bubbles参数为true，表示event在冒泡阶段可以被捕获；否则在冒泡阶段不能被捕获
    2. 然后，在target对象，添加事件监听器这边，其中参数capture，为true，则表示监听器只能监听处于capturing_phase和at_target阶段的事件；为false，则表示监听器只能监听处于bubbling_phase和at_target阶段的事件
    3. 显然，不论怎么设置，当event处于at_target阶段时，会被target的监听器正常捕获
4. 例子，可以运行下面例子测试
    ```html
    <!doctype html>
    <html>
      <head>
        <title>Boring example</title>
      </head>
      <body>
          
        <p>Hello <span id=x>world</span>!</p>
        
        <script>
          function test(e) {
            console.log(e.eventPhase)
          }
          
          document.addEventListener("hey", test, true)
          document.body.addEventListener("hey", test)
          
          var ev = new Event("hey", {bubbles:true})
          
          document.getElementById("x").dispatchEvent(ev)
        </script>
      </body>
    </html>
    ```



## Temp

- 模仿EventTarget对象
    ```js
    var EventTarget = function() {
        if (!this instanceof EventTarget) {
            return new EventTarget();
        }
    
        this.listeners = {};
    }
    
    EventTarget.prototype.listeners = null;
    
    EventTarget.prototype.addEventListener = function(type, listener) {}
    
    EventTarget.prototype.removeEventListener = function(type, listener) {}
    
    EventTarget.prototype.dispatchEvent = function(event) {}
    ```
- EventTarget对象，有点像Nodejs中event模块对象，其dispatchEvent方法就像Nodejs中的Event.emit方法一样，触发本对象监听事件
- 一个`<button>`的原型链：
    - object -> EventTarget -> Node -> Element -> HTMLElement -> HTMLButtonElement --操作--> `<button>`
    - Object -> Event -> UIEvent -> MouseEvent
- 事件流 event flow
- 事件对象：他被自动传递给事件处理函数
- 事件UI对象
- 事件监听器/事件处理器

## //////////////////////////////////////////////////////////

## DOM4 (2015-11-19)

### 第一章 一致性

### 第二章 术语

### 第三章 事件 Events

1. [介绍 DOM Events](#)
    - 在web平台上，事件作为发生信号被派遣到对象，例如网络活动、用户交互等。
    - 这些可以接受事件信号（events）的对象，实现了 `EventTarget` 接口，并且可以通过调用方法 `addEventListener()` 来添加事件监听器（event listeners）去监听事件。
    - 事件监听器（event listeners）可以通过调用方法 `removeEventListener()` 来移除监听器
    - 事件信号（Events）也是对象，并且实现了 `dom Event` 接口，当触发事件时，它作为参数被传递到事件监听器
        ```javascript
        function imgFetched(ev) {
             /*great success*/
        }
        obj.addEventListener("load", imgFetched);
        ```
    - 目前，虽然典型事件是由用户代理发出的，是用户交互或完成某些任务的结果，但是应用程序可以派遣/调度事件本身，通常称为合成事件（synthetic events）
        ```js
        // 添加一个事件监听器
        obj.addEventListener("cat", function(e) { process(e.detail) })
        
        // 自己创建和派遣事件
        var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
        obj.dispatchEvent(event)
        ```
    - 除了发信号，事件（events）有时候也被应用程序用于控制下一步操作、流程。
    - 例如，作为表单提交的一部分，其type属性为 “submit” 的事件被派遣。如果事件对象 preventDefault() 方法被调用，表单提交会被终止。
    - 当事件被发送到参与树的对象（例如元素）时，它可以到达目标对象的祖先（例如，根元素）...待整理...
2. [接口 Event](#)
    ```js
    [Constructor(DOMString type, optional EventInit eventInitDict),
     Exposed=(Window,Worker)]
    interface Event {
      readonly attribute DOMString type;
      readonly attribute EventTarget? target;
      readonly attribute EventTarget? currentTarget;
    
      const unsigned short NONE = 0;
      const unsigned short CAPTURING_PHASE = 1;
      const unsigned short AT_TARGET = 2;
      const unsigned short BUBBLING_PHASE = 3;
      readonly attribute unsigned short eventPhase;
    
      void stopPropagation();
      void stopImmediatePropagation();
    
      readonly attribute boolean bubbles;
      readonly attribute boolean cancelable;
      void preventDefault();
      readonly attribute boolean defaultPrevented;
    
      [Unforgeable] readonly attribute boolean isTrusted;
      readonly attribute DOMTimeStamp timeStamp;
    
      void initEvent(DOMString type, boolean bubbles, boolean cancelable);
    };
    
    dictionary EventInit {
      boolean bubbles = false;
      boolean cancelable = false;
    };
    ```
    - `event = new Event(type[, eventInitDict])`：返回一个新创建的event对象，其参数type被设置为事件对象的type属性，eventInitDict对象参数可以设置事件对象的bubbles和cancelable属性
    - `event.type`：事件的类型
    - `event.target`：事件起源目标的引用
    - `event.currentTarget`：当前被触发的事件监听器所在的目标对象
    - `event.eventPhase`：事件所处的阶段，为以下几个值之一：“NODE”、“CAPTURING_PHASE”、“AT_TARGET”、“BUBBLING_PHASE”
        1. node：在此阶段，事件当前没有被派遣，这是event的初始化阶段
        2. capturing_phase：当事件被派遣到dom tree上的目标对象，在event到target之前，其处于该阶段，即捕捉阶段
        3. at_target：当event派遣到target对象上时，处于该阶段
        4. bubbling_phase：当event过了target对象之后，处于该阶段，即冒泡阶段
    - `event.stopPropagation()`：当事件在dom树中派遣时，调用此方法可以阻止该事件到达除当前对象之外的任何对象。即，不再派发事件。
    - `event.stopImmediatePropagation()`：
    - `event.bubbles`：一个布尔值，用来表示这个事件是否在DOM中冒泡
    - `event.cacelable`：一个布尔值，用来表示这个事件是否可以取消
    - `event.preventDefault()`：取消事件默认行为，如果该事件可以取消
    - `event.defaultPrevented`：一个布尔值，表示是否已经执行过了event.preventDefault()
    - `event.isTrusted`：
    - `event.timeStamp`：
    - 每个event对象有以下初始未设置的标志flags
        1. 停止传播标志
        2. 停止即时传播标志
        3. 取消标志
        4. 初始化标志
        5. 派遣标志
    - ...待整理...
3. [接口 CustomEvent](#)
4. [构造事件](#)
5. [定义事件接口](#)
6. [接口 EventTarget](#)
    ```js
    [Exposed=(Window,Worker)]
    interface EventTarget {
      void addEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
      void removeEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
      boolean dispatchEvent(Event event);
    };
    
    callback interface EventListener {
      void handleEvent(Event event);
    };
    ```
    - EventTarget 是事件派遣的target对象。每一个EventTarget关联有一列事件监听器。
    - `target.addEventListener(type, listener [, capture=false])`
        1. 当capture为true，event处于冒泡阶段的话，不会被触发
        2. 当capture为false，event处于捕获阶段的话，不会被触发
        3. 无论capture为true或false，event处于AT_TARGET的话，会触发
    - `target.removeEventListener(type, listener [, capture=false])`
        - 从target上将指定的listener移除
    - `target.dispatch(event)`
        - 派遣一个合成事件到target，如果event对象的 “cancelable” 属性值为false或event对象的 “preventDefault()” 方法没有被调用，则返回true；否则返回false。
    - ...待整理...
7. [派遣事件](#)
    - 派遣一个事件event，到target对象，有以下步骤
        1. ...待整理...
    - 调用事件监听器，有以下步骤
        1. ...待整理...
8. [触发事件](#)
 
### 第四章 节点 Nodes
 
### 第五章 节点范围 Nodes Ranges
 
### 第六章 遍历

### 第七章 集合

### 第八章 历史

### A：异常和错误

### B：CSS 概念

## DOM2 Events Specification (2000-11-13)

### 第一章 dom2 事件模型概述
### 第二章 事件流
### 第三章 事件监听器注册
### 第四章 Event 接口
### 第五章 DocumentEvent 接口
### 第六章 Event 模块定义





## 链接

- [W3C 标准：W3C DOM4 2015-11-19](https://www.w3.org/TR/2015/REC-dom-20151119/)
- [W3C 标准：DOM2 Events Specification 2000-11-13](https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/)
- [W3C 标准：DOM](https://www.w3.org/standards/techs/dom#w3c_all)
- [W3C 标准：DOM events](https://www.w3.org/standards/techs/domevents#w3c_all)
- [MDN：文档对象模型 DOM](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model)
- [MDN：事件介绍](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events)
- [博客：javascript 之 - 深入事件机制](https://juejin.im/entry/5864af5861ff4b00631b259d)
- [博客：JavaScript 详说事件机制之冒泡、捕获、传播、委托](http://www.cnblogs.com/bfgis/p/5460191.html)
