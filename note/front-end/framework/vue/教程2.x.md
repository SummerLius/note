<!-- TOC -->

- [教程](#教程)
    - [基础](#基础)
        - [安装](#安装)
        - [介绍](#介绍)
        - [Vue实例](#vue实例)
        - [模版语法](#模版语法)
        - [计算属性和侦听器](#计算属性和侦听器)
        - [Class 与 Style 绑定](#class-与-style-绑定)
        - [条件渲染](#条件渲染)
        - [列表渲染](#列表渲染)
        - [事件处理](#事件处理)
        - [表单输入绑定](#表单输入绑定)
        - [组件基础](#组件基础)
    - [深入了解组件](#深入了解组件)
        - [组件注册](#组件注册)
        - [Prop](#prop)
        - [自定义事件](#自定义事件)
        - [插槽](#插槽)
        - [动态组件 & 异步组件](#动态组件--异步组件)
        - [处理边界情况](#处理边界情况)
    - [过渡 & 动画](#过渡--动画)
        - [进入/离开 & 列表过渡](#进入离开--列表过渡)
        - [状态过渡](#状态过渡)
    - [可复用性 & 组合](#可复用性--组合)
        - [混入](#混入)
        - [自定义指令](#自定义指令)
        - [渲染函数 & JSX](#渲染函数--jsx)
        - [插件](#插件)
        - [过滤器](#过滤器)
    - [工具](#工具)
        - [生产环境部署](#生产环境部署)
        - [单文件组件](#单文件组件)
        - [单元测试](#单元测试)
        - [TypeScript支持](#typescript支持)
    - [规模化](#规模化)
        - [路由](#路由)
        - [状态管理](#状态管理)
        - [服务端渲染](#服务端渲染)
    - [内在](#内在)
        - [深入响应式原理](#深入响应式原理)
    - [迁移](#迁移)
        - [从Vue 1.x迁移](#从vue-1x迁移)
        - [从Vue Router 0.7.x迁移](#从vue-router-07x迁移)
        - [从Vue 0.6.x迁移到1.0](#从vue-06x迁移到10)

<!-- /TOC -->

# 教程

## 基础

### 安装

记录于2018-03-29：
- [地址](https://cn.vuejs.org/v2/guide/installation.html)
- **兼容性**
    - Vue不支持IE8及以下的版本，因为Vue使用了IE8无法模拟ECMAScript5特性。但它支持所有[兼容es6的浏览器](https://caniuse.com/#feat=es5)
- **更新日志**
    - 当前稳定版本：2.5.16，每个版本的更新日志见GitHub
- vue引入
    - 直接文件下载
    - CDN引入
- NPM
- 命令行工具（CLI）
- 对不同构建版本的解释
    - 术语
    - 运行时+编译器VS只包含运行时
    - 开发环境vs生成环境模式
    - csp环境
- 开发版本
- Bower
- AMD模块加载器 

### 介绍

- `Vue.js是什么`
    - Vue是一套用户构建用户界面的渐近式框架。与其它大型框架不同的是，vue被设计为可以自底向上逐层应用。vue的核心库只关注视图层，不仅容易上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，vue也完全能够为复杂的单页面应用提供驱动。
- `起步`
- `声明式渲染`
    - vue的核心是一个允许采用简洁的模版语法来声明式地将数据渲染进DOM的系统。
    - 在html的`<script>`部分使用`new Vue()`对象，可以将vue实例对象的数据绑定元素的属性值、文本值等
    - `{{  }}`、`v-bind`
    - 指令带有前缀 `v-`，以表示它们是vue提供的特殊特性。它们会在渲染的DOM上应用特殊的响应式行为。 
- `条件与循环`
    - `v-if`，可以控制元素是否显示，表示vue不仅可以把数据绑定到DOM**文本或属性**，还可以绑定控制DOM**结构**。
    - 还有其它很多指令，每个都有特殊功能。例如，`v-for`指令可以绑定数组的数据来渲染一个项目列表。
- `处理用户输入`
    - 为了让用户和应用进行交互，我们可以用 `v-on` 指令添加一个事件监听器，通过它调用在Vue实例中定义的方法。
    - vue还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。
- `组件化应用构建`
    - 组件系统是Vue的另一个重要概念。因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树。
    - 在Vue里，一个组件本质上是一个拥有预定义选项的Vue实例。
    - 使用组件时，子单元可以通过 `prop` 接口与父单元进行良好的解耦。
    - 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。
    ```html
    <div id='app'>
        <app-nav></app-nav>
        <app-view>
            <app-sidebar></app-sidebar>
            <app-content></app-content>
        </app-view>
    </div>
    ```
    - `自定义元素的关系`
        - Vue组件的做法非常类似自定义元素————它是Web组件规范的一部分，这是因为Vue组件语法部分参考了该规范。同时也有一些差别。
- 准备好了吗

问题：
1. 什么是渐近式框架？
2. 什么是自底向上设计？


```js
new Vue({
    el: '#app-6',
    data: {
        message: 'Hello World!'
    },
    methods: {
        reverseMessage: function () {}
    }
});
```

### Vue实例

- `创建一个Vue实例`
    - 每个Vue应用都是通过 `Vue` 构造函数创建一个新的Vue实例开始的：
        ```js
        var vm = new Vue({
            // 选项
        });
        ```
    - 虽然没有完全遵循 `MVVM` 模型，但是Vue的设计也受到了它的启发，因此在文档中经常使用vm（ViewModel的缩写）这个变量表示Vue实例。
    - 当创建一个Vue实例时，也可以传一个**选项对象**，即参数。使用该选项对象可以创建你想要的行为。
    - 一个Vue应用由一个通过 `new Vue` 创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成。详细会在组件系统章节中展开，此处仅需明白所有的**Vue组件都是Vue实例**，并且接受相同的选项对象。 
- `数据与方法`
    - 当一个Vue实例被创建时，**它向Vue的响应式系统中加入了其 `data` 对象中能找到的所有属性**。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。
        ```js
        var data = {a: 1};
        var vm = new Vue({
            data: data
        });

        vm.a == data.a; // true

        // 给vm.a或data.a赋值，都会相互同步
        vm.a = 2;
        data.a // => 2

        data.a = 3;
        vm.a // => 3
        ```
    - 当这些数据改变时，视图自动进行重渲染。
    - 值得注意的，只有当实例 `data` 中存在的属性才是**响应式**的。比如，你新添加一个属性，`vm.b = 1`，那么对于b后续的改动不会触发任何视图更新，也就是说如果想要数据有效，必须事先在 `data` 对象中预设。同时，如果`data`对象使用了`Object.freeze()`，这会阻止修改现有的属性，也意味着响应系统无法追踪变化。
    - 除了数据属性，Vue实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。例如：
        ```js
        var data = {a: 1};
        var vm = new Vue({
            el: '#example',
            data: data
        });

        vm.a === data.a; // true
        vm.$data === data; // true
        vm.$el === document.getElementById('example'); // true
        
        // vm 实例方法
        vm.$watch('a', function(newValue, oldValue) {
            // 这个回调将在vm.a改变后调用
        }); 
        ```
    - vm实例完整的实例属性和方法可参考API
- `实例生命周期钩子`
    - 每个Vue实例，在被创建时都要经过一系列的初始化过程，例如，需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同的阶段添加自己代码的机会。
    - 生命周期钩子的 `this` 上下文指向调用它的Vue实例。
    - > 不要在选项属性或回调上使用**箭头函数**，比如 `created: () => {}` 或 `vm.$watch('a', () => {})`。因为箭头函数是和父级上下文绑定在一起的，箭头函数里面的`this`不会是如你所预期的Vue实例。所以会经常报错。
- `生命周期图示`
    - 下图展示了实例的生命周期。
        ![](../../../../assets/vue_vm_lifecycle.png)

### 模版语法

- `其它`
    - Vue使用了基于HTMl的模版语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。所有Vue的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。
    - 在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数见到最少。
    - 如果你熟悉虚拟DOM并且偏爱JS的原始力量，你也可以不使用模板，直接写渲染（render）函数，使用可选的JSX语法。
- `插值`
    - `文本`
        - 数据绑定最常见的形式就是使用“Mustache”语法（双大括号）的文本插值：`<span>Message: {{ msg }}</span>`，Mustache标签将会替代为对应数据对象vm.$data上`msg`属性的值。无论何时，绑定的数据对象上`msg`属性发生了变化，插值处的内容都会更新。
        - 通过使用 `v-once 指令`，可以执行一次性的插值，当数据改变时，插值处的内容不会更新。`<span v-once>这个将不会改变： {{ msg }}</span>`。
    - `原始HTML`
        - Mustache双大括号会将数据解释为普通文本，而非HTML代码。为了输出真正的HTML，需要使用 `v-html` 指令。
        - > 注意，站点上动态渲染任意的HTML可能会比较危险，因为它很容易导致XSS攻击。请只对可信的内容使用HTML插值，不要对用户提供的内容使用插值。
    - `特性`
        - 注意Mustache语法不能用在HTMl特性/属性上，遇到这种情况应该使用 `v-bind 指令`：`<div v-bind:id="dynamicId"></div>`
    - `使用JavaScript表达式`
        - 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。**但实际上对于所有的数据绑定，Vue都提供了完全的JS表达式支持**。
            ```js
            {{ number + 1 }}

            {{ ok ? 'Yes' : 'No' }}

            {{ messsage.split('').reverse().join('') }}
            ```
        - 这些表达式会在所属Vue实例的数据作用域下作为JS被解析。有个**限制就是**，每个绑定都只能包含**单个表达式**，所以下面的例子都不会生效。
            ```js
            // 这是语句，不是表达式
            {{ var a = 1 }}

            // 控制流也不会生效，请使用三元表达式
            if(ok) { return message } 
            ```
        - 模版表达式都被放到沙盒中，只能访问全局变量的一个白名单，如Math和Date。你不应该在模板表达式中试图访问用户定义的全局变量。
- `指令`
    - `其它`
        - 指令（Directives）是带有 `v-` 前缀的特殊特性。指令特性的值预期是**单个JavaScript表达式**（v-for 是例外）。
        - 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM。
        - 例如：`<p v-if="seen">现在你看到我了</p>`
    - `参数`
        - 一些指令能够接受一个“参数”，在指令名称之后以冒号表示。例如，`v-bind`和`v-on`指令
        - `v<a v-bind:href="url">...</a>`，这里的href是参数，告诉v-bind指令，将该元素的href特性与表达式url的值绑定
        - `<a v-on:click="doSomething">...</a>`，这里的参数是监听的事件名
    - `修饰符`
        - 修饰符Modifiers是以半角句号 `.` 指明的特俗后缀，用于指定一个指令应该以特殊方式绑定。例如 `.prevent` 修饰符告诉 v-on 指令对于触发的事件调用 `event.preventDefault()`
            ```html
            <form v-on:submit.prevent="onSubmit">...</form>
            ```
- `缩写`
    - “v-” 指令，可以有缩写，例如
        ```html
        <!-- 完整语法 -->
        <a v-bind:href="url">...</a>
        
        <!-- 缩写 -->
        <a :href="url">...</a>

        <!-- 完整语法 -->
        <a v-on:click="doSomething">...</a>
        
        <!-- 缩写 -->
        <a @click="doSomething">...</a>
        ```

### 计算属性和侦听器

- [计算属性](#)
    1. [概要](#)
        - 模板内的表达式非常便利，但是设计它们初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重并难以维护。例如：
            ```html
            <div id="example">
              {{ message.split('').reverse().join('') }}
            </div>
            ```
        - 在此例子中，模板中逻辑可读性不高，必须看一段时间后才能意识到。所以对于，复杂的逻辑，应该使用**计算属性**
    2. [基础例子](#)
        ```html
            <div id="example">
              <p>Original message: "{{ message }}"</p>
              <p>Computed reversed message: "{{ reversedMessage }}"</p>
            </div>
        ```
        ```javascript
            var vm = new Vue({
              el: '#example',
              data: {
                message: 'Hello'
              },
              computed: {
                // 计算属性的 getter
                reversedMessage: function () {
                  // `this` 指向 vm 实例
                  return this.message.split('').reverse().join('')
                }
              }
            })
        ```
        - 这里我们声明了一个计算属性 `reverseMessage`，我们提供的computed函数将用作属性 `vm.reverseMessage` 的 getter 函数。
    3. [计算属性缓存VS方法](#)
        ```html
        <p>Reversed message: "{{ reversedMessage() }}"</p>
        ```
        ```js
        // 在组件中
        methods: {
          reversedMessage: function () {
            return this.message.split('').reverse().join('')
          }
        }
        ```
        - 你可能已经注意到，我们可以在模板中直接 调用方法 来达到同样的效果，但是也要注意区别
        - **计算属性是基于它们的依赖进行缓存的。计算属性 只有在它的相关依赖发生改变时才会重新求值**。这就意味着，只要 `message` 还没有发生改变，多次访问 `reverseMessage` 计算属性会立即返回之前的计算结果，而不会再次执行函数。
        - 这同样意味着下面例子的计算属性将不再更新，因为 `Date.now()` 没有依赖：
            ```js
            computed: {
              now: function () {
                return Date.now()
              }
            }
            ```
        - 相比，每当触发重新渲染时，**调用方法** 将总会再次执行函数。
        - 针对不同的应用场景，来选择使用 “计算属性缓存” 或 “调用方法”
            1. 对于存在依赖属性，并且计算量大的、需要缓存的场景，可以使用 “计算属性”
            2. 如果明确不希望有缓存，使用 “调用方法”
    4. [计算属性 VS 侦听属性](#)
        - Vue 提供了一种更通用的方式来观察和响应Vue实例上的数据变动：**侦听属性**
        - 当你有一些数据需要随着其他数据的变动而变动时，你很容易滥用 `watch`。然而，通常更好的做法是使用计算属性，而不是命令式的 `watch` 回调。
        - 细想一下下面的例子：
            ```html
            <div id="demo">{{ fullName }}</div>
            ```
            ```js
            // watch 方式
            var vm = new Vue({
             el: '#demo',
             data: {
               firstName: 'Foo',
               lastName: 'Bar',
               fullName: 'Foo Bar'
             },
             watch: {
               firstName: function (val) {
                 this.fullName = val + ' ' + this.lastName
               },
               lastName: function (val) {
                 this.fullName = this.firstName + ' ' + val
               }
             }
            })
            ```
            ```js
            // 计算属性方式
            var vm = new Vue({
              el: '#demo',
              data: {
                firstName: 'Foo',
                lastName: 'Bar'
              },
              computed: {
                fullName: function () {
                  return this.firstName + ' ' + this.lastName
                }
              }
            })
            ```
        - 由上面例子，可以看到 “计算属性” 的写法更加精简，美观
    5. [计算属性的 setter](#)
        - 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：
            ```js
            computed: {
              fullName: {
                // getter
                get: function () {
                  return this.firstName + ' ' + this.lastName
                },
                // setter
                set: function (newValue) {
                  var names = newValue.split(' ')
                  this.firstName = names[0]
                  this.lastName = names[names.length - 1]
                }
              }
            }
            ```
        - 现在运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应的被更新。
- [侦听器](#)
    1. [概要](#)
        - 虽然计算属性在大多数情况下更合适，但是有时也需要一个自定义的侦听器。这就是为什么Vue通过 watch 选项提供一个更通用的方法，来响应数据变化。
        - 当需要在数据变化时执行 **异步** 或 **开销较大** 的操作时，这个方法时最有用的。

### Class 与 Style 绑定

- [概要](#)
    1. [概要](#)
        - 操作元素的class和内联样式是数据绑定的常见需求。因为它们都是属性，所以可以用 `v-bind` 处理它们，只需要通过表达式计算出字符串结果即可。
        - 不过，字符串拼接麻烦且易错，因此, v-bind 用于 class 和 style 时，Vue做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组
- [绑定HTML class](#)
    1. [对象语法](#)
        - 对象的属性为类名，属性值的true和false，来控制是否该类名开关
        ```html
        <div class="static"
             v-bind:class="{ active: isActive, 'text-danger': hasError}">
        </div>

        <script>
        data: {
          isActive: true,
          hasError: false
        }
        </script>
        ```
        ```html
        <div v-bind:class="classObject"></div>

        <script>
        data: {
          classObject: {
            active: true,
            'text-danger': false
          }
        }
        </script>
        ```
        ```html
        <div v-bind:class="classObject"></div>

        <script>
        data: {
          isActive: true,
          error: null
        },
        computed: {
          classObject: function () {
            return {
              active: this.isActive && !this.error,
              'text-danger': this.error && this.error.type === 'fatal'
            }
          }
        }
        </script>
        ```
    2. [数组语法](#)
        ```html
        <div v-bind:class="[activeClass, errorClass]"></div>

        <!-- 或 -->
        <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
        
        <!-- 或 -->
        <div v-bind:class="[{ active: isActive }, errorClass]"></div>

        
        <script>
        data: {
          activeClass: 'active',
          errorClass: 'text-danger',
          
          isActive:　true
        }
        </script>
        ```
    3. [用在组件上](#)
        - 当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素已存在的类不会被覆盖。
        - 例如，如果你声明了组件：`Vue.component('my-component', {template: '<p class="foo bar">Hi</p>'})`
        - 然后使用时添加一些class：`<my-component class="baz boo"></my-component>`
        - 最后html将被渲染为：`<p class="foo bar baz boo">Hi</p>`
        - 对于带数据绑定class也同样适用：`<my-component v-bind:class="{ active: isActive }"></my-component>`
- [绑定内联样式](#)
    1. [对象语法](#)
        - `v-bind:style` 的对象语法十分直观，看着非常像CSS，但其实是一个JS对象。
        - CSS属性名可以用 驼峰式或短横线 分隔来命名
        - 同样的，对象语法常常结合返回对象的计算属性使用
        ```html
        <div v-bind:style="styleObject"></div>

        <script>
        data: {
          styleObject: {
            color: 'red',
            fontSize: '13px'
          }
        }
        </script>
        ```
    2. [数组语法](#)
        - `v-bind:style` 的数组语法可以将多个样式对象，应用到同一个元素上
        ```html
        <div v-bind:style="[baseStyles, overridingStyles]"></div>
        ```
    3. [自动添加前缀](#)
        - 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。
    4. [多重值](#)
        - 从 Vue@2.3.0 版本起，可以为 style 绑定的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：
        - `<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>`
        - 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。

### 条件渲染

- [v-if](#)
    1. [概要](#)
        - 在字符串模板中，比如[handlebars库](http://handlebarsjs.com/)，我们得像这样写一个条件块：
            ```html
            <!-- Handlebars 模板 -->
            {{#if ok}}
              <h1>Yes</h1>
            {{/if}}
            ```
        - 在Vue中，我们使用 `v-if` 指令实现同样的功能：
            ```html
            <h1 v-if="ok">Yes</h1>
            <h1 v-else>No</h1>
            ```
    2. [在\<template\>元素上使用v-if条件渲染分组](#)
        - 因为v-if是一个指令，所以必须将它添加到一个元素上。
        - 但是如果想切换多个元素呢？此时可以把 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素
            ```html
            <template v-if="ok">
              <h1>Title</h1>
              <p>Paragraph 1</p>
              <p>Paragraph 2</p>
            </template>
            ```
    3. [v-else](#)
        - 你可以使用 `v-else` 指令来表示 `v-if` 的 “else块”
        - v-else 元素必须紧跟在 v-if 或 v-else-if 的元素后面，否则它将不会被识别
    4. [v-else-if](#)
        - Vue@2.10 版本新增加
        - `v-else-if` 顾名思义，充当 v-if 的 “else-if 块”，可以连续使用
        - 类似于 v-else，v-else-if 也必须紧跟在 v-if 或 v-else-if元素之后，否则不被识别
            ```html
            <div v-if="type === 'A'">
              A
            </div>
            <div v-else-if="type === 'B'">
              B
            </div>
            <div v-else-if="type === 'C'">
              C
            </div>
            <div v-else>
              Not A/B/C
            </div>
            ```
    5. [用key管理可复用元素](#)
        - 注意：
        - Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：
        ```html
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username">
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address">
        </template>
        ```
        - 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 placeholder。
        - 但是，这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：
        ```html
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username" key="username-input">
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address" key="email-input">
        </template>
        ```
        - 注意，`<label>` 元素仍然会被高效地复用，因为它们没有添加 key 属性。
- [v-show](#)
    1. [概要](#)
        - 另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样：`<h1 v-show="ok">Hello!</h1>`
        - 不同的是，带有 v-show 的元素始终会被渲染并保留在DOM中。v-show只是简单的切换元素的CSS属性：`display`
        - 注意：注意，v-show 不支持 \<template\> 元素，也不支持 v-else。
- [v-if 对比 v-show](#)
    1. [概要](#)
        - v-if，是真正的条件渲染，因为它会确保在切换的过程中，条件快内的事件监听器和子组件适当的被销毁和重建
        - v-if，也是惰性的，如果初始渲染条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块
        - 相比之下，v-show 就简单的多，不管初始条件是什么，元素总会被渲染，并且只是简单地基于 CSS 进行切换
        - 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁的切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好
- [v-if 和 v-for 一起使用](#)
    1. [概要](#)
        - 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级

### 列表渲染

- [用v-for把一个数组对应为一组元素](#)
    1. [概要](#)
        - 我们用 v-for 指令根据一组数组的选项列表进行渲染。
        - v-for 指令需要使用 `item in items` 形式的特殊语法，items 是源数据数组，item 是数组元素迭代的别名
        - 在 v-for 块中，我们拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引。
        - 你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法
            ```html
            <ul id="example-2">
              <li v-for="(item, index) in items">
                {{ parentMessage }} - {{ index }} - {{ item.message }}
              </li>
            </ul>
    
            <script>
            var example2 = new Vue({
              el: '#example-2',
              data: {
                parentMessage: 'Parent',
                items: [
                  { message: 'Foo' },
                  { message: 'Bar' }
                ]
              }
            })
            </script>
            ```
- [一个对象的v-for](#)
    1. [概要](#)
        - 也可以用 v-for 来迭代对象
        - 在遍历对象时，是按照 `Object.keys()` 的结果遍历，但是不能保证它的结果在不同的JS引擎下时一致的
            ```html
            <ul id="v-for-object" class="demo">
                <div v-for="(value, key, index) in object">
                  {{ index }}. {{ key }}: {{ value }}
                </div>
            </ul>

            <script>
            new Vue({
              el: '#v-for-object',
              data: {
                object: {
                  firstName: 'John',
                  lastName: 'Doe',
                  age: 30
                }
              }
            })
            </script>
            ```
- [key](#)
    1. [概要](#)
        - 当Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是简单的复用此处的每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似Vue 1.x 的 `track-by="$index"`
        - 这个默认的模式是搞效的，但是只适用**不依赖子组件状态或临时DOM状态（例如：表单输入值）的列表渲染输出**
        - 为了给Vue一个提示，以便它能追踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 `key` 属性。
        - 理想的 key 值是每项都有的且唯一的id。这个特殊的属性相当于Vue 1.x的 `track-by`，但它的工作方式类似于一个属性，所以你需要用 `v-bind` 来绑定动态值
        - 建议尽可能在使用 `v-for` 时提供 `key`，除非遍历输出的DOM内容非常简单，或者时刻意依赖默认行为以获取性能上的提升
        - 因为它是Vue识别节点的一个通用机制，key 并不与 v-for 特别关联，key还具有其他用途 ，我们将在后面的指南中看到其他用途
- [数组更新检测](#)
    1. [概要](#)
    2. [变异方法](#)
        - Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新，这些方法如下：
        - push()
        - pop()
        - shift()
        - unshift()
        - splice()
        - sort()
        - reverse()
        - 你可以打开控制台，然后用前面例子的 `items` 数组调用变异方法：`example.items.push({message: 'Baz'})`
    3. [替换数组](#)
        - **变异方法**（mutation method），顾名思义，会改变被这些方法调用的原始数组。
        - 相比之下，也有 **非变异方法**（non-mutating method）方法，例如：filter()，concat() 和 slice()。这些不会改变原始数组，但是总返回一个新的数组。
        - 但是用非变异方法时，可以用新数组替换旧数组：
            ```js
            example1.items = example1.items.filter(function (item) {
              return item.message.match(/Foo/)
            })

            ```
        - 你可能认为这将导致Vue丢弃现有DOM并重新渲染整个列表。幸运的是，事实并非如此。Vue为了使得DOM元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的。
    4. [注意事项](#)
        - **由于JS的限制，Vue不能检测以下变动的数组**：
            1. 当你利用索引直接设置一个项时，例如：`vm.items[indexOfItem] = newValue`
            2. 当你修改数组的长度时，例如：`vm.items.length = newLength`
        - 举个例子：
            ```js
            var vm = new Vue({
              data: {
                items: ['a', 'b', 'c']
              }
            })
            vm.items[1] = 'x' // 不是响应性的
            vm.items.length = 2 // 不是响应性的
            ```
        - 为了解决第一类问题，以下方式都可以达到要求，同时也将触发状态更新
            1. Vue.set(vm.items, indexOfItem, newValue)
            2. vm.$set(vm.items, indexOfItem, newValue)，vm.$set实例方法，是全局方法 Vue.set 的一个别名
            3. vm.items.splice(indexOfItem, 1, newValue)
        - 为了解决第二类问题，可以使用 `splice()`
            1. vm.items.splice(newLength)
- [对象更改检测注意事项](#)
    1. [概要](#)
        - **还是由于JS的限制，Vue不能检测对象属性的添加和删除**，（检测到修改，应该是可以的，待测试确定）
        - 例如：
            ```js
            var vm = new Vue({
              data: {
                a: 1
              }
            })
            // `vm.a` 现在是响应式的
            
            vm.b = 2
            // `vm.b` 不是响应式的
            ```
        - 对于已经创建的实例，Vue不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)` 方法向嵌套对象添加响应式属性。
        - 举个例子
            ```js
            var vm = new Vue({
              data: {
                userProfile: {
                  name: 'Anika'
                }
              }
            })

            // 添加一个新的 age 属性到嵌套的 userProfile 对象
            Vue.set(vm.userProfile, 'age', 27)

            // 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：
            vm.$set(vm.userProfile, 'age', 27)
            ```
        - 有时你可能需要为已有对象赋予多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新对象。
            ```js
            // 你不应该这样做
            Object.assign(vm.userProfile, {
              age: 27,
              favoriteColor: 'Vue Green'
            })
            
            
            // 你应该这样做：
            vm.userProfile = Object.assign({}, vm.userProfile, {
              age: 27,
              favoriteColor: 'Vue Green'
            })
            ```
- [显示过滤/排序结果](#)
    1. [概要](#)
        - 有时，我们想要显示一个数组的过滤或排序副本，而不是实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。
        - 在计算属性不适用的情况下（例如，在嵌套 `v-for` 循环中），你可以使用一个method方法
- [一段取值范围v-for](#)
    1. [概要](#)
        - v-for，也可以取整数。在这种情况下，它将重复多次模板。
            ```html
            <div>
              <span v-for="n in 10">{{ n }} </span>
            </div>

            <!-- 结果： -->
            <!-- 1 2 3 4 5 6 7 8 9 10 -->
            ```
- [v-for on a \<template\>](#)
    1. [概要](#)
        - 类似于 v-if，你也可以利用带有 v-for 的 `<template>` 渲染多个元素。比如：
            ```html
            <ul>
              <template v-for="item in items">
                <li>{{ item.msg }}</li>
                <li class="divider"></li>
              </template>
            </ul>
            ```
- [v-for with v-if](#)
    1. [概要](#)
        - 当它们处于同一个节点，v-for 的优先级比 v-if　更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：
            ```html
            <li v-for="todo in todos" v-if="!todo.isComplete">
              {{ todo }}
            </li>
            ```
        - 上面的代码只传递了未完成的 todos。而如果你的目的时有条件的跳过循环的执行，那么将 v-if 置于外层元素（或 `<template>`）上，如：
            ```html
            <ul v-if="todos.length">
              <li v-for="todo in todos">
                {{ todo }}
              </li>
            </ul>
            <p v-else>No todos left!</p>
            ```
- [一个组件的v-for](#)
    1. [概要](#)
        - 在自定义的组件里，你可以像任何普通元素一样用 v-for
            ```html
            <my-component v-for="item in items" :key="item.id"></my-component>
            ```
        - Vue 2.2.0+ 的版本里，当组件中使用 v-for 时， `key` 现在时必须的
        - 然而，任何数据不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 `props`
            ```html
            <my-component
              v-for="(item, index) in items"
              v-bind:item="item"
              v-bind:index="index"
              v-bind:key="item.id"
            ></my-component>
            ```
<!-- 
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
-->

### 事件处理

- [监听事件](#)
    1. [概要](#)
        - 可以用 v-on 指令监听DOM事件，并在触发时运行一些JavaScript代码
            ```html
            <div id="example-1">
              <button v-on:click="counter += 1">Add 1</button>
              <p>The button above has been clicked {{ counter }} times.</p>
            </div>

            <script>
            var example1 = new Vue({
              el: '#example-1',
              data: {
                counter: 0
              }
            })
            </script>
            ```
- [事件处理方法](#)
    1. [概要](#)
        - 许多事件处理逻辑会比较复杂，所以直接把JS代码写在v-on指令中时不可行的。因此 v-on 还可以接受一个需要调用的方法名称。
            ```html
            <div id="example-2">
              <!-- `greet` 是在下面定义的方法名 -->
              <button v-on:click="greet">Greet</button>
            </div>

            <script>
            var example2 = new Vue({
              el: '#example-2',
              data: {
                name: 'Vue.js'
              },
              // 在 `methods` 对象中定义方法
              methods: {
                greet: function (event) {
                  // `this` 在方法里指向当前 Vue 实例
                  alert('Hello ' + this.name + '!')
                  // `event` 是原生 DOM 事件
                  if (event) {
                    alert(event.target.tagName)
                  }
                }
              }
            })
            
            // 也可以用 JavaScript 直接调用方法
            example2.greet() // => 'Hello Vue.js!'
            </script>
            ```
- [内联处理器中的方法](#)
    1. [概要](#)
        - 除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法：
            ```html
            <div id="example-3">
              <button v-on:click="say('hi')">Say hi</button>
              <button v-on:click="say('what')">Say what</button>
            </div>

            <script>
            new Vue({
              el: '#example-3',
              methods: {
                say: function (message) {
                  alert(message)
                }
              }
            })
            </script>
            ```
        - 有时候也需要在内联语句处理器中访问原始DOM事件。可以用特殊变量 `$event` 把它传入方法：
            ```html
            <button v-on:click="warn('Form cannot be submitted yet.', $event)">
              Submit
            </button>
            
            <script>
            // ...
            methods: {
              warn: function (message, event) {
                // 现在我们可以访问原生事件对象
                if (event) event.preventDefault()
                alert(message)
              }
            }
            </script>
            ```
- [事件修饰符](#)
    1. [概要](#)
        - 在事件处理程序中调用 `event.preventDefault()` 和 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只是纯粹的数据逻辑，而不是去处理DOM事件细节。
        - 为了解决这个问题，Vue 为v-on提供了**事件修饰符**，修饰符是由点开头的指令后缀来表示的。
- [按键修饰符](#)
    1. [概要](#)
    2. [自动匹配按键修饰符](#)
- [系统修饰符](#)
    1. [概要](#)
    2. [.exact修饰符](#)
    3. [鼠标按钮修饰符](#)
- [为什么在HTML中监听事件？](#)

### 表单输入绑定

- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)

### 组件基础

- [基本示例](#)
    1. [概要](#)
        - 这里有一个Vue组件的实例：
            ```js
            // 定义一个名为 button-counter 的新组件
            Vue.component('button-counter', {
              data: function () {
                return {
                  count: 0
                }
              },
              template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
            })
            ```
        - 组件是可复用的Vue实例，且带有一个名字：在这个例子中 `<button-conter>`。我们可以在一个通过`new Vue`创建的Vue根实例中，把这个组件作为自定义元素来使用：
            ```html
            <div id="components-demo">
              <button-counter></button-counter>
            </div>

            <script>
            new Vue({ el: '#components-demo' })
            </script>
            ```
        - **因为组件是可复用的Vue实例**，所以它们与 `new Vue` 接受相同的选项，例如 `data`、`computed`、`watch`、`methods`以及生命周期钩子等。仅有的例外是像 `el` 这样的根实例特有的选项。
- [组件的复用](#)
    1. [概要](#)
        - 你可以将组件进行任意次数的复用
        - 每用一次组件，就会有一个它的新实例被创建
            ```html
            <div id="components-demo">
              <button-counter></button-counter>
              <button-counter></button-counter>
              <button-counter></button-counter>
            </div>
            ```
    2. [data 必须是一个函数](#)
        - 当我们定义这个 `<button-counter>` 组件时，你可能发现它的 `data` 并不是直接提供一个对象
        - 取而代之的，**一个组件的 data 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立拷贝。
        - 这样可以避免组件多次复用时，造成data数据组件间共享，这样是我们不期望的
- [组件的组织](#)
    1. [概要](#)
        - 通常一个应用会以一颗嵌套的组件树的形式来组织，方便组件化开发
        - 例如，你可能会有页头、侧边栏、内容区等组件，没有组件又包含了其它的像导航链接、博文之类的组件
        - 为了能在模板中使用，这些组件必须先注册以使Vue能够识别。
        - 这里有两种组件的注册类型：**全局注册** 和 **局部注册**。
        - 目前，通过`Vue.component`方式是全局注册，全局注册的组件可以用在新创建的Vue根实例，也包括其组件树中的所有子组件的模板中。
- [通过Prop向子组件传递数据](#)
    1. [概要](#)
        - Prop 是你可以在组件上注册的一些自定义特性。
        - 当一个值传递给一个prop特性的时候，它就变成了那个组件实例的一个属性。
        - 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。
            ```js
            Vue.component('blog-post', {
              props: ['title'],
              template: '<h3>{{ title }}</h3>'
            })

            new Vue({
              el: '#blog-post-demo',
              data: {
                posts: [
                  { id: 1, title: 'My journey with Vue' },
                  { id: 2, title: 'Blogging with Vue' },
                  { id: 3, title: 'Why Vue is so fun' },
                ]
              }
            })
            ```
            ```html
            <blog-post title="My journey with Vue"></blog-post>
            <blog-post title="Blogging with Vue"></blog-post>
            <blog-post title="Why Vue is so fun"></blog-post>

            <blog-post
              v-for="post in posts"
              v-bind:key="post.id"
              v-bind:title="post.title"
            ></blog-post>
            ```
- [单个根元素](#)
    1. [概要](#)
        - 当构建一个`<blog-post>`组件时，你的模板最终包含的东西远不止一个标题，可能还有正文
            ```html
            <h3>{{ post.title }}</h3>
            <div v-html="post.content"></div>
            ```
        - 然而如果你在组件模板（component.template）直接这么写，Vue会提示一个错误，**每个组件必须只有一个根元素**，你可以将模板的内容包裹在一个父元素内
            ```html
            <div class="blog-post">
              <h3>{{ post.title }}</h3>
              <div v-html="post.content"></div>
            </div>
            ```
- [通过事件向父级组件发送消息](#)
    1. [概要](#)
        - 详细暂略...
        - 主要通过在子组件使用 `$emit`，和在父组件使用 `v-on`，来控制
    2. [使用事件抛出一个值](#)
    3. [在组件上使用v-model](#)
        - 暂略，待整理...
- [通过插槽分发内容](#)
    1. [概要](#)
- [动态组件](#)
    1. [概要](#)
- [解析DOM模板时的注意事项](#)
    1. [概要](#)

## 深入了解组件

### 组件注册

- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)

### Prop

### 自定义事件

### 插槽

### 动态组件 & 异步组件

### 处理边界情况

## 过渡 & 动画

### 进入/离开 & 列表过渡

### 状态过渡

## 可复用性 & 组合

### 混入

### 自定义指令

### 渲染函数 & JSX

### 插件

### 过滤器

## 工具

### 生产环境部署

### 单文件组件

### 单元测试

### TypeScript支持

## 规模化

### 路由

### 状态管理

### 服务端渲染

## 内在

### 深入响应式原理

## 迁移

### 从Vue 1.x迁移

### 从Vue Router 0.7.x迁移

### 从Vue 0.6.x迁移到1.0