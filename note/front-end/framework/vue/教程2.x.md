<!-- TOC -->

- [教程](#教程)
    - [基础](#基础)
        - [安装](#安装)
        - [介绍](#介绍)
        - [Vue实例](#vue实例)
        - [模版语法](#模版语法)
        - [计算属性和侦听器](#计算属性和侦听器)
        - [Class 与 Style 绑定](#class-与-style-绑定)
        - [条件渲染](#条件渲染)
        - [列表渲染](#列表渲染)
        - [事件处理](#事件处理)
        - [表单输入绑定](#表单输入绑定)
        - [组件基础](#组件基础)
    - [深入了解组件](#深入了解组件)
        - [组件注册](#组件注册)
        - [Prop](#prop)
        - [自定义事件](#自定义事件)
        - [插槽](#插槽)
        - [动态组件 & 异步组件](#动态组件--异步组件)
        - [处理边界情况](#处理边界情况)
    - [过渡 & 动画](#过渡--动画)
        - [进入/离开 & 列表过渡](#进入离开--列表过渡)
        - [状态过渡](#状态过渡)
    - [可复用性 & 组合](#可复用性--组合)
        - [混入](#混入)
        - [自定义指令](#自定义指令)
        - [渲染函数 & JSX](#渲染函数--jsx)
        - [插件](#插件)
        - [过滤器](#过滤器)
    - [工具](#工具)
        - [生产环境部署](#生产环境部署)
        - [单文件组件](#单文件组件)
        - [单元测试](#单元测试)
        - [TypeScript支持](#typescript支持)
    - [规模化](#规模化)
        - [路由](#路由)
        - [状态管理](#状态管理)
        - [服务端渲染](#服务端渲染)
    - [内在](#内在)
        - [深入响应式原理](#深入响应式原理)
    - [迁移](#迁移)
        - [从Vue 1.x迁移](#从vue-1x迁移)
        - [从Vue Router 0.7.x迁移](#从vue-router-07x迁移)
        - [从Vue 0.6.x迁移到1.0](#从vue-06x迁移到10)

<!-- /TOC -->

# 教程

## 基础

### 安装

记录于2018-03-29：
- [地址](https://cn.vuejs.org/v2/guide/installation.html)
- **兼容性**
    - Vue不支持IE8及以下的版本，因为Vue使用了IE8无法模拟ECMAScript5特性。但它支持所有[兼容es6的浏览器](https://caniuse.com/#feat=es5)
- **更新日志**
    - 当前稳定版本：2.5.16，每个版本的更新日志见GitHub
- vue引入
    - 直接文件下载
    - CDN引入
- NPM
- 命令行工具（CLI）
- 对不同构建版本的解释
    - 术语
    - 运行时+编译器VS只包含运行时
    - 开发环境vs生成环境模式
    - csp环境
- 开发版本
- Bower
- AMD模块加载器 

### 介绍

- `Vue.js是什么`
    - Vue是一套用户构建用户界面的渐近式框架。与其它大型框架不同的是，vue被设计为可以自底向上逐层应用。vue的核心库只关注视图层，不仅容易上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，vue也完全能够为复杂的单页面应用提供驱动。
- `起步`
- `声明式渲染`
    - vue的核心是一个允许采用简洁的模版语法来声明式地将数据渲染进DOM的系统。
    - 在html的`<script>`部分使用`new Vue()`对象，可以将vue实例对象的数据绑定元素的属性值、文本值等
    - `{{  }}`、`v-bind`
    - 指令带有前缀 `v-`，以表示它们是vue提供的特殊特性。它们会在渲染的DOM上应用特殊的响应式行为。 
- `条件与循环`
    - `v-if`，可以控制元素是否显示，表示vue不仅可以把数据绑定到DOM**文本或属性**，还可以绑定控制DOM**结构**。
    - 还有其它很多指令，每个都有特殊功能。例如，`v-for`指令可以绑定数组的数据来渲染一个项目列表。
- `处理用户输入`
    - 为了让用户和应用进行交互，我们可以用 `v-on` 指令添加一个事件监听器，通过它调用在Vue实例中定义的方法。
    - vue还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。
- `组件化应用构建`
    - 组件系统是Vue的另一个重要概念。因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树。
    - 在Vue里，一个组件本质上是一个拥有预定义选项的Vue实例。
    - 使用组件时，子单元可以通过 `prop` 接口与父单元进行良好的解耦。
    - 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。
    ```html
    <div id='app'>
        <app-nav></app-nav>
        <app-view>
            <app-sidebar></app-sidebar>
            <app-content></app-content>
        </app-view>
    </div>
    ```
    - `自定义元素的关系`
        - Vue组件的做法非常类似自定义元素————它是Web组件规范的一部分，这是因为Vue组件语法部分参考了该规范。同时也有一些差别。
- 准备好了吗

问题：
1. 什么是渐近式框架？
2. 什么是自底向上设计？


```js
new Vue({
    el: '#app-6',
    data: {
        message: 'Hello World!'
    },
    methods: {
        reverseMessage: function () {}
    }
});
```

### Vue实例

- `创建一个Vue实例`
    - 每个Vue应用都是通过 `Vue` 构造函数创建一个新的Vue实例开始的：
        ```js
        var vm = new Vue({
            // 选项
        });
        ```
    - 虽然没有完全遵循 `MVVM` 模型，但是Vue的设计也受到了它的启发，因此在文档中经常使用vm（ViewModel的缩写）这个变量表示Vue实例。
    - 当创建一个Vue实例时，也可以传一个**选项对象**，即参数。使用该选项对象可以创建你想要的行为。
    - 一个Vue应用由一个通过 `new Vue` 创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成。详细会在组件系统章节中展开，此处仅需明白所有的**Vue组件都是Vue实例**，并且接受相同的选项对象。 
- `数据与方法`
    - 当一个Vue实例被创建时，**它向Vue的响应式系统中加入了其 `data` 对象中能找到的所有属性**。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。
        ```js
        var data = {a: 1};
        var vm = new Vue({
            data: data
        });

        vm.a == data.a; // true

        // 给vm.a或data.a赋值，都会相互同步
        vm.a = 2;
        data.a // => 2

        data.a = 3;
        vm.a // => 3
        ```
    - 当这些数据改变时，视图自动进行重渲染。
    - 值得注意的，只有当实例 `data` 中存在的属性才是**响应式**的。比如，你新添加一个属性，`vm.b = 1`，那么对于b后续的改动不会触发任何视图更新，也就是说如果想要数据有效，必须事先在 `data` 对象中预设。同时，如果`data`对象使用了`Object.freeze()`，这会阻止修改现有的属性，也意味着响应系统无法追踪变化。
    - 除了数据属性，Vue实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。例如：
        ```js
        var data = {a: 1};
        var vm = new Vue({
            el: '#example',
            data: data
        });

        vm.a === data.a; // true
        vm.$data === data; // true
        vm.$el === document.getElementById('example'); // true
        
        // vm 实例方法
        vm.$watch('a', function(newValue, oldValue) {
            // 这个回调将在vm.a改变后调用
        }); 
        ```
    - vm实例完整的实例属性和方法可参考API
- `实例生命周期钩子`
    - 每个Vue实例，在被创建时都要经过一系列的初始化过程，例如，需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同的阶段添加自己代码的机会。
    - 生命周期钩子的 `this` 上下文指向调用它的Vue实例。
    - > 不要在选项属性或回调上使用**箭头函数**，比如 `created: () => {}` 或 `vm.$watch('a', () => {})`。因为箭头函数是和父级上下文绑定在一起的，箭头函数里面的`this`不会是如你所预期的Vue实例。所以会经常报错。
- `生命周期图示`
    - 下图展示了实例的生命周期。
        ![](../../../../assets/vue_vm_lifecycle.png)

### 模版语法

- `其它`
    - Vue使用了基于HTMl的模版语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。所有Vue的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。
    - 在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数见到最少。
    - 如果你熟悉虚拟DOM并且偏爱JS的原始力量，你也可以不使用模板，直接写渲染（render）函数，使用可选的JSX语法。
- `插值`
    - `文本`
        - 数据绑定最常见的形式就是使用“Mustache”语法（双大括号）的文本插值：`<span>Message: {{ msg }}</span>`，Mustache标签将会替代为对应数据对象vm.$data上`msg`属性的值。无论何时，绑定的数据对象上`msg`属性发生了变化，插值处的内容都会更新。
        - 通过使用 `v-once 指令`，可以执行一次性的插值，当数据改变时，插值处的内容不会更新。`<span v-once>这个将不会改变： {{ msg }}</span>`。
    - `原始HTML`
        - Mustache双大括号会将数据解释为普通文本，而非HTML代码。为了输出真正的HTML，需要使用 `v-html` 指令。
        - > 注意，站点上动态渲染任意的HTML可能会比较危险，因为它很容易导致XSS攻击。请只对可信的内容使用HTML插值，不要对用户提供的内容使用插值。
    - `特性`
        - 注意Mustache语法不能用在HTMl特性/属性上，遇到这种情况应该使用 `v-bind 指令`：`<div v-bind:id="dynamicId"></div>`
    - `使用JavaScript表达式`
        - 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。**但实际上对于所有的数据绑定，Vue都提供了完全的JS表达式支持**。
            ```js
            {{ number + 1 }}

            {{ ok ? 'Yes' : 'No' }}

            {{ messsage.split('').reverse().join('') }}
            ```
        - 这些表达式会在所属Vue实例的数据作用域下作为JS被解析。有个**限制就是**，每个绑定都只能包含**单个表达式**，所以下面的例子都不会生效。
            ```js
            // 这是语句，不是表达式
            {{ var a = 1 }}

            // 控制流也不会生效，请使用三元表达式
            if(ok) { return message } 
            ```
        - 模版表达式都被放到沙盒中，只能访问全局变量的一个白名单，如Math和Date。你不应该在模板表达式中试图访问用户定义的全局变量。
- `指令`
    - `其它`
        - 指令（Directives）是带有 `v-` 前缀的特殊特性。指令特性的值预期是**单个JavaScript表达式**（v-for 是例外）。
        - 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM。
        - 例如：`<p v-if="seen">现在你看到我了</p>`
    - `参数`
        - 一些指令能够接受一个“参数”，在指令名称之后以冒号表示。例如，`v-bind`和`v-on`指令
        - `v<a v-bind:href="url">...</a>`，这里的href是参数，告诉v-bind指令，将该元素的href特性与表达式url的值绑定
        - `<a v-on:click="doSomething">...</a>`，这里的参数是监听的事件名
    - `修饰符`
        - 修饰符Modifiers是以半角句号 `.` 指明的特俗后缀，用于指定一个指令应该以特殊方式绑定。例如 `.prevent` 修饰符告诉 v-on 指令对于触发的事件调用 `event.preventDefault()`
            ```html
            <form v-on:submit.prevent="onSubmit">...</form>
            ```
- `缩写`
    - “v-” 指令，可以有缩写，例如
        ```html
        <!-- 完整语法 -->
        <a v-bind:href="url">...</a>
        
        <!-- 缩写 -->
        <a :href="url">...</a>

        <!-- 完整语法 -->
        <a v-on:click="doSomething">...</a>
        
        <!-- 缩写 -->
        <a @click="doSomething">...</a>
        ```

### 计算属性和侦听器

- [计算属性](#)
    1. [概要](#)
        - 模板内的表达式非常便利，但是设计它们初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重并难以维护。例如：
            ```html
            <div id="example">
              {{ message.split('').reverse().join('') }}
            </div>
            ```
        - 在此例子中，模板中逻辑可读性不高，必须看一段时间后才能意识到。所以对于，复杂的逻辑，应该使用**计算属性**
    2. [基础例子](#)
        ```html
            <div id="example">
              <p>Original message: "{{ message }}"</p>
              <p>Computed reversed message: "{{ reversedMessage }}"</p>
            </div>
        ```
        ```javascript
            var vm = new Vue({
              el: '#example',
              data: {
                message: 'Hello'
              },
              computed: {
                // 计算属性的 getter
                reversedMessage: function () {
                  // `this` 指向 vm 实例
                  return this.message.split('').reverse().join('')
                }
              }
            })
        ```
        - 这里我们声明了一个计算属性 `reverseMessage`，我们提供的computed函数将用作属性 `vm.reverseMessage` 的 getter 函数。
    3. [计算属性缓存VS方法](#)
        ```html
        <p>Reversed message: "{{ reversedMessage() }}"</p>
        ```
        ```js
        // 在组件中
        methods: {
          reversedMessage: function () {
            return this.message.split('').reverse().join('')
          }
        }
        ```
        - 你可能已经注意到，我们可以在模板中直接 调用方法 来达到同样的效果，但是也要注意区别
        - **计算属性是基于它们的依赖进行缓存的。计算属性 只有在它的相关依赖发生改变时才会重新求值**。这就意味着，只要 `message` 还没有发生改变，多次访问 `reverseMessage` 计算属性会立即返回之前的计算结果，而不会再次执行函数。
        - 这同样意味着下面例子的计算属性将不再更新，因为 `Date.now()` 没有依赖：
            ```js
            computed: {
              now: function () {
                return Date.now()
              }
            }
            ```
        - 相比，每当触发重新渲染时，**调用方法** 将总会再次执行函数。
        - 针对不同的应用场景，来选择使用 “计算属性缓存” 或 “调用方法”
            1. 对于存在依赖属性，并且计算量大的、需要缓存的场景，可以使用 “计算属性”
            2. 如果明确不希望有缓存，使用 “调用方法”
    4. [计算属性 VS 侦听属性](#)
        - Vue 提供了一种更通用的方式来观察和响应Vue实例上的数据变动：**侦听属性**
        - 当你有一些数据需要随着其他数据的变动而变动时，你很容易滥用 `watch`。然而，通常更好的做法是使用计算属性，而不是命令式的 `watch` 回调。
        - 细想一下下面的例子：
            ```html
            <div id="demo">{{ fullName }}</div>
            ```
            ```js
            // watch 方式
            var vm = new Vue({
             el: '#demo',
             data: {
               firstName: 'Foo',
               lastName: 'Bar',
               fullName: 'Foo Bar'
             },
             watch: {
               firstName: function (val) {
                 this.fullName = val + ' ' + this.lastName
               },
               lastName: function (val) {
                 this.fullName = this.firstName + ' ' + val
               }
             }
            })
            ```
            ```js
            // 计算属性方式
            var vm = new Vue({
              el: '#demo',
              data: {
                firstName: 'Foo',
                lastName: 'Bar'
              },
              computed: {
                fullName: function () {
                  return this.firstName + ' ' + this.lastName
                }
              }
            })
            ```
        - 由上面例子，可以看到 “计算属性” 的写法更加精简，美观
    5. [计算属性的 setter](#)
        - 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：
            ```js
            computed: {
              fullName: {
                // getter
                get: function () {
                  return this.firstName + ' ' + this.lastName
                },
                // setter
                set: function (newValue) {
                  var names = newValue.split(' ')
                  this.firstName = names[0]
                  this.lastName = names[names.length - 1]
                }
              }
            }
            ```
        - 现在运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应的被更新。
- [侦听器](#)
    1. [概要](#)
        - 虽然计算属性在大多数情况下更合适，但是有时也需要一个自定义的侦听器。这就是为什么Vue通过 watch 选项提供一个更通用的方法，来响应数据变化。
        - 当需要在数据变化时执行 **异步** 或 **开销较大** 的操作时，这个方法时最有用的。

### Class 与 Style 绑定

- [概要](#)
    1. [概要](#)
        - 操作元素的class和内联样式是数据绑定的常见需求。因为它们都是属性，所以可以用 `v-bind` 处理它们，只需要通过表达式计算出字符串结果即可。
        - 不过，字符串拼接麻烦且易错，因此, v-bind 用于 class 和 style 时，Vue做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组
- [绑定HTML class](#)
    1. [对象语法](#)
        - 对象的属性为类名，属性值的true和false，来控制是否该类名开关
        ```html
        <div class="static"
             v-bind:class="{ active: isActive, 'text-danger': hasError}">
        </div>

        <script>
        data: {
          isActive: true,
          hasError: false
        }
        </script>
        ```
        ```html
        <div v-bind:class="classObject"></div>

        <script>
        data: {
          classObject: {
            active: true,
            'text-danger': false
          }
        }
        </script>
        ```
        ```html
        <div v-bind:class="classObject"></div>

        <script>
        data: {
          isActive: true,
          error: null
        },
        computed: {
          classObject: function () {
            return {
              active: this.isActive && !this.error,
              'text-danger': this.error && this.error.type === 'fatal'
            }
          }
        }
        </script>
        ```
    2. [数组语法](#)
        ```html
        <div v-bind:class="[activeClass, errorClass]"></div>

        <!-- 或 -->
        <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
        
        <!-- 或 -->
        <div v-bind:class="[{ active: isActive }, errorClass]"></div>

        
        <script>
        data: {
          activeClass: 'active',
          errorClass: 'text-danger',
          
          isActive:　true
        }
        </script>
        ```
    3. [用在组件上](#)
        - 当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素已存在的类不会被覆盖。
        - 例如，如果你声明了组件：`Vue.component('my-component', {template: '<p class="foo bar">Hi</p>'})`
        - 然后使用时添加一些class：`<my-component class="baz boo"></my-component>`
        - 最后html将被渲染为：`<p class="foo bar baz boo">Hi</p>`
        - 对于带数据绑定class也同样适用：`<my-component v-bind:class="{ active: isActive }"></my-component>`
- [绑定内联样式](#)
    1. [对象语法](#)
        - `v-bind:style` 的对象语法十分直观，看着非常像CSS，但其实是一个JS对象。
        - CSS属性名可以用 驼峰式或短横线 分隔来命名
        - 同样的，对象语法常常结合返回对象的计算属性使用
        ```html
        <div v-bind:style="styleObject"></div>

        <script>
        data: {
          styleObject: {
            color: 'red',
            fontSize: '13px'
          }
        }
        </script>
        ```
    2. [数组语法](#)
        - `v-bind:style` 的数组语法可以将多个样式对象，应用到同一个元素上
        ```html
        <div v-bind:style="[baseStyles, overridingStyles]"></div>
        ```
    3. [自动添加前缀](#)
        - 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。
    4. [多重值](#)
        - 从 Vue@2.3.0 版本起，可以为 style 绑定的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：
        - `<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>`
        - 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。

### 条件渲染

- [v-if](#)
    1. [概要](#)
        - 在字符串模板中，比如[handlebars库](http://handlebarsjs.com/)，我们得像这样写一个条件块：
            ```html
            <!-- Handlebars 模板 -->
            {{#if ok}}
              <h1>Yes</h1>
            {{/if}}
            ```
        - 在Vue中，我们使用 `v-if` 指令实现同样的功能：
            ```html
            <h1 v-if="ok">Yes</h1>
            <h1 v-else>No</h1>
            ```
    2. [在\<template\>元素上使用v-if条件渲染分组](#)
        - 因为v-if是一个指令，所以必须将它添加到一个元素上。
        - 但是如果想切换多个元素呢？此时可以把 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素
            ```html
            <template v-if="ok">
              <h1>Title</h1>
              <p>Paragraph 1</p>
              <p>Paragraph 2</p>
            </template>
            ```
    3. [v-else](#)
        - 你可以使用 `v-else` 指令来表示 `v-if` 的 “else块”
        - v-else 元素必须紧跟在 v-if 或 v-else-if 的元素后面，否则它将不会被识别
    4. [v-else-if](#)
        - Vue@2.10 版本新增加
        - `v-else-if` 顾名思义，充当 v-if 的 “else-if 块”，可以连续使用
        - 类似于 v-else，v-else-if 也必须紧跟在 v-if 或 v-else-if元素之后，否则不被识别
            ```html
            <div v-if="type === 'A'">
              A
            </div>
            <div v-else-if="type === 'B'">
              B
            </div>
            <div v-else-if="type === 'C'">
              C
            </div>
            <div v-else>
              Not A/B/C
            </div>
            ```
    5. [用key管理可复用元素](#)
        - 注意：
        - Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：
        ```html
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username">
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address">
        </template>
        ```
        - 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 placeholder。
        - 但是，这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：
        ```html
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username" key="username-input">
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address" key="email-input">
        </template>
        ```
        - 注意，`<label>` 元素仍然会被高效地复用，因为它们没有添加 key 属性。
- [v-show](#)
    1. [概要](#)
        - 另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样：`<h1 v-show="ok">Hello!</h1>`
        - 不同的是，带有 v-show 的元素始终会被渲染并保留在DOM中。v-show只是简单的切换元素的CSS属性：`display`
        - 注意：注意，v-show 不支持 \<template\> 元素，也不支持 v-else。
- [v-if 对比 v-show](#)
    1. [概要](#)
        - v-if，是真正的条件渲染，因为它会确保在切换的过程中，条件快内的事件监听器和子组件适当的被销毁和重建
        - v-if，也是惰性的，如果初始渲染条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块
        - 相比之下，v-show 就简单的多，不管初始条件是什么，元素总会被渲染，并且只是简单地基于 CSS 进行切换
        - 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁的切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好
- [v-if 和 v-for 一起使用](#)
    1. [概要](#)
        - 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级

### 列表渲染

- [用v-for把一个数组对应为一组元素](#)
    1. [概要](#)
        - 我们用 v-for 指令根据一组数组的选项列表进行渲染。
        - v-for 指令需要使用 `item in items` 形式的特殊语法，items 是源数据数组，item 是数组元素迭代的别名
        - 在 v-for 块中，我们拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引。
        - 你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法
            ```html
            <ul id="example-2">
              <li v-for="(item, index) in items">
                {{ parentMessage }} - {{ index }} - {{ item.message }}
              </li>
            </ul>
    
            <script>
            var example2 = new Vue({
              el: '#example-2',
              data: {
                parentMessage: 'Parent',
                items: [
                  { message: 'Foo' },
                  { message: 'Bar' }
                ]
              }
            })
            </script>
            ```
- [一个对象的v-for](#)
    1. [概要](#)
        - 也可以用 v-for 来迭代对象
        - 在遍历对象时，是按照 `Object.keys()` 的结果遍历，但是不能保证它的结果在不同的JS引擎下时一致的
            ```html
            <ul id="v-for-object" class="demo">
                <div v-for="(value, key, index) in object">
                  {{ index }}. {{ key }}: {{ value }}
                </div>
            </ul>

            <script>
            new Vue({
              el: '#v-for-object',
              data: {
                object: {
                  firstName: 'John',
                  lastName: 'Doe',
                  age: 30
                }
              }
            })
            </script>
            ```
- [key](#)
    1. [概要](#)
        - 当Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是简单的复用此处的每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似Vue 1.x 的 `track-by="$index"`
        - 这个默认的模式是搞效的，但是只适用**不依赖子组件状态或临时DOM状态（例如：表单输入值）的列表渲染输出**
        - 为了给Vue一个提示，以便它能追踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 `key` 属性。
        - 理想的 key 值是每项都有的且唯一的id。这个特殊的属性相当于Vue 1.x的 `track-by`，但它的工作方式类似于一个属性，所以你需要用 `v-bind` 来绑定动态值
        - 建议尽可能在使用 `v-for` 时提供 `key`，除非遍历输出的DOM内容非常简单，或者时刻意依赖默认行为以获取性能上的提升
        - 因为它是Vue识别节点的一个通用机制，key 并不与 v-for 特别关联，key还具有其他用途 ，我们将在后面的指南中看到其他用途
- [数组更新检测](#)
    1. [概要](#)
    2. [变异方法](#)
        - Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新，这些方法如下：
        - push()
        - pop()
        - shift()
        - unshift()
        - splice()
        - sort()
        - reverse()
        - 你可以打开控制台，然后用前面例子的 `items` 数组调用变异方法：`example.items.push({message: 'Baz'})`
    3. [替换数组](#)
        - **变异方法**（mutation method），顾名思义，会改变被这些方法调用的原始数组。
        - 相比之下，也有 **非变异方法**（non-mutating method）方法，例如：filter()，concat() 和 slice()。这些不会改变原始数组，但是总返回一个新的数组。
        - 但是用非变异方法时，可以用新数组替换旧数组：
            ```js
            example1.items = example1.items.filter(function (item) {
              return item.message.match(/Foo/)
            })

            ```
        - 你可能认为这将导致Vue丢弃现有DOM并重新渲染整个列表。幸运的是，事实并非如此。Vue为了使得DOM元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的。
    4. [注意事项](#)
        - **由于JS的限制，Vue不能检测以下变动的数组**：
            1. 当你利用索引直接设置一个项时，例如：`vm.items[indexOfItem] = newValue`
            2. 当你修改数组的长度时，例如：`vm.items.length = newLength`
        - 举个例子：
            ```js
            var vm = new Vue({
              data: {
                items: ['a', 'b', 'c']
              }
            })
            vm.items[1] = 'x' // 不是响应性的
            vm.items.length = 2 // 不是响应性的
            ```
        - 为了解决第一类问题，以下方式都可以达到要求，同时也将触发状态更新
            1. Vue.set(vm.items, indexOfItem, newValue)
            2. vm.$set(vm.items, indexOfItem, newValue)，vm.$set实例方法，是全局方法 Vue.set 的一个别名
            3. vm.items.splice(indexOfItem, 1, newValue)
        - 为了解决第二类问题，可以使用 `splice()`
            1. vm.items.splice(newLength)
- [对象更改检测注意事项](#)
    1. [概要](#)
        - **还是由于JS的限制，Vue不能检测对象属性的添加和删除**，（检测到修改，应该是可以的，待测试确定）
        - 例如：
            ```js
            var vm = new Vue({
              data: {
                a: 1
              }
            })
            // `vm.a` 现在是响应式的
            
            vm.b = 2
            // `vm.b` 不是响应式的
            ```
        - 对于已经创建的实例，Vue不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)` 方法向嵌套对象添加响应式属性。
        - 举个例子
            ```js
            var vm = new Vue({
              data: {
                userProfile: {
                  name: 'Anika'
                }
              }
            })

            // 添加一个新的 age 属性到嵌套的 userProfile 对象
            Vue.set(vm.userProfile, 'age', 27)

            // 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：
            vm.$set(vm.userProfile, 'age', 27)
            ```
        - 有时你可能需要为已有对象赋予多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新对象。
            ```js
            // 你不应该这样做
            Object.assign(vm.userProfile, {
              age: 27,
              favoriteColor: 'Vue Green'
            })
            
            
            // 你应该这样做：
            vm.userProfile = Object.assign({}, vm.userProfile, {
              age: 27,
              favoriteColor: 'Vue Green'
            })
            ```
- [显示过滤/排序结果](#)
    1. [概要](#)
        - 有时，我们想要显示一个数组的过滤或排序副本，而不是实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。
        - 在计算属性不适用的情况下（例如，在嵌套 `v-for` 循环中），你可以使用一个method方法
- [一段取值范围v-for](#)
    1. [概要](#)
        - v-for，也可以取整数。在这种情况下，它将重复多次模板。
            ```html
            <div>
              <span v-for="n in 10">{{ n }} </span>
            </div>

            <!-- 结果： -->
            <!-- 1 2 3 4 5 6 7 8 9 10 -->
            ```
- [v-for on a \<template\>](#)
    1. [概要](#)
        - 类似于 v-if，你也可以利用带有 v-for 的 `<template>` 渲染多个元素。比如：
            ```html
            <ul>
              <template v-for="item in items">
                <li>{{ item.msg }}</li>
                <li class="divider"></li>
              </template>
            </ul>
            ```
- [v-for with v-if](#)
    1. [概要](#)
        - 当它们处于同一个节点，v-for 的优先级比 v-if　更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：
            ```html
            <li v-for="todo in todos" v-if="!todo.isComplete">
              {{ todo }}
            </li>
            ```
        - 上面的代码只传递了未完成的 todos。而如果你的目的时有条件的跳过循环的执行，那么将 v-if 置于外层元素（或 `<template>`）上，如：
            ```html
            <ul v-if="todos.length">
              <li v-for="todo in todos">
                {{ todo }}
              </li>
            </ul>
            <p v-else>No todos left!</p>
            ```
- [一个组件的v-for](#)
    1. [概要](#)
        - 在自定义的组件里，你可以像任何普通元素一样用 v-for
            ```html
            <my-component v-for="item in items" :key="item.id"></my-component>
            ```
        - Vue 2.2.0+ 的版本里，当组件中使用 v-for 时， `key` 现在时必须的
        - 然而，任何数据不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 `props`
            ```html
            <my-component
              v-for="(item, index) in items"
              v-bind:item="item"
              v-bind:index="index"
              v-bind:key="item.id"
            ></my-component>
            ```
<!-- 
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
-->

### 事件处理

- [监听事件](#)
    1. [概要](#)
        - 可以用 v-on 指令监听DOM事件，并在触发时运行一些JavaScript代码
            ```html
            <div id="example-1">
              <button v-on:click="counter += 1">Add 1</button>
              <p>The button above has been clicked {{ counter }} times.</p>
            </div>

            <script>
            var example1 = new Vue({
              el: '#example-1',
              data: {
                counter: 0
              }
            })
            </script>
            ```
- [事件处理方法](#)
    1. [概要](#)
        - 许多事件处理逻辑会比较复杂，所以直接把JS代码写在v-on指令中时不可行的。因此 v-on 还可以接受一个需要调用的方法名称。
            ```html
            <div id="example-2">
              <!-- `greet` 是在下面定义的方法名 -->
              <button v-on:click="greet">Greet</button>
            </div>

            <script>
            var example2 = new Vue({
              el: '#example-2',
              data: {
                name: 'Vue.js'
              },
              // 在 `methods` 对象中定义方法
              methods: {
                greet: function (event) {
                  // `this` 在方法里指向当前 Vue 实例
                  alert('Hello ' + this.name + '!')
                  // `event` 是原生 DOM 事件
                  if (event) {
                    alert(event.target.tagName)
                  }
                }
              }
            })
            
            // 也可以用 JavaScript 直接调用方法
            example2.greet() // => 'Hello Vue.js!'
            </script>
            ```
- [内联处理器中的方法](#)
    1. [概要](#)
        - 除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法：
            ```html
            <div id="example-3">
              <button v-on:click="say('hi')">Say hi</button>
              <button v-on:click="say('what')">Say what</button>
            </div>

            <script>
            new Vue({
              el: '#example-3',
              methods: {
                say: function (message) {
                  alert(message)
                }
              }
            })
            </script>
            ```
        - 有时候也需要在内联语句处理器中访问原始DOM事件。可以用特殊变量 `$event` 把它传入方法：
            ```html
            <button v-on:click="warn('Form cannot be submitted yet.', $event)">
              Submit
            </button>
            
            <script>
            // ...
            methods: {
              warn: function (message, event) {
                // 现在我们可以访问原生事件对象
                if (event) event.preventDefault()
                alert(message)
              }
            }
            </script>
            ```
- [事件修饰符](#)
    1. [概要](#)
        - 在事件处理程序中调用 `event.preventDefault()` 和 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只是纯粹的数据逻辑，而不是去处理DOM事件细节。
        - 为了解决这个问题，Vue 为v-on提供了**事件修饰符**，修饰符是由点开头的指令后缀来表示的。
            1. .stop
            2. .prevent
            3. .capture
            4. .self
            5. .once
            6. .passive
            ```html
            <!-- 阻止单击事件继续传播 -->
            <a v-on:click.stop="doThis"></a>
            
            <!-- 提交事件不再重载页面 -->
            <form v-on:submit.prevent="onSubmit"></form>
            
            <!-- 修饰符可以串联 -->
            <a v-on:click.stop.prevent="doThat"></a>
            
            <!-- 只有修饰符 -->
            <form v-on:submit.prevent></form>
            
            <!-- 添加事件监听器时使用事件捕获模式 -->
            <!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 -->
            <div v-on:click.capture="doThis">...</div>
            
            <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
            <!-- 即事件不是从内部元素触发的 -->
            <div v-on:click.self="doThat">...</div>
            ```
        - 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。比如，v-on:click.prevent.self 会阻止所有的点击事件，而 v-on:click.self.prevent 只会阻止对元素自身的点击
        - Vue@2.1.4 新增，
            - `<a v-on:click.once="doThis"></a>`，点击事件只会触发一次
            - 不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。
        - Vue@2.3.0新增
            - Vue还对应 `addEventListener()` 中的 `passive` 选项提供了 .passive 修饰符
            - 这个 .passive 修饰符尤其能够提供移动端的性能
            - 不要把 .passive 和 .prevent 一起使用，因为 .prevent 会被忽略，同时浏览器可能会给你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。
            ```html
            <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
            <!-- 而不会等待 `onScroll` 完成  -->
            <!-- 这其中包含 `event.preventDefault()` 的情况 -->
            <div v-on:scroll.passive="onScroll">...</div>
            ```
- [按键修饰符](#)
    1. [概要](#)
        - 在监听键盘事件时，我们经常需要检查常见的键值。Vue允许为 v-on 在监听键盘事件时添加按键修饰符。
        - 记住所有的 `keyCode` 比较困难，所以Vue为最为常见的按键提供了别名。
            ```html
            <!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` -->
            <input v-on:keyup.13="submit">

            <!-- 同上 -->
            <input v-on:keyup.enter="submit">
            
            <!-- 缩写语法 -->
            <input @keyup.enter="submit">
            ```
        - 全部的按键别名：
            1. .enter
            2. .tab
            3. .delete （捕获 “删除” 和 “退格” 键）
            4. .esc
            5. .space
            6. .up
            7. .down
            8. .left
            9. .right
        - 可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名，详细可见API
    2. [自动匹配按键修饰符](#)
        - @2.5.0 新增
        - 你可以直接将 keyboardEvent.key 暴露的任意有效键名转换为kebab-case来作为修饰符...待整理...
- [系统修饰符](#)
    1. [概要](#)
        - @2.1.0新增
        - 可以用如下修饰符来实现仅有在按下相应按键时才触发鼠标或键盘事件的监听器
            1. .ctrl
            2. .alt
            3. .shift
            4. .meta
            ```html
            <!-- Alt + C -->
            <input @keyup.alt.67="clear">
            
            <!-- Ctrl + Click -->
            <div @click.ctrl="doSomething">Do something</div>
            ```
        - 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。
    2. [.exact修饰符](#)
        - @2.5.0 新增
        - .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。
            ```html
            <!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
            <button @click.ctrl="onClick">A</button>
            
            <!-- 有且只有 Ctrl 被按下的时候才触发 -->
            <button @click.ctrl.exact="onCtrlClick">A</button>
            
            <!-- 没有任何系统修饰符被按下的时候才触发 -->
            <button @click.exact="onClick">A</button>
            ```
    3. [鼠标按钮修饰符](#)
        - @2.2.0 新增
        - 这些修饰符会限制处理函数仅响应特定的鼠标按钮。
            1. .left
            2. .right
            3. .middle
- [为什么在HTML中监听事件？](#)
    1. [概要](#)
        - 你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：
            1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
            2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。
            3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

### 表单输入绑定

- [基础用法](#)
    1. [概要](#)
        - 你可以用 `v-model` 指令在表单 `<input>` 及 `<textarea>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 
        - v-model 会忽略所有表单元素的 `value`、`checked`、`selected` 特性的初始值而总是将Vue实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值
        - 对于需要使用输入法的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用input事件
    2. [文本](#)
        ```html
        <input v-model="message" placeholder="edit me">
        <p>Message is: {{ message }}</p>
        ```
    3. [多行文本](#)
        ```html
        <span>Multiline message is:</span>
        <p style="white-space: pre-line;">{{ message }}</p>
        <br>
        <textarea v-model="message" placeholder="add multiple lines"></textarea>
        ```
    4. [复选框](#)
        - 单个复选框，绑定到布尔值
            ```html
            <input type="checkbox" id="checkbox" v-model="checked">
            <label for="checkbox">{{ checked }}</label>
            ```
        - 多个复选框，绑定到同一个数组
            ```html
            <div id='example-3'>
              <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
              <label for="jack">Jack</label>
              <input type="checkbox" id="john" value="John" v-model="checkedNames">
              <label for="john">John</label>
              <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
              <label for="mike">Mike</label>
              <br>
              <span>Checked names: {{ checkedNames }}</span>
            </div>

            <script>
                new Vue({
                  el: '#example-3',
                  data: {
                    checkedNames: []
                  }
                })
            </script>
            ```
    5. [单选按钮](#)
        ```html
        <div id="example-4">
          <input type="radio" id="one" value="One" v-model="picked">
          <label for="one">One</label>
          <br>
          <input type="radio" id="two" value="Two" v-model="picked">
          <label for="two">Two</label>
          <br>
          <span>Picked: {{ picked }}</span>
        </div>

        <script>
            new Vue({
              el: '#example-4',
              data: {
                picked: ''
              }
            })
        </script>
        ```
    6. [选择框](#)
        - 单选
        - 如果 v-model 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为 “未选中” 状态。在IOS中，这会使得用户无法选择第一个选项。因为这样的情况下，ios不会触发change事件。因此，更推荐像上面这样提供一个值为空的禁用选项。
            ```html
            <div id="example-5">
              <select v-model="selected">
                <option disabled value="">请选择</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
              </select>
              <span>Selected: {{ selected }}</span>
            </div>

            <script>
                new Vue({
                  el: '...',
                  data: {
                    selected: ''
                  }
                })
            </script>
            ```
        - 多选时，绑定到一个数组
            ```html
            <div id="example-6">
              <select v-model="selected" multiple style="width: 50px;">
                <option>A</option>
                <option>B</option>
                <option>C</option>
              </select>
              <br>
              <span>Selected: {{ selected }}</span>
            </div>

            <script>
                new Vue({
                  el: '#example-6',
                  data: {
                    selected: []
                  }
                })
            </script>
            ```
        - 用 `v-for` 渲染的动态选项
            ```html
            <select v-model="selected">
              <option v-for="option in options" v-bind:value="option.value">
                {{ option.text }}
              </option>
            </select>
            <span>Selected: {{ selected }}</span>

            <script>
                new Vue({
                  el: '...',
                  data: {
                    selected: 'A',
                    options: [
                      { text: 'One', value: 'A' },
                      { text: 'Two', value: 'B' },
                      { text: 'Three', value: 'C' }
                    ]
                  }
                })
            </script>
            ```
- [值绑定](#)
    1. [概要](#)
        ```html
        <!-- 当选中时，`picked` 为字符串 "a" -->
        <input type="radio" v-model="picked" value="a">
        
        <!-- `toggle` 为 true 或 false -->
        <input type="checkbox" v-model="toggle">
        
        <!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
        <select v-model="selected">
          <option value="abc">ABC</option>
        </select>
        ```
    2. [复选框](#)
    3. [单选按钮](#)
    4. [选择框的选项](#)
- [修饰符](#)
    1. [概要](#)
    2. [.lazy](#)
        - 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。
        - 你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：`<input v-model.lazy="msg" >`
    3. [.number](#)
        - 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符
        - 这通常很有用，因为即使在 type="number" 时，HTML 输入元素的值也总会返回字符串。
            ```html
            <input v-model.number="age" type="number">
            ```
    4. [.trim](#)
        - 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：`<input v-model.trim="msg">`
- [在组件上使用v-model](#)
    1. [概要](#)
        - HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 v-model 一起使用！要了解更多，请参阅组件指南中的 自定义输入组件。

### 组件基础

- [基本示例](#)
    1. [概要](#)
        - 这里有一个Vue组件的实例：
            ```js
            // 定义一个名为 button-counter 的新组件
            Vue.component('button-counter', {
              data: function () {
                return {
                  count: 0
                }
              },
              template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
            })
            ```
        - 组件是可复用的Vue实例，且带有一个名字：在这个例子中 `<button-conter>`。我们可以在一个通过`new Vue`创建的Vue根实例中，把这个组件作为自定义元素来使用：
            ```html
            <div id="components-demo">
              <button-counter></button-counter>
            </div>

            <script>
            new Vue({ el: '#components-demo' })
            </script>
            ```
        - **因为组件是可复用的Vue实例**，所以它们与 `new Vue` 接受相同的选项，例如 `data`、`computed`、`watch`、`methods`以及生命周期钩子等。仅有的例外是像 `el` 这样的根实例特有的选项。
- [组件的复用](#)
    1. [概要](#)
        - 你可以将组件进行任意次数的复用
        - 每用一次组件，就会有一个它的新实例被创建
            ```html
            <div id="components-demo">
              <button-counter></button-counter>
              <button-counter></button-counter>
              <button-counter></button-counter>
            </div>
            ```
    2. [data 必须是一个函数](#)
        - 当我们定义这个 `<button-counter>` 组件时，你可能发现它的 `data` 并不是直接提供一个对象
        - 取而代之的，**一个组件的 data 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立拷贝。
        - 这样可以避免组件多次复用时，造成data数据组件间共享，这样是我们不期望的
- [组件的组织](#)
    1. [概要](#)
        - 通常一个应用会以一颗嵌套的组件树的形式来组织，方便组件化开发
        - 例如，你可能会有页头、侧边栏、内容区等组件，没有组件又包含了其它的像导航链接、博文之类的组件
        - 为了能在模板中使用，这些组件必须先注册以使Vue能够识别。
        - 这里有两种组件的注册类型：**全局注册** 和 **局部注册**。
        - 目前，通过`Vue.component`方式是全局注册，全局注册的组件可以用在新创建的Vue根实例，也包括其组件树中的所有子组件的模板中。
- [通过Prop向子组件传递数据](#)
    1. [概要](#)
        - Prop 是你可以在组件上注册的一些自定义特性。
        - 当一个值传递给一个prop特性的时候，它就变成了那个组件实例的一个属性。
        - 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。
            ```js
            Vue.component('blog-post', {
              props: ['title'],
              template: '<h3>{{ title }}</h3>'
            })

            new Vue({
              el: '#blog-post-demo',
              data: {
                posts: [
                  { id: 1, title: 'My journey with Vue' },
                  { id: 2, title: 'Blogging with Vue' },
                  { id: 3, title: 'Why Vue is so fun' },
                ]
              }
            })
            ```
            ```html
            <blog-post title="My journey with Vue"></blog-post>
            <blog-post title="Blogging with Vue"></blog-post>
            <blog-post title="Why Vue is so fun"></blog-post>

            <blog-post
              v-for="post in posts"
              v-bind:key="post.id"
              v-bind:title="post.title"
            ></blog-post>
            ```
- [单个根元素](#)
    1. [概要](#)
        - 当构建一个`<blog-post>`组件时，你的模板最终包含的东西远不止一个标题，可能还有正文
            ```html
            <h3>{{ post.title }}</h3>
            <div v-html="post.content"></div>
            ```
        - 然而如果你在组件模板（component.template）直接这么写，Vue会提示一个错误，**每个组件必须只有一个根元素**，你可以将模板的内容包裹在一个父元素内
            ```html
            <div class="blog-post">
              <h3>{{ post.title }}</h3>
              <div v-html="post.content"></div>
            </div>
            ```
- [通过事件向父级组件发送消息](#)
    1. [概要](#)
        - 详细暂略...
        - 主要通过在子组件使用 `$emit`，和在父组件使用 `v-on`，来控制
    2. [使用事件抛出一个值](#)
    3. [在组件上使用v-model](#)
        - 暂略，待整理...
- [通过插槽分发内容](#)
    1. [概要](#)
- [动态组件](#)
    1. [概要](#)
- [解析DOM模板时的注意事项](#)
    1. [概要](#)

## 深入了解组件

### 组件注册

- [组件名](#)
    1. [概要](#)
        - `Vue.component()` 第一个参数就是组件名
        - 你给予组件的名字可能依赖于你打算拿它来做什么。当直接在DOM中使用一个组件的时候（而不是在字符串模板或单文件组件），我们强烈推荐遵循[w3c规范](https://www.w3.org/TR/custom-elements/#concepts)中的自定义组件名（**字母全小写，且必须包含一个连字符**）。这回帮助你避免和当前以及未来的HTML元素相冲突。
    2. [组件名大小写](#)
        - 定义组件名的方式有两种：
            1. 使用 kebab-case（短横线隔开）
                - `Vue.component('my-component-name', { /* ... */ })`
                - 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 `<my-component-name>`
            2. 使用 PascalCase（驼峰式）
                - `Vue.component('MyComponentName', { /* ... */ })`
                - 当使用 PascalCase (驼峰式命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 `<my-component-name>` 和 `<MyComponentName>` 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。
- [全局注册](#)
    1. [概要](#)
        - 使用 `Vue.component()` 注册的组件，是**全局注册**，也就是它们在注册之后可以用在任何新创建的Vue根实例的模板中。
- [局部注册](#)
    1. [概要](#)
        - 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。
        - 在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件，然后在 components 选项中定义你想要使用的组件：
            ```html
            <script>
                var ComponentA = { /* ... */ }
                var ComponentB = { /* ... */ }
                var ComponentC = { /* ... */ }

                new Vue({
                  el: '#app'
                  components: {
                    'component-a': ComponentA,
                    'component-b': ComponentB
                  }
                })
            </script>
            ```
        - 对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。
        - 注意局部注册的组件在其子组件中不可用
- [模块系统](#)
    1. [概要](#)
        - 如果你没有通过 import/require 使用一个模块系统，也许可以暂且跳过这个章节。如果你使用了，那么我们会为你提供一些特殊的使用说明和注意事项。
    2. [在模块系统中局部注册](#)
        - 如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。
        - 然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中：
            ```js
            import ComponentA from './ComponentA'
            import ComponentC from './ComponentC'
            
            export default {
              components: {
                ComponentA,
                ComponentC
              },
              // ...
            }
            ```
        - 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。
    3. [基础组件的自动化全局注册](#)
        - 可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。
        - ...

### Prop

- [Prop的大小写](#)
    1. [概要](#)
        - HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。
        - 这意味着当你使用DOM中的模板时，camelCase（驼峰命名法）的prop名需要使用其等价的kebab-case（短横线分隔命名）命名：
            ```html
            <!-- 在 HTML 中是 kebab-case 的 -->
            <blog-post post-title="hello!"></blog-post>
            
            <script>
                Vue.component('blog-post', {
                  // 在 JavaScript 中是 camelCase 的
                  props: ['postTitle'],
                  template: '<h3>{{ postTitle }}</h3>'
                })
            </script>
            ```
- [静态和动态的Prop](#)
    1. [概要](#)
        - 静态：`<blog-post title="My journey with Vue"></blog-post>`
        - 通过 v-bind 动态赋值：`<blog-post v-bind:title="post.title"></blog-post>`
        - 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。
    2. [传入一个数字](#)
        ```html
        <!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <blog-post v-bind:likes="42"></blog-post>
        
        <!-- 用一个变量进行动态赋值。-->
        <blog-post v-bind:likes="post.likes"></blog-post>
        ```
    3. [传入一个布尔值](#)
        ```html
        <!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->
        <blog-post favorited></blog-post>
        
        <!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <base-input v-bind:favorited="false">
        
        <!-- 用一个变量进行动态赋值。-->
        <base-input v-bind:favorited="post.currentUserFavorited">
        ```
    4. [传入一个数组](#)
        ```html
        <!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>
        
        <!-- 用一个变量进行动态赋值。-->
        <blog-post v-bind:comment-ids="post.commentIds"></blog-post>
        ```
    5. [传入一个对象](#)
        ```html
        <!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <blog-post v-bind:comments="{ id: 1, title: 'My Journey with Vue' }"></blog-post>
        
        <!-- 用一个变量进行动态赋值。-->
        <blog-post v-bind:post="post"></blog-post>
        ```
    6. [传入一个对象的所有属性](#)
        - 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：
            ```js
            post: {
              id: 1,
              title: 'My Journey with Vue'
            }
            ```
        - 下面的模板：
            ```html
            <blog-post v-bind="post"></blog-post>
            ```
        - 等价于：
            ```html
            <blog-post
              v-bind:id="post.id"
              v-bind:title="post.title"
            ></blog-post>
            ```
- [单向数据流](#)
    1. [概要](#)
        - 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
        - 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。
        - 这里有两种常见的试图改变一个 prop 的情形：
            1. 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
                ```js
                props: ['initialCounter'],
                data: function () {
                  return {
                    counter: this.initialCounter
                  }
                }
                ```
            2. 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：
                ```js
                props: ['size'],
                computed: {
                  normalizedSize: function () {
                    return this.size.trim().toLowerCase()
                  }
                }
                ```
        - **注意**，在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。
- [Prop验证](#)
    1. [概要](#)
        - 我们可以为组件的 prop 指定需求。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。
        - 为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：
            ```js
            Vue.component('my-component', {
              props: {
                // 基础的类型检查 (`null` 匹配任何类型)
                propA: Number,
                // 多个可能的类型
                propB: [String, Number],
                // 必填的字符串
                propC: {
                  type: String,
                  required: true
                },
                // 带有默认值的数字
                propD: {
                  type: Number,
                  default: 100
                },
                // 带有默认值的对象
                propE: {
                  type: Object,
                  // 对象或数组且一定会从一个工厂函数返回默认值
                  default: function () {
                    return { message: 'hello' }
                  }
                },
                // 自定义验证函数
                propF: {
                  validator: function (value) {
                    // 这个值必须匹配下列字符串中的一个
                    return ['success', 'warning', 'danger'].indexOf(value) !== -1
                  }
                }
              }
            })
            ```
        - 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。
        - 注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的属性 (如 data、computed 等) 在 default 或 validator 函数中是不可用的。
    2. [类型检查](#)
        - `type` 可以是下列原生构造函数中的一个：
            1. String
            2. Number
            3. Boolean
            4. Function
            5. Object
            6. Array
            7. Symbol
        - 额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数：
            ```js
            function Person (firstName, lastName) {
              this.firstName = firstName
              this.lastName = lastName
            }

            Vue.component('blog-post', {
              props: {
                author: Person
              }
            })
            ```
- [非Prop的特性](#)
    1. [概要](#)
        - 一个非 prop 特性是指：传向一个组件，但是该组件并没有相应 prop 定义的特性。
        - 因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。
    2. [替换/合并已有的特性](#)
        - 想象一下 组件`<bootstrap-date-input>` 的模板是这样的：
            ```html
            <input type="date" class="form-control">
            ```
        - 为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：
            ```html
            <bootstrap-date-input
              data-date-picker="activated"
              class="date-picker-theme-dark"
            ></bootstrap-date-input>
            ```
        - 在这种情况下，我们定义了两个不同的 class 的值：
            1. form-control，这是在组件的模板内设置好的
            2. date-picker-theme-dark，这是从组件的父级传入的
        - **对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值**。所以如果传入 type="text" 就会替换掉 type="date" 并把它破坏！**庆幸的是，class 和 style 特性会稍微智能一些，即两边的值会被合并起来，**从而得到最终的值：form-control date-picker-theme-dark。
    3. [禁用特性继承](#)
        - 如果你不希望组件的根元素继承特性，你可以设置在组件的选项中设置：`inheritAttrs: false`
        - 这尤其适合配合实例的 `$attrs` 属性使用，该属性包含了传递给一个组件的特性名和特性值
        - 有了 `inheritAttrs: false` 和 `$attrs`，你就可以手动决定这些特性会被赋予哪个元素。在撰写基础组件的时候是常会用到的
        - ...

### 自定义事件

### 插槽

### 动态组件 & 异步组件

- [在动态组件上使用keep-alive](#)
    1. [概要](#)
        - 我们之前曾经在一个多标签的界面中使用 `is` 特性来切换不同的组件：
            ```html
            <component v-bind:is="currentTabComponent"></component>
            ```
        - 当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。
        - 重新创建动态组件的行为通常是非常有用的,为了解决这个问题，我们可以用一个 `<keep-alive>` 元素将其动态组件包裹起来。
            ```html
            <!-- 失活的组件将会被缓存！-->
            <keep-alive>
              <component v-bind:is="currentTabComponent"></component>
            </keep-alive>
            ```
        - 注意这个 `<keep-alive>` 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。
        - 你可以在 API 参考文档 查阅更多关于 `<keep-alive>` 的细节。
- [异步组件](#)
    1. [概要](#)
        - ...待整理...
    2. [处理加载状态](#)

### 处理边界情况

## 过渡 & 动画

### 进入/离开 & 列表过渡

### 状态过渡

## 可复用性 & 组合

### 混入

### 自定义指令

### 渲染函数 & JSX

### 插件

- [开发插件](#)
    - 插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：
        1. 添加全局方法或者属性，如: vue-custom-element
        2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch
        3. 通过全局 mixin 方法添加一些组件选项，如: vue-router
        4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。
        5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router
    - Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：
        ```js
        MyPlugin.install = function (Vue, options) {
          // 1. 添加全局方法或属性
          Vue.myGlobalMethod = function () {
            // 逻辑...
          }
        
          // 2. 添加全局资源
          Vue.directive('my-directive', {
            bind (el, binding, vnode, oldVnode) {
              // 逻辑...
            }
            ...
          })
        
          // 3. 注入组件
          Vue.mixin({
            created: function () {
              // 逻辑...
            }
            ...
          })
        
          // 4. 添加实例方法
          Vue.prototype.$myMethod = function (methodOptions) {
            // 逻辑...
          }
        }
        ```
- [使用插件](#)
    - 通过全局方法 `Vue.use()` 使用插件：
        ```js
        // 调用 `MyPlugin.install(Vue)`
        Vue.use(MyPlugin)
        ```
    - 也可以传入一个选项对象：
        ```js
        Vue.use(MyPlugin, { someOption: true })
        ```
    - Vue.use 会自动阻止多次注册相同插件，届时只会注册一次该插件。
    - Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在例如 CommonJS 的模块环境中，你应该始终显式地调用 Vue.use()： 
        ```js
        // 用 Browserify 或 webpack 提供的 CommonJS 模块环境时
        var Vue = require('vue')
        var VueRouter = require('vue-router')
        
        // 不要忘了调用此方法
        Vue.use(VueRouter)
        ```
    - [awesome-vue](https://github.com/vuejs/awesome-vue#components--libraries) 集合了来自社区贡献的数以千计的插件和库。
    
### 过滤器

- Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 `v-bind` 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：
    ```js
    <!-- 在双花括号中 -->
    {{ message | capitalize }}
    
    <!-- 在 `v-bind` 中 -->
    <div v-bind:id="rawId | formatId"></div>
    ```
- 注册组件
    1. 在一个组件的选项中定义本地的过滤器：
        ```js
        filters: {
          capitalize: function (value) {
            if (!value) return ''
            value = value.toString()
            return value.charAt(0).toUpperCase() + value.slice(1)
          }
        }
        ```
    2. 在创建 Vue 实例之前全局定义过滤器：
        ```js
        Vue.filter('capitalize', function (value) {
          if (!value) return ''
          value = value.toString()
          return value.charAt(0).toUpperCase() + value.slice(1)
        })
        
        new Vue({
          // ...
        })
        ```
- 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。
- `{{ message | filterA | filterB }}`
- `{{ message | filterA('arg1', arg2) }}`

## 工具

### 生产环境部署

### 单文件组件

### 单元测试

### TypeScript支持

## 规模化

### 路由

- [官方路由](#)
    1. [概要](#)
        - 对于大多数单页面应用，都推荐使用官方支持的 vue-router 库。更多细节可以看 [vue-router 文档](https://router.vuejs.org/zh-cn/)。
- [从零开始简单的路由](#)
- [整合第三方路由](#)

### 状态管理

### 服务端渲染

## 内在

### 深入响应式原理

## 迁移

### 从Vue 1.x迁移

### 从Vue Router 0.7.x迁移

### 从Vue 0.6.x迁移到1.0

<!-- 
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#)
- [](#)
    1. [概要](#) 
-->