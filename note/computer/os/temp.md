进程是os执行一个可执行二进制文件的产物。 

什么是“可执行二进制文件”？
os会检查文件是否符合“可执行二进制文件”的一些格式或者规范。

而程序一般不会直接和硬件接触，而是和os打交道，不同平台的可执行文件格式和规范
可能不一致，会存在直接的不兼容问题，但是兼容的问题可以通过一定的方式来处理。

 Linux操作系统的可执行文件格式详细解析 2008-10-06 18:47:38
分类： LINUX
可执行文件可以是具有不同格式的二进制文件，也可以是一个文本的脚本。可执行文件映像中包含了进程执行的代码和数据，同时也包含了操作系统用来将映像正确装入内存并执行的信息。在Linux中，当前的“本地”(系统默认的)可执行文件格式是ELF[15] (Executable and Linking Format)可执行链接格式。由于先前的a.out格式难于实现共享库，不能适用于动态链接，所以目前已经全部被ELF所替换。不过，Linux仍然为 a.out保留了一个二进制处理程序，但通常是使用ELF。
Linux的加载程序一般是根据内嵌在可执行文件开头的“magic序列”(一个特殊字节序列)来识别文件，有时也会通过文件名的一些特性。例如，Java编译处理程序可以保证其文件名以.class结尾，并且文件起始前四个字节是 0xcafebabe，这是Java标准所定义的。下面是2.4版本内核在Intel体系下所提供的二进制处理程序，理论上，Linux灵活到足以处理几乎所有的目标文件格式。
(1)a.out(在fs/binfmt_aout.c中)：这是为了支持原来风格的Linux二进制文件。它的存在主要是为了满足一些系统的向后兼容的需要，但是基本上a.out已经光荣退役了。
(2) ELF(在fs/binfmt_elf.c中)：目前是Linux默认的二进制文件格式。该格式在可执行文件和共享库中都广泛使用。最新的Linux系统 (例如Red Hat 9)一般只预装了ELF二进制文件解释器，但是特殊情况下要决定加载a.out二进制文件，那么系统也通过模块的方式，对它提供支持。虽然ELF被作为惯用的Linux本地格式，但也和其它格式一样使用同一个加载处理程序。
(3)EM86(在fs/binfmt_em86.c中)：允许在Alpha机器上运行Intel的Linux二进制文件，仿佛它们就是Alpha的本地二进制文件。
(4) Java(在fs/binfmt_java.c中)：可以不必每次都定义Java字节码的解释程序就可以执行Java的.class文件。这种机制和脚本中使用的机制类似，通过把.class文件的文件名作为参数传递，处理程序返回执行整型字节码的解释程序。从用户的观点来看，Java二进制文件是作为本地可执行文件处理的。
(5)misc(在fs/binfmt_misc.c中)：这是最明智地使用二进制处理程序的方法，这个处理程序通过内嵌的特征数字或者文件名后缀可以识别出各种二进制格式，不过最优秀的特性是它可以在运行期配置，而不是只能在编译期配置。因此，只要遵循其规则，就可以快速的增加对新二进制文件的支持，而不用重新编译内核，也无须重新启动机器。Linux源程序文件中的注释建议最终使用它来取代Java和EM86二进制处理程序。
(6)脚本(在fs/binfmt_script.c中)：对于shell脚本、Perl脚本等提供支持。宽松一点地说，所有前面两个字符是“#!”的可执行文件，都归由这个二进制处理程序进行处理。
这些Linux支持的二进制格式，可以在内核编译链接的时候直接建立在内核之中，也可以在内核运行的时候作为模块来加载。内核保存了支持的二进制格式解释程序的列表，当试图执行一个文件的时候，每一个二进制格式都会被依次尝试，直到判断出可识别的对应的二进制格式为止。

流程：

nodejs的js语法代码 -> 被v8转换为c++代码 -> 然后所有的c++代码被编译、连接，转换为二进制代码 -> 二进制还有机器码和数据，这些都是可以被cpu识别的

那么机器码具体是什么？

机器码对应着指令集

机器指令（Machine Instructions）是CPU能直接识别并执行的指令，它的表现形式是二进制编码。机器指令通常由操作码和操作数两部分组成，操作码指出该指令所要完成的操作，即指令的功能，操作数指出参与运算的对象，以及运算结果所存放的位置等。
由于机器指令与CPU紧密相关，所以，不同种类的CPU所对应的机器指令也就不同，而且它们的指令系统往往相差很大。但对同一系列的CPU来说，为了满足各型号之间具有良好的兼容性，要做到：新一代CPU的指令系统必须包括先前同系列CPU的指令系统。只有这样，先前开发出来的各类程序在新一代CPU上才能正常运行。