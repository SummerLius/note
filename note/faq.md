<!-- TOC -->

- [webstorm忽略文件或目录设置？](#webstorm忽略文件或目录设置)
- [Endianness](#endianness)

<!-- /TOC -->

## webstorm忽略文件或目录设置？

两种方式：
1. Directories > Mark as: Excluded
2. Editor > File Types > ignore files and folders

## Endianness
<!-- 
- 磁盘（文本）中的数据
    - 源文件
    - 可执行文件
- 内存中的数据

1. utf编码的源文件

首先对于，unicode编码有有utf8、utf16、utf32三种编码形式，其中编码单元分别为：8bit、16bit、32bit。以unicode字符“刘”为例子
- “刘”
- utf8
    - e5 88 98
    - 11100101 10001000 10011000
- utf16
    - 52 18
    - 01010010 00011000
- utf32
    - 00 00 52 18 
    - 00000000 00000000 01010010 00011000

注意观察上面编码的二进制表示，utf16和utf32编码的字符，和其字符码点其实是一一对应的。而utf8是最特殊的，其通过特殊的规则，将字符编码成具有特定规则的序列，就像下面这样

0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

这样有个有趣的点就是，utf8的字符序列头部字节是确定的，你反转一个字符的utf8编码序列，你可以很简单的根据规则将其复原。相反，utf16和utf32不能，因为其对应的字符的字节序列，没有头尾特征，所以其字节序列不能随便反转。

但是由于某些机器大小端问题，可能会反转的相关问题，所以utf16和utf32就进一步细化为反转的和不反转的字节序列：小端LE和大端BE

    ```sh
    # bom 问题
    # 大端小端问题

    # 有点糊涂
    
    1. 内存寻址
    2. utf16/32
    3. cpu指令


    以C语言理解，程序中的数据对象都有具体的设置，例如，一个int数据占四个字节，每个字节都有一个地址，但是c语言中仅仅引用低位地址就行，具体的操作，例如cpu指令集，会有类似这样的命令：“mov 地址 长度4”

    对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。

    大端小端，是直接保存到磁盘文件中

    1. 文本编码的unicode大端、小端的体现（utf16le utf16be 等）  磁盘存储体现（文件）
    2. 内存中数据大端、小端的体现     内存存储体现

    对于文本无论什么编码，还是什么大端小端，各种标识，都是为了能够确定都能识别编码的字符到对应的unicode码点


    源码字符集
    执行字符集
    运行环境编码
    https://blog.csdn.net/benkaoya/article/details/59522148
    ```
 -->

