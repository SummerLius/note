
## 预备知识

1. 假设客户端HTTP请求途径为：`client` --> `proxy server1` --> `proxy server2` --> `final server`
2. 那么一般情况下，request每个位置headers里面的x-forwarded-for的值为：
    - `client`：客户端创建http包，此时还没有x-forwarded-for字段
    - `proxy server1`：修改http包，修改后的x-forwarded-for值为"client"
    - `proxy server2`：修改http包，修改后x-forwarded-for值为"client, proxy server1"
    - `final server`：收到的http包，此时x-forwarded-for的值即为`proxy server2`修改后的值 "client, proxy server1"
3. 结论：
    - 对于代理服务器来说，修改x-forwarded-for时，只会将**直连**的client的ip追加到后面，不会将自身的ip写入到里面
4. `req.ip`：若'trust proxy'开启，则去最左边一个，详细见...
5. `req.ips`：若'trust proxy'开启，则返回x-forwarded-for的ip数组，否者返回空数组


## Express trust proxy

- Express涉及的函数、变量
    - `app.set('trust proxy', xxx)`
    - `app.get('trust proxy')`
    - `app.enabled('trust proxy')`
    - req.ip
    - req.ips
- 逻辑：
    1. 首先Express整合remoteAddress TCP直连ip地址和HTTP头x-forwarded-for的ip列表，得到整个过程中的IP列表：proxyAddr=[remoteAddress, proxy server1, client]，此处的remoteAddress就是proxy server2，注意此时是经过倒序处理的，即列表中的IP越靠前，离final server最近，下面进行trust信任比较便是依此顺序进行的
    2. 然后Express进行for循环依次每个IP进行“是否是信任的代理服务器”比较，比较有几个要点、规则
        - 使用`app.get('trust proxy fn')`返回的函数进行比较
        - 整个proxyAddr列表，最后一位不比较。（因为如果比较过程执行到最后一位时，表示前面的ip都是信任的代理IP，不管最后一个IP是否是信任的ip，那么此时都只能把最后一位作为 client IP，即req.ip的值）
        - 在哪终止，在哪截断。只要比较过程中某一个IP，trust(proxyAddr[i])，判断返回为false，则立刻终止，而且proxyAddr进行截断：从开始~到该IP（包含该ip），例如，假如proxyAddr=[5,4,3,2,1]，到3时判断false，则proxyAddr截断为[5,4,3]，此时3就是client IP
    3. proxyAddr循环判断完后，得到ip值
        - req.ip = proxyAddr[proxyAddr.length-1]，即最后一位（因为之前进行逆序处理，故取最后一位）
        - req.ips = proxyAddr.reverse().pop()，逆序回来，并弹出remoteAddress，即仅保留x-forwarded-for中的ip值
- 判断函数设置：`app.get('trust proxy fn')`
    - **设置方法**：`app.set('trust proxy', 值)`，该方法会生成两个`app.settings.xxx`属性，分别为:
        - `app.settings['trust proxy'] = 值`，存储原始赋值
        - `app.settings['trust proxy fn'] = proxyaddr.compile(值)`，生成函数，用来判断是否是信任ip
    - **设置的值类型**
        - Boolean
            - `false（默认）`：trustFn = proxy-addr.compile([])，基本上无论输入什么IP地址，都返回false（测试猜测）
                - 逻辑：由于trustFn无论输入都返回false，故proxyAddr[0]比较就false，故proxyAddr直接截断为：[remoteAddress]，仅保留一个TCP直连IP
                - 结果：req.ip = remoteAddress，rep.ips = []
            - `true`：trustFn = function(){return true}，都返回true
                - 逻辑：proxyAddr循环比较都为true，不截断，整体保留
                - 结论：req.ip = "proxyAddr最后一位"，req.ips = "proxyAddr弹出remoteAddress，然后逆序"
        - number
            - 函数：trustFn = function(ip, i) {return i < number;}
            - 逻辑：该值直接限定proxyAddr循环到某一个位置就截断，理解记忆的话，可以理解为表示信任的代理IP有number个，则proxyAddr截断保留number+1个长度，这个最后一个认为是client IP
            - 例如：假设proxyAddr=[5,4,3,2,1]，指定number=2，则proxyAddr截断为[5,4,3]，前2个是已知的信任代理，认为第3个是client IP
        - string/array
            - 函数：trustFn = proxy-addr.compile(string/array)，给定一个信任的代理IP列表，用来进行判断
            - 逻辑：proxyAddr循环依次使用trustFn函数判断，若某次ip判断为false，则在此截断，此ip即为client IP
            - 逻辑：[5,4,3,2,1]，3处判断为false，则截断为[5,4,3]
        - function
            - 函数：trustFn = function(proxyAddr[i], i){ 自定义 }
            - 逻辑：同上













```javascript
// express 默认值
app.set('trust proxy', false)
app.set('trust proxy fn', proxyaddr.compile([]));

app.enabled('trust proxy'); // false
app.get('trust proxy'); // false

// 手动设置
```

```javascript
// app.set() 函数内部逻辑
// trust proxy 原始值
// trust proxy fn 格式化后的值

let val = '127.0.0.1';
app.set('trust proxy', val);

app.settings['trust proxy'] = val
app.set('trust proxy fn', compileTrust(val));

// compileTrust： Boolean、ip、number、function
// 使用proxyaddr包
1. 如果是函数，返回val
2. 如果是Boolean，且为true，返回 function(){return true;}
3. 如果是number，返回 function(a,i){return i < val;}
4. 如果是string或array，使用proxyaddr.compile(val)构造函数
```

```javascript

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

////////
exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(/ *, */);
  }

  return proxyaddr.compile(val || []);
}

```

