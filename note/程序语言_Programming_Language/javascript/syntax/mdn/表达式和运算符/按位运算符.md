# 按位运算符

## 概述

|运算符|用法|描述|
|:--:|:--:|:--:|
|按位与（ AND）|a & b|对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。|
|按位或（OR）|a | b|对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。|
|按位异或（XOR）|a ^ b|对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。|
|按位非（NOT）|~ a|反转操作数的比特位，即0变成1，1变成0。|
|左移（Left shift）|a << b|将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。|
|有符号右移|a >> b|将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用符号位在左侧填充。|
|无符号右移|a >>> b|将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。|
||||

- 按位操作符（Bitwise operators）将其操作数（operands）当做 32 位的二进制序列；


## 有符号32位运算符

- 按位运算符的操作数都会被转成**补码形式的有符号32位整数**；
- 32位有符号数字所能表示的最大整数和最小整数：
    - 2147483647（01111111111111111111111111111111）
    - -2147483648（10000000000000000000000000000000）
- 32位有符号数限制下：常见十进制数值对应二进制补码序列
    - 2147483647（0x7fffffff）（01111111111111111111111111111111）
    - -2147483648（-0x80000000）（10000000000000000000000000000000）
    - -2147483647（10000000000000000000000000000001）
    - -1（11111111111111111111111111111111）
- 示例
    ```js
    0x80000000 // 2147483648
    0x80000000 | 0 // -2147483648

    ```


```text
> 对于负数求补码说法不一

说法一
    - 例如 “-18”，
    - 起点原序列从18的二进制序列开始（即符号位0）：0000 0000 0000 0000 0000 0000 0001 0010
    - 对上面18的序列全部取反（包括符号位）：1111 1111 1111 1111 1111 1111 1110 1101
    - 然后加一：1111 1111 1111 1111 1111 1111 1110 1110
说法二
    - 例如 “-18”
    - 起点序列从-18开始（即符号为1）：1000 0000 0000 0000 0000 0000 0001 0010
    - 对上全部取反（不包括符号位）：1111 1111 1111 1111 1111 1111 1110 1101
    - 然后加一：1111 1111 1111 1111 1111 1111 1110 1110

两者说法结果一样，这里先倾向采用第二种
```

## 按位逻辑运算符

- 从概念上讲，按位逻辑运算符遵守下面规则
    - 操作数被转换为32位整数，超过32位的数字会被丢弃；
    - 位操作包括符号位；
- 示例
    ```js
    // 十进制为：34359738367
    0b11111111111111111111111111111111111

    // 结果为： -1
    0b11111111111111111111111111111111111 | 0
    ```

### 与

- 对每比特位执行与操作；
- 设任一数值 `x`
    - ` x & 0 === 0`，原因在于数值 0 对应的比特序列为32个0；
    - ` x & -1 === x` ，原因在于数字 -1 对应的比特序列为32个1；
    - ` x & x === x` ；

### 或

- 对每比特位执行或操作；
- 设任一数值 `x`
    - `x | 0 === x`；
    - `x | -1 === -1`；
    - `x | x === x`；

### 异或

- 对每比特位执行异或操作；
- 设任一数值 `x`
    - `x ^ 0 === x`；
    - `x ^ -1 === ~x`；
    - `x ^ x === 0`；

### 非

- 对每比特位执行非操作
- 设任一数值 `x`
    - `~x === -(x + 1)`
    - `~-1 === 0`
    - `~0 === -1`

## 按位移动运算符

- 按位移动运算符有两个操作数：被移动的数子和要移动的长度；

### 左移动 <<

- 该运算符将左操作数向左移动指定位数，向左被移出的位被丢弃，右侧用 0 补充；
    ```js
    // 左操作数为：31个比特位为1，即32位有符号最大正整数
    0b1111111111111111111111111111111 << 1 // -2

    2 << 1 // 4
    -1 << 1 // -2
    ```
- 在可控范围内：在数字 x 上左移 y 比特位得到 `x * 2 ** y`

### 有符号右移 >>

- 该操作符将左操作数向右移动指定的位数，向右被移出的位被丢弃，并拷贝最左侧的位以填充左侧；
- 由于新的最左侧的位总和之前相同，符号位没有改变，所以被称为“符号传播”；
    ```js
    9 >> 2 // 2
    -9 >> 2 // -3
    ```

### 无符号右移 >>>

- 该操作符将左操作数向右移动指定位数，向右被移出的位被丢弃，左侧用 0 填充；
- 因为符号位变成了 0 ，所以结果总是非负的；
- 对于非负数，有符号右移和无符号右移总是返回相同的结果；
- 对于负数，两者结果就不同了；
    ```js
    -9 >>> 2 // 1073741821
    -9 >> 2 // -3
    ```
