# 链接

<!-- TOC -->

- [链接](#链接)
    - [概述](#概述)
    - [静态库](#静态库)
    - [工具](#工具)
        - [gcc](#gcc)
        - [ld](#ld)
        - [ar](#ar)

<!-- /TOC -->

## 概述

链接（linking）是将各种代码和数据片段集合成单一文件的过程，即可执行文件，可以加载到内存中执行。

linking可以执行的时间点：
1. 编译时，即源代码翻译成机器码时
2. 加载时，即程序被加载器加载到内存执行时
3. 运行时，在程序运行过程中，由应用程序来执行linking操作

现代系统中，linking由链接器（linker）程序自动执行。

链接器作用：链接器在软件开发中扮演重要角色，其使得分离编译称为可能，不用将源代码每次都全部编译，而是可以划分
子部分编译，最后链接到一起。



三种目标形式：
1. 可重定位目标文件
2. 共享目标文件：一种特殊类型的可重定位目标文件
3. 可执行目标文件

编译器和汇编器生成可重定位目标文件（包括共享目标文件）。  
链接器生成可执行目标文件。

## 静态库

链接可以linking可重定位目标文件（xxx.o文件），这样的文件会把整个.o文件副本拷贝到可执行文件。

如果以可重定位目标文件（xx.o）为库，那么有两个问题：
1. 可重定位目标文件xx.o会被链接器整个拷贝到可执行文件，如果多个函数都被写到一个可重定位目标文件，那么该文件可能会很大，会占内存，而且程序不一定会用到该库的所有函数。
2. 第一个问题，多个函数集中到一个可重定位目标文件会造成，文件过大。所以，接下来的思路，分而治之，将每类函数编译成对应的.o文件，程序需要什么函数就链接对应的库文件，但这样一个问题就是库文件太过分散，链接库列表会很长，不利于开发，例如`gcc main.c /printf.o /scanf.o ...`

**故提出了静态库的概念，以解决上述方法缺点。相关函数被编译成独立的目标模块（即可重定位目标文件），然后封装成一个单独的静态库文件。**

**程序代码中，如果引用了相关模块，然后在链接时，链接器只是复制静态库中被程序引用的模块，这样就减少了可执行文件的大小。**


## 工具

### gcc

### ld

### ar